<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オンライン対戦対応 召喚将棋 (改良版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@600&display=swap');

        :root {
            --board-bg: #E8C99B;
            --board-border: #8B4513;
            --cell-bg: #F0D9B5;
            --cell-hover: #FFE4B5;
            --highlight: #FFFF99;
            --highlight-move: rgba(50, 255, 50, 0.4);
            --highlight-attack: rgba(255, 50, 50, 0.4);
            --main-bg: #F5F5DC;
            --text-color: #333;
            --button-primary: #8B4513;
            --button-hover: #A0522D;
            --button-disabled: #cccccc;
            --sente-color: #000;
            --gote-color: #000;
            --header-bg: #8B4513;
            --header-text: #FFF;
            --promotion-bg: rgba(0, 0, 0, 0.7);
            --chat-bg: #fff;
            --chat-border: #ddd;
            --chat-message-sent: #e1f5fe;
            --chat-message-received: #f5f5f5;
            --piece-sente-bg: #f9e0a2;
            --piece-sente-border: #c19a6b;
            --piece-gote-bg: #f0f0f0;
            --piece-gote-border: #bbbbbb;
            --piece-shadow: rgba(0, 0, 0, 0.3);
            --modal-bg: rgba(0, 0, 0, 0.7);
            --game-list-hover: #f0f0f0;
            --game-list-active: #e6f7ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--main-bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            position: relative;
        }

        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            width: 100%;
            padding: 15px 20px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .back-to-title-btn {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .back-to-title-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%) scale(1.05);
        }

        .back-to-title-btn:active {
            transform: translateY(-50%) scale(0.98);
        }

        .sync-btn {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            padding: 8px 16px;
            background-color: rgba(76, 175, 80, 0.3);
            color: white;
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .sync-btn:hover {
            background-color: rgba(76, 175, 80, 0.5);
            transform: translateY(-50%) scale(1.05);
        }

        .sync-btn:active {
            transform: translateY(-50%) scale(0.98);
        }

        .sync-btn.syncing {
            animation: rotate 1s linear infinite;
        }

        @keyframes rotate {
            from {
                transform: translateY(-50%) rotate(0deg);
            }

            to {
                transform: translateY(-50%) rotate(360deg);
            }
        }


        h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8rem;
            margin: 0;
        }

        .user-info {
            display: flex;
            align-items: center;
            margin-top: 10px;
            color: white;
            font-size: 0.9em;
        }

        .user-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
            color: #333;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }

        .board-area {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            overflow: auto;
            padding-bottom: 120px;
        }

        .board-toolbar {
            display: flex;
            justify-content: flex-end;
            width: 100%;
            margin-bottom: 6px;
            gap: 8px;
        }

        .board-toggle-button {
            background-color: var(--button-primary);
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.85em;
            cursor: pointer;
            transition: background-color 0.2s;
            flex: none;
        }

        .board-toggle-button:hover {
            background-color: var(--button-hover);
        }

        #chat-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: flex-end;
            padding: 40px;
            box-sizing: border-box;
            z-index: 9999;
        }

        #chat-overlay.active {
            display: flex;
        }

        body.chat-overlay-active {
            overflow: hidden;
        }

        .chat-panel {
            position: relative;
            width: min(420px, 90vw);
            max-height: 90vh;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.35);
            padding: 24px 24px 18px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            pointer-events: auto;
        }

        #result-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }

        #result-overlay.active {
            display: flex;
        }

        body.result-overlay-active {
            overflow: hidden;
        }

        .result-panel {
            background: radial-gradient(circle at top, rgba(255, 255, 255, 0.98), rgba(245, 245, 245, 0.95));
            border-radius: 20px;
            padding: 48px 56px;
            text-align: center;
            box-shadow: 0 40px 80px rgba(0, 0, 0, 0.4);
            max-width: 520px;
            width: 90vw;
            transform: scale(0.85);
            opacity: 0;
            animation: result-pop-in 0.4s ease-out forwards;
        }

        #result-title {
            font-size: 3rem;
            margin-bottom: 12px;
            font-family: 'Noto Serif JP', serif;
            letter-spacing: 0.2em;
        }

        #result-subtitle {
            font-size: 1.1rem;
            color: #555;
            margin-bottom: 28px;
        }

        .result-buttons {
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .result-button {
            min-width: 140px;
            padding: 12px 18px;
            border-radius: 999px;
            border: none;
            font-weight: bold;
            background: var(--button-primary);
            color: #fff;
            cursor: pointer;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            flex: none;
        }

        .result-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
            background: var(--button-hover);
        }

        .result-button:active {
            transform: translateY(1px);
        }

        @keyframes result-pop-in {
            0% {
                opacity: 0;
                transform: scale(0.85);
            }

            60% {
                opacity: 1;
                transform: scale(1.05);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
            pointer-events: none;
        }

        .toast {
            min-width: 240px;
            max-width: 420px;
            padding: 12px 18px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-weight: bold;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .toast-info {
            background: rgba(33, 150, 243, 0.9);
        }

        .toast-success {
            background: rgba(46, 204, 113, 0.9);
        }

        .toast-warn {
            background: rgba(241, 196, 15, 0.92);
            color: #4a3600;
        }

        .toast-error {
            background: rgba(231, 76, 60, 0.92);
        }

        .chat-close-button {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            color: #444;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease, transform 0.2s ease;
            flex: none;
        }

        .chat-close-button:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .chat-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #summon-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #e60000;
            color: #fff;
            font-size: 1.1em;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 0.2em;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(230, 0, 0, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            padding: 0;
            flex: none;
            z-index: 5;
        }

        #summon-button:hover:not(:disabled),
        #summon-button:focus-visible:not(:disabled) {
            background-color: #e60000;
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 14px 30px rgba(230, 0, 0, 0.45);
        }

        #summon-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: translateX(-50%);
            box-shadow: none;
            background-color: #e60000;
        }

        #summon-button:active:not(:disabled) {
            transform: translateX(-50%) scale(0.96);
        }

        .coordinates {
            display: flex;
            justify-content: space-around;
            width: 450px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .row-coordinates {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 450px;
            font-weight: bold;
            margin-right: 5px;
        }

        .board-with-coords {
            display: flex;
            align-items: center;
        }

        .board {
            width: 450px;
            height: 450px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            background-color: var(--board-border);
            padding: 2px;
            border: 5px solid var(--board-border);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .board::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23E8C99B" fill-opacity="0.5"/><path d="M0,20 L100,20 M0,40 L100,40 M0,60 L100,60 M0,80 L100,80 M20,0 L20,100 M40,0 L40,100 M60,0 L60,100 M80,0 L80,100" stroke="%238B4513" stroke-width="0.5" stroke-opacity="0.3"/></svg>');
            background-size: 50px 50px;
            opacity: 0.5;
            z-index: 0;
            pointer-events: none;
        }

        .cell {
            background-color: var(--cell-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .cell:hover {
            background-color: var(--cell-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .cell.highlighted {
            background-color: var(--highlight);
        }

        .cell.highlight-move {
            background-color: var(--highlight-move);
        }

        .cell.highlight-attack {
            background-color: var(--highlight-attack);
        }

        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5em;
            font-weight: bold;
            user-select: none;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 2;
            --piece-rotation: 0deg;
            transform: rotate(var(--piece-rotation));

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            --piece-rotation: 0deg;
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            --piece-rotation: 180deg;
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        body.board-flipped .piece.sente {
            --piece-rotation: 180deg;
        }

        body.board-flipped .piece.gote {
            --piece-rotation: 0deg;
        }

        .piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .piece.selected {
            box-shadow: 0 0 0 3px #ff0, 0 4px 6px var(--piece-shadow);
            transform: rotate(var(--piece-rotation)) scale(1.1);
        }

        .piece.animated {
            animation: pop-in 0.3s ease-out forwards;
        }

        @keyframes pop-in {
            0% {
                transform: rotate(var(--piece-rotation)) scale(0.5);
                opacity: 0;
            }

            70% {
                transform: rotate(var(--piece-rotation)) scale(1.1);
            }

            100% {
                transform: rotate(var(--piece-rotation)) scale(1);
                opacity: 1;
            }
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 450px;
        }

        .status-panel {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            background-color: #f0f0f0;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status.sente-turn {
            background-color: #ffe6e6;
        }

        .status.gote-turn {
            background-color: #e6f0ff;
        }

        .status.check {
            background-color: #ffcccc;
            animation: pulse 1.5s infinite;
        }

        .status.gameover {
            background-color: #ffcc00;
            font-size: 1.2em;
            padding: 15px;
            animation: victory-pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes victory-pulse {
            0% {
                transform: scale(1);
                background-color: #ffcc00;
            }

            50% {
                transform: scale(1.05);
                background-color: #ffd700;
            }

            100% {
                transform: scale(1);
                background-color: #ffcc00;
            }
        }

        .hand-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .hand-title {
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hand-title span {
            font-size: 0.9em;
            color: #777;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 60px;
        }

        .hand-piece {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-weight: bold;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;
            --hand-rotation: 0deg;
            transform: rotate(var(--hand-rotation));

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .hand-piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            --hand-rotation: 0deg;
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        .hand-piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            --hand-rotation: 180deg;
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        body.board-flipped .hand-piece.sente {
            --hand-rotation: 180deg;
        }

        body.board-flipped .hand-piece.gote {
            --hand-rotation: 0deg;
        }

        .hand-piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .hand-piece:hover {
            background-color: var(--highlight);
            transform: rotate(var(--hand-rotation)) scale(1.05);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .hand-piece.gote:hover {
            transform: translateY(-2px) rotate(180deg);
        }

        /* 召喚した駒の強調表示 */
        .hand-piece.summoned {
            animation: summon-glow 1.5s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 4px 6px rgba(0, 0, 0, 0.15);
            border: 3px solid #FFD700;
            background: linear-gradient(135deg, #FFF8DC 0%, #F0E68C 100%);
        }

        .hand-piece.summoned.sente {
            color: #8B4513;
        }

        .hand-piece.summoned.gote {
            color: #2d6a4f;
        }

        @keyframes summon-glow {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 4px 6px rgba(0, 0, 0, 0.15);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 6px 8px rgba(0, 0, 0, 0.2);
            }
        }


        .summon-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .summon-title {
            margin-bottom: 10px;
            font-weight: bold;
        }

        .summon-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
            margin-bottom: 10px;
        }

        .summon-piece {
            padding: 5px 8px;
            background-color: #f0d9b5;
            border: 1px solid #c19a6b;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 12px;
            background-color: var(--button-primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.2s ease;
            flex: 1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .rules-container {
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .rules-toggle {
            cursor: pointer;
            color: var(--button-primary);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .rules-toggle::after {
            content: "▼";
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .rules-toggle.open::after {
            transform: rotate(180deg);
        }

        .rules-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .rules-content.show {
            max-height: 800px;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 20px;
            margin: 10px 0;
        }

        .rules-content li {
            margin-bottom: 8px;
        }

        .piece-movement {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .move-diagram {
            text-align: center;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 90px;
            height: 90px;
            margin: 0 auto 5px;
        }

        .move-cell {
            width: 30px;
            height: 30px;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
        }

        .move-cell.can-move {
            background-color: var(--highlight);
        }

        .move-cell.piece {
            background-color: #ffedcc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* プロモーションダイアログ */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--promotion-bg);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 300px;
            width: 100%;
        }

        .promotion-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .promotion-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .promotion-option {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8em;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .promotion-option:nth-child(1) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option:nth-child(2) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .promotion-option:hover {
            background-color: var(--highlight);
            transform: scale(1.1);
        }

        /* オンライン対戦用スタイル */
        .online-controls {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            width: 100%;
            max-width: 450px;
        }

        .online-controls h3 {
            margin-bottom: 15px;
            text-align: center;
            color: var(--board-border);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }

        .tab-button {
            padding: 8px 15px;
            background-color: transparent;
            color: #666;
            border: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            box-shadow: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background-color: #f5f5f5;
            box-shadow: none;
        }

        .tab-button.active {
            color: var(--button-primary);
            border-bottom: 3px solid var(--button-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #game-info {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
        }

        #game-code {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--board-border);
        }

        #player-role {
            font-weight: bold;
        }

        #join-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #game-code-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        #join-submit {
            white-space: nowrap;
        }

        .public-games-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .public-game-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .public-game-item:last-child {
            border-bottom: none;
        }

        .public-game-item:hover {
            background-color: var(--game-list-hover);
        }

        .public-game-info {
            display: flex;
            flex-direction: column;
        }

        .public-game-host {
            font-weight: bold;
        }

        .public-game-time {
            font-size: 0.8em;
            color: #888;
        }

        .public-game-status {
            font-size: 0.75em;
            color: #a0522d;
            font-weight: bold;
        }

        .join-public-button {
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .join-public-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .no-games-message {
            padding: 15px;
            text-align: center;
            color: #999;
        }

        .wait-message {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }

        .turn-indicator {
            padding: 5px 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .your-turn {
            background-color: #d4edda;
            color: #155724;
        }

        .opponent-turn {
            background-color: #f8d7da;
            color: #721c24;
        }

        /* リマッチ対応 */
        #rematch-controls {
            display: none;
            margin-top: 15px;
            text-align: center;
        }

        #rematch-button {
            width: 100%;
            background-color: #4caf50;
        }

        #rematch-button:hover {
            background-color: #45a049;
        }

        #rematch-status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        /* 制限時間表示 */
        .timer-container {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 8px;
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .timer {
            flex: 1;
            text-align: center;
            padding: 6px 10px;
            border-radius: 6px;
            background-color: #f0f0f0;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .timer.active {
            background-color: #ffe6e6;
            box-shadow: 0 0 10px rgba(230, 0, 0, 0.3);
        }

        .timer.warning {
            background-color: #ffcccc;
            animation: timer-pulse 1s infinite;
        }

        @keyframes timer-pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .timer-label {
            font-size: 0.75em;
            font-weight: bold;
            color: #666;
            margin-bottom: 3px;
        }

        .timer-value {
            font-size: 1.3em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .timer.warning .timer-value {
            color: #e60000;
        }

        .time-settings {
            margin-bottom: 15px;
            padding: 15px;
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .time-settings label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }

        .time-settings select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            background-color: white;
        }

        .time-settings select:focus {
            outline: none;
            border-color: var(--button-primary);
        }


        /* チャット機能のスタイル */
        .chat-container {
            background-color: var(--chat-bg);
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            display: none;
        }

        .chat-container h3 {
            margin-bottom: 10px;
            text-align: center;
            color: var(--board-border);
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fafafa;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            max-width: 80%;
            word-break: break-word;
        }

        .chat-message.sent {
            background-color: var(--chat-message-sent);
            margin-left: auto;
            border-bottom-right-radius: 0;
        }

        .chat-message.received {
            background-color: var(--chat-message-received);
            margin-right: auto;
            border-bottom-left-radius: 0;
        }

        .chat-message-time {
            font-size: 0.7em;
            color: #888;
            text-align: right;
            margin-top: 2px;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
        }

        #chat-input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            font-size: 1em;
        }

        #chat-submit {
            white-space: nowrap;
            background-color: #4caf50;
        }

        #chat-submit:hover {
            background-color: #45a049;
        }

        /* プリセットメッセージ */
        .preset-messages {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .preset-message {
            font-size: 0.8em;
            padding: 5px 8px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-message:hover {
            background-color: #e0e0e0;
        }

        /* ログインモーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-bg);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .modal-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: var(--board-border);
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 1em;
        }

        .modal-error {
            color: #dc3545;
            font-size: 0.9em;
            margin-bottom: 15px;
            display: none;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .header {
                padding: 15px 10px;
            }

            .back-to-title-btn {
                position: static;
                transform: none;
                margin-bottom: 10px;
                font-size: 0.85em;
                padding: 6px 12px;
            }

            .back-to-title-btn:hover {
                transform: scale(1.05);
            }

            .back-to-title-btn:active {
                transform: scale(0.98);
            }

            .game-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .board {
                width: 90vw;
                height: 90vw;
                max-width: 450px;
                max-height: 450px;
            }

            .coordinates,
            .row-coordinates {
                font-size: 0.8em;
            }

            .coordinates {
                width: 90vw;
                max-width: 450px;
            }

            .row-coordinates {
                height: 90vw;
                max-height: 450px;
            }

            .controls,
            .online-controls,
            .chat-container {
                width: 90vw;
                max-width: 450px;
            }

            .piece {
                font-size: 3.5vw;
            }

            .rules-container {
                width: 90vw;
                padding: 15px;
            }

            .button-group {
                flex-direction: column;
            }

            .tab-button {
                padding: 8px 10px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .piece {
                font-size: 4vw;
            }

            .hand-piece {
                width: 35px;
                height: 35px;
                font-size: 0.9em;
            }

            .action-buttons {
                flex-direction: column;
            }
        }

        /* 縦長レイアウト用 (スマホ向け) */
        @media (max-width: 768px) and (orientation: portrait) {
            .game-layout {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            /* .controls 内の子要素の並びを固定化 */
            .controls {
                width: 100%;
            }

            #gote-hand-container {
                order: 0;
            }

            #board-area {
                order: 1;
                margin-bottom: 15px;
                width: 100%;
            }

            #sente-hand-container {
                order: 2;
                margin-top: 10px;
            }

            /* スマホではボタン等を先に、その後に召喚プール */
            .status-panel {
                order: 3;
            }

            .summon-container {
                order: 4;
            }
        }

        /* タイトル画面とルール選択画面のスタイル */
        #title-screen,
        #rule-selection-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10000;
            padding: 20px;
        }

        #title-screen.hidden,
        #rule-selection-screen.hidden {
            display: none;
        }

        .title-content {
            text-align: center;
            animation: fade-in-up 1s ease-out;
        }

        .title-logo {
            font-family: 'Noto Serif JP', serif;
            font-size: 4rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            letter-spacing: 0.1em;
            writing-mode: horizontal-tb;
        }

        .title-subtitle {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 50px;
            letter-spacing: 0.2em;
        }

        .title-button {
            padding: 18px 60px;
            font-size: 1.3rem;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            animation: pulse-glow 2s infinite;
        }

        .title-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        .title-button:active {
            transform: translateY(-2px);
        }

        @keyframes fade-in-up {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            }

            50% {
                box-shadow: 0 8px 32px rgba(255, 255, 255, 0.4);
            }
        }

        /* プレイモード選択画面 */
        #play-mode-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10000;
            padding: 20px;
        }

        #play-mode-screen.hidden {
            display: none;
        }

        .play-mode-content {
            text-align: center;
            animation: fade-in-up 0.8s ease-out;
        }

        .play-mode-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 50px;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .play-mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 400px;
            margin: 0 auto 40px;
        }

        .play-mode-btn {
            padding: 20px 40px;
            font-size: 1.3rem;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .play-mode-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        .play-mode-btn .icon {
            font-size: 1.8rem;
        }

        .play-mode-btn.local {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.4) 0%, rgba(56, 142, 60, 0.4) 100%);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .play-mode-btn.online {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.4) 0%, rgba(25, 118, 210, 0.4) 100%);
            border-color: rgba(33, 150, 243, 0.5);
        }

        .play-mode-btn.spectate {
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.4) 0%, rgba(245, 124, 0, 0.4) 100%);
            border-color: rgba(255, 152, 0, 0.5);
        }

        /* マッチング待機画面 */
        #matching-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20000;
        }

        #matching-overlay.active {
            display: flex;
        }

        .matching-content {
            text-align: center;
            padding: 40px;
            animation: fade-in-up 0.5s ease-out;
        }

        .matching-title {
            font-size: 2rem;
            color: #fff;
            margin-bottom: 30px;
        }

        .matching-code-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .matching-code-label {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .matching-code {
            font-size: 2.5rem;
            font-weight: bold;
            color: #FFD700;
            letter-spacing: 0.3em;
            margin-bottom: 15px;
        }

        .matching-copy-btn {
            padding: 10px 25px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .matching-copy-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .matching-status {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .matching-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .matching-rule-badge {
            display: inline-block;
            padding: 8px 20px;
            background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
            border-radius: 20px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 30px;
        }

        .matching-cancel-btn {
            padding: 15px 40px;
            background: rgba(255, 100, 100, 0.3);
            border: 2px solid rgba(255, 100, 100, 0.5);
            border-radius: 10px;
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .matching-cancel-btn:hover {
            background: rgba(255, 100, 100, 0.5);
        }

        /* 部屋参加画面 */
        #join-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20000;
        }

        #join-overlay.active {
            display: flex;
        }

        .join-content {
            text-align: center;
            padding: 40px;
            animation: fade-in-up 0.5s ease-out;
        }

        .join-title {
            font-size: 2rem;
            color: #fff;
            margin-bottom: 30px;
        }

        .join-code-input {
            font-size: 2rem;
            padding: 15px 30px;
            border: 3px solid rgba(255, 215, 0, 0.5);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #FFD700;
            text-align: center;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            width: 250px;
            margin-bottom: 30px;
        }

        .join-code-input::placeholder {
            color: rgba(255, 215, 0, 0.4);
        }

        .join-btn {
            padding: 15px 50px;
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            border: none;
            border-radius: 10px;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .join-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
        }

        /* ルール選択画面 */
        .rule-selection-content {
            max-width: 900px;
            width: 100%;
            animation: fade-in-up 0.8s ease-out;
        }

        .rule-selection-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            text-align: center;
            margin-bottom: 50px;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.1em;
        }

        .rule-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .rule-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .rule-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rule-card:hover::before {
            opacity: 1;
        }

        .rule-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .rule-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .rule-card.disabled:hover {
            transform: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .rule-card-title {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 15px;
            text-align: center;
        }

        .rule-card-description {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
            line-height: 1.6;
            text-align: center;
            margin-bottom: 20px;
        }

        .rule-card-badge {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(255, 215, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.5);
            border-radius: 20px;
            color: #FFD700;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .rule-card-badge.coming-soon {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
        }

        .back-button {
            padding: 12px 40px;
            font-size: 1rem;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            display: block;
            margin: 0 auto;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        /* ゲーム画面を初期状態で非表示 */
        #game-screen {
            display: none;
        }

        #game-screen.active {
            display: block;
        }

        /* 配置フェーズのスタイル */
        #placement-phase-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            z-index: 9500;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            overflow-y: auto;
        }

        #placement-phase-overlay.active {
            display: flex;
        }

        .placement-header {
            text-align: center;
            margin-bottom: 20px;
            animation: fade-in-up 0.5s ease-out;
        }

        .placement-header h2 {
            font-family: 'Noto Serif JP', serif;
            font-size: 2rem;
            color: #fff;
            margin-bottom: 15px;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .placement-timer {
            display: inline-block;
            padding: 10px 30px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            color: #fff;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .placement-timer.warning {
            background: rgba(255, 100, 100, 0.4);
            border-color: rgba(255, 100, 100, 0.6);
            animation: timer-pulse 1s infinite;
        }

        .placement-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        .placement-hand-area {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            animation: fade-in-up 0.5s ease-out 0.2s both;
        }

        .placement-hand-title {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .placement-hand {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .placement-piece {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .placement-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .placement-piece.selected {
            box-shadow: 0 0 0 4px #FFD700, 0 6px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.1);
        }

        .placement-piece.placed {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .cell.placement-valid {
            background-color: rgba(50, 255, 50, 0.4) !important;
            cursor: pointer;
        }

        .cell.placement-valid:hover {
            background-color: rgba(50, 255, 50, 0.6) !important;
        }

        .placement-complete-btn {
            padding: 15px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            border: none;
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: fade-in-up 0.5s ease-out 0.4s both;
        }

        .placement-complete-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .placement-complete-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
        }

        .placement-info {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
            margin-top: 15px;
            text-align: center;
        }

        .placement-waiting {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }

        .placement-waiting.active {
            display: flex;
        }

        .placement-waiting h3 {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .placement-waiting .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            .title-logo {
                font-size: 2.5rem;
            }

            .title-subtitle {
                font-size: 1rem;
            }

            .title-button {
                padding: 15px 40px;
                font-size: 1.1rem;
            }

            .rule-selection-title {
                font-size: 1.8rem;
            }

            .rule-cards-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .rule-card-title {
                font-size: 1.3rem;
            }
        }
    </style>

    <!-- Firebase SDK -->
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script> -->
</head>

<body>
    <!-- タイトル画面 -->
    <div id="title-screen">
        <div class="title-content">
            <h1 class="title-logo">召喚将棋</h1>
            <p class="title-subtitle">Summon Shogi</p>
            <button class="title-button" id="start-button">はじめる</button>
        </div>
    </div>

    <!-- プレイモード選択画面 -->
    <div id="play-mode-screen" class="hidden">
        <div class="play-mode-content">
            <h2 class="play-mode-title">プレイモードを選択</h2>
            <div class="play-mode-buttons">
                <button class="play-mode-btn local" id="local-play-btn">
                    <span class="icon">🎮</span>
                    <span>ローカルプレイ</span>
                </button>
                <button class="play-mode-btn online" id="create-room-btn">
                    <span class="icon">🌐</span>
                    <span>部屋を作成</span>
                </button>
                <button class="play-mode-btn online" id="join-room-btn"
                    style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.4) 0%, rgba(124, 77, 255, 0.4) 100%); border-color: rgba(156, 39, 176, 0.5);">
                    <span class="icon">🚪</span>
                    <span>部屋に参加</span>
                </button>
                <button class="play-mode-btn spectate" id="spectate-mode-btn">
                    <span class="icon">👁️</span>
                    <span>観戦する</span>
                </button>
            </div>
            <button class="back-button" id="back-to-title-from-mode">戻る</button>
        </div>
    </div>

    <!-- ルール選択画面 -->
    <div id="rule-selection-screen" class="hidden">
        <div class="rule-selection-content">
            <h2 class="rule-selection-title">ルールを選択</h2>
            <div class="rule-cards-container">
                <!-- 召喚将棋クラシック -->
                <div class="rule-card" data-rule="classic">
                    <h3 class="rule-card-title">召喚将棋<br>クラシック</h3>
                    <p class="rule-card-description">
                        基本ルールで楽しむ召喚将棋。<br>
                        召喚プールから駒を召喚して戦おう！
                    </p>
                    <div class="rule-card-badge">プレイ可能</div>
                </div>

                <!-- 召喚将棋デッキルール -->
                <div class="rule-card" data-rule="deck">
                    <h3 class="rule-card-title">召喚将棋<br>デッキルール</h3>
                    <p class="rule-card-description">
                        ランダムで引いた3枚の駒を自由に配置！<br>
                        コストが軽い方が先攻になる。
                    </p>
                    <div class="rule-card-badge">プレイ可能</div>
                </div>

                <!-- 召喚将棋デラックス -->
                <div class="rule-card disabled" data-rule="deluxe">
                    <h3 class="rule-card-title">召喚将棋<br>デラックス</h3>
                    <p class="rule-card-description">
                        特殊能力と新駒が登場！<br>
                        究極の召喚将棋体験。
                    </p>
                    <div class="rule-card-badge coming-soon">近日公開</div>
                </div>
            </div>
            <button class="back-button" id="back-to-title">戻る</button>
        </div>
    </div>

    <!-- ゲーム画面 -->
    <div id="game-screen">
        <div id="version-banner"
            style="width:100%;background:#fffbcc;color:#8B4513;padding:6px 10px;text-align:center;font-weight:bold;border:1px solid #e6d87a;border-radius:6px;margin-bottom:8px;">
            ver3.2.1召喚ボタン・チャットオーバーレイ・決着時表示大など
        </div>
        <div class="header">
            <button class="back-to-title-btn" id="back-to-title-game">← タイトルへ</button>
            <h1>オンライン対戦対応 召喚将棋</h1>
            <button class="sync-btn" id="manual-sync-btn" style="display: none;" title="盤面を最新状態に同期">🔄 同期</button>
            <div class="user-info" id="user-info" style="display: none;">
                <div class="user-avatar" id="user-avatar">N</div>
                <span id="user-nickname">未ログイン</span>
            </div>
        </div>

        <div id="chat-overlay" aria-hidden="true">
            <div class="chat-panel" role="dialog" aria-modal="true" aria-labelledby="chat-title">
                <button id="chat-close-button" class="chat-close-button" aria-label="チャットを閉じる">×</button>
                <div class="chat-container" id="chat-container">
                    <h3 id="chat-title">チャット</h3>
                    <div class="preset-messages">
                        <div class="preset-message">よろしくお願いします</div>
                        <div class="preset-message">いい勝負でした</div>
                        <div class="preset-message">考え中です</div>
                        <div class="preset-message">ありがとうございました</div>
                        <div class="preset-message">また対戦しましょう</div>
                    </div>
                    <div class="chat-messages" id="chat-messages"></div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input" placeholder="メッセージを入力...">
                        <button id="chat-submit">送信</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="result-overlay" aria-hidden="true">
            <div class="result-panel" role="dialog" aria-modal="true" aria-labelledby="result-title">
                <div id="result-title">勝利</div>
                <p id="result-subtitle">おめでとうございます！</p>
                <div class="result-buttons">
                    <button id="result-rematch-button" class="result-button">もう一局</button>
                    <button id="result-replay-button" class="result-button">リプレイ</button>
                </div>
            </div>
        </div>

        <!-- マッチング待機画面 -->
        <div id="matching-overlay">
            <div class="matching-content">
                <h2 class="matching-title">対戦相手を待っています...</h2>

                <div class="matching-rule-badge" id="matching-rule-badge">デッキルール</div>

                <div class="matching-code-container">
                    <p class="matching-code-label">招待コード</p>
                    <p class="matching-code" id="matching-code">----</p>
                    <button class="matching-copy-btn" id="matching-copy-btn">コードをコピー</button>
                </div>

                <div class="matching-status">
                    <div class="matching-spinner"></div>
                    <span id="matching-status-text">対戦相手の参加を待っています...</span>
                </div>

                <button class="matching-cancel-btn" id="matching-cancel-btn">キャンセル</button>
            </div>
        </div>

        <!-- 部屋参加画面 -->
        <div id="join-overlay">
            <div class="join-content">
                <h2 class="join-title">部屋に参加</h2>

                <div class="matching-rule-badge" id="join-rule-badge">デッキルール</div>

                <p style="color: rgba(255,255,255,0.8); margin-bottom: 20px;">招待コードを入力してください</p>

                <input type="text" class="join-code-input" id="join-code-input" placeholder="ABCD12" maxlength="8">

                <br>

                <button class="join-btn" id="join-room-submit-btn">参加する</button>

                <br>

                <button class="matching-cancel-btn" id="join-cancel-btn">キャンセル</button>
            </div>
        </div>

        <!-- 配置フェーズオーバーレイ（body直下に移動） -->
        <div id="placement-phase-overlay">
            <!-- プレイヤー交代確認画面 -->
            <div id="player-switch-screen" style="display: none; text-align: center;">
                <h2 id="switch-player-name" style="color: #fff; font-size: 2.5rem; margin-bottom: 20px;">後手さん</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 1.3rem; margin-bottom: 30px;">画面を見ないでください！</p>
                <p id="switch-message" style="color: #FFD700; font-size: 1.1rem; margin-bottom: 40px;">
                    先手の番です。準備ができたらボタンを押してください。</p>
                <button class="placement-complete-btn" id="player-ready-btn"
                    style="background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);">準備OK</button>
            </div>

            <div class="placement-header">
                <h2 id="placement-title">駒を配置してください</h2>
                <div class="placement-timer">残り <span id="placement-timer-value">60</span>秒</div>
            </div>

            <div class="placement-hand-area">
                <div class="placement-hand-title">配置する駒を選択してください</div>
                <div class="placement-hand" id="placement-hand"></div>
            </div>

            <div class="placement-board-container" id="placement-board-container">
                <!-- ここに盤面が表示される -->
            </div>

            <button class="placement-complete-btn" id="placement-complete-btn">配置完了</button>
            <p class="placement-info">自陣3行以内に駒を配置してください（二歩は禁止）</p>

            <div class="placement-waiting" id="placement-waiting">
                <h3>相手の配置を待っています...</h3>
                <div class="spinner"></div>
            </div>

            <!-- ゲームスタート画面 -->
            <div class="game-start-ready" id="game-start-ready" style="display: none;">
                <h2 style="color: #fff; font-size: 2rem; margin-bottom: 20px;">配置完了！</h2>
                <p style="color: rgba(255,255,255,0.9); margin-bottom: 10px;">先手のコスト: <span id="sente-cost">0</span></p>
                <p style="color: rgba(255,255,255,0.9); margin-bottom: 20px;">後手のコスト: <span id="gote-cost">0</span></p>
                <p style="color: #FFD700; font-size: 1.2rem; margin-bottom: 30px;" id="first-player-msg">先手が先攻です！</p>
                <button class="placement-complete-btn" id="game-start-btn"
                    style="background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%); font-size: 1.5rem; padding: 20px 60px;">ゲームスタート！</button>
            </div>
        </div>

        <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

        <div class="online-controls">
            <h3>オンライン対戦</h3>

            <div class="tab-buttons">
                <button class="tab-button active" data-tab="create-tab">部屋を作成</button>
                <button class="tab-button" data-tab="join-tab">部屋に参加</button>
                <button class="tab-button" data-tab="watch-tab">観戦する</button>
            </div>

            <div class="tab-content active" id="create-tab">
                <div class="time-settings">
                    <label for="time-limit-select">制限時間（各プレイヤー）:</label>
                    <select id="time-limit-select">
                        <option value="0">制限なし</option>
                        <option value="60">1分</option>
                        <option value="180">3分</option>
                        <option value="300" selected>5分</option>
                        <option value="600">10分</option>
                        <option value="900">15分</option>
                        <option value="1800">30分</option>
                    </select>
                </div>
                <button id="create-game" class="create-game-button">部屋を作成する</button>
            </div>

            <div class="tab-content" id="join-tab">
                <div class="public-games-list" id="public-games-list">
                    <div class="no-games-message">現在公開された部屋はありません</div>
                </div>

                <div id="join-form">
                    <input type="text" id="game-code-input" placeholder="ゲームコードを入力して参加">
                    <button id="join-submit">参加</button>
                </div>
            </div>

            <div class="tab-content" id="watch-tab">
                <div class="public-games-list" id="spectator-games-list">
                    <div class="no-games-message">現在観戦できる部屋はありません</div>
                </div>

                <div id="watch-form">
                    <input type="text" id="watch-code-input" placeholder="ゲームコードを入力して観戦">
                    <button id="watch-submit">観戦を開始</button>
                </div>
            </div>

            <!-- 役割選択（先手/後手） -->
            <div id="role-select" class="role-select" style="display: none; margin-top:10px;">
                <div style="display:flex; gap:8px; justify-content:center;">
                    <button id="choose-sente"
                        style="background:#8B4513; color:#fff; padding:8px 12px; border:none; border-radius:4px; font-weight:bold;">先手になる</button>
                    <button id="choose-gote"
                        style="background:#2d6a4f; color:#fff; padding:8px 12px; border:none; border-radius:4px; font-weight:bold;">後手になる</button>
                </div>
                <div id="role-select-msg" style="margin-top:6px; text-align:center; color:#8B4513; font-size:0.9em;">
                </div>
            </div>

            <div id="game-info" style="display: none;">
                <p>ゲームコード: <span id="game-code"></span></p>
                <p>あなたは<span id="player-role"></span>です</p>
            </div>

            <div id="participants" style="display:none; margin-top:10px;">
                <h4 style="margin-bottom:6px;">参加者一覧</h4>
                <ul id="participant-list"
                    style="list-style:none; padding:0; margin:0; font-size:0.95em; display:flex; flex-direction:column; gap:4px;">
                </ul>
            </div>

            <div id="turn-indicator" class="turn-indicator" style="display: none;">
                待機中...
            </div>

            <div id="rematch-controls" style="display: none;">
                <button id="rematch-button">リマッチを申し込む</button>
                <div id="rematch-status"></div>
            </div>
        </div>

        <div class="game-container game-layout">
            <div class="controls">
                <!-- 後手の持ち駒 -->
                <div class="hand-container" id="gote-hand-container">
                    <div class="hand-title">後手の持ち駒 <span id="gote-count">0枚</span></div>
                    <div class="hand" id="gote-hand"></div>
                </div>

                <!-- 盤面 -->
                <div class="board-area" id="board-area">
                    <div class="board-toolbar">
                        <button id="flip-board-button" class="board-toggle-button">盤面反転</button>
                        <button id="chat-toggle-button" class="board-toggle-button">チャット</button>
                    </div>
                    <div class="coordinates" id="column-coordinates">
                        <div>9</div>
                        <div>8</div>
                        <div>7</div>
                        <div>6</div>
                        <div>5</div>
                        <div>4</div>
                        <div>3</div>
                        <div>2</div>
                        <div>1</div>
                    </div>
                    <div class="board-with-coords">
                        <div class="row-coordinates" id="row-coordinates">
                            <div>一</div>
                            <div>二</div>
                            <div>三</div>
                            <div>四</div>
                            <div>五</div>
                            <div>六</div>
                            <div>七</div>
                            <div>八</div>
                            <div>九</div>
                        </div>
                        <div class="board" id="board"></div>
                    </div>

                    <!-- 召喚ボタンとタイマー -->
                    <div
                        style="display: flex; gap: 15px; align-items: center; justify-content: center; margin-top: 15px;">
                        <button id="summon-button" disabled>召喚</button>

                        <!-- 制限時間表示 -->
                        <div class="timer-container" id="timer-container" style="display: none; margin: 0;">
                            <div class="timer" id="sente-timer">
                                <div class="timer-label">先手</div>
                                <div class="timer-value" id="sente-time">--:--</div>
                            </div>
                            <div class="timer" id="gote-timer">
                                <div class="timer-label">後手</div>
                                <div class="timer-value" id="gote-time">--:--</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 先手の持ち駒 -->
                <div class="hand-container" id="sente-hand-container">
                    <div class="hand-title">先手の持ち駒 <span id="sente-count">0枚</span></div>
                    <div class="hand" id="sente-hand"></div>
                </div>

                <!-- 召喚プール（任意の位置、ここではボタンの直前） -->
                <div class="summon-container">
                    <div class="summon-title">召喚プール <span id="summon-count">38枚</span></div>
                    <div class="summon-pool" id="summon-pool"></div>
                    <div class="summon-info" id="summon-info">
                        新しい駒を召喚するには「召喚する」ボタンをクリックしてください。
                    </div>
                    <div style="margin-top: 10px; font-size: 0.85em; color: #8B4513; text-align: center;">
                        ※召喚したら、その駒を必ず盤面に打つ必要があります
                    </div>
                </div>

                <!-- ボタン類（最下部） -->
                <div class="status-panel">
                    <div class="status" id="status">ゲームを開始します</div>
                    <div class="action-buttons">
                        <button id="pass-button" disabled>パス</button>
                        <button id="reset-button">リセット</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="rules-container">
            <div class="rules-toggle" id="rules-toggle">召喚将棋のルール</div>
            <div class="rules-content" id="rules-content">
                <h3>基本ルール:</h3>
                <ul>
                    <li>最初、盤面には王将と玉将のみが初期配置されている（王将は先手側、玉将は後手側）</li>
                    <li>残りのコマは「召喚プール」に置いてあり、ランダムに一コマずつ召喚できる</li>
                    <li>先行のプレイヤーから交互に以下の選択肢がある:
                        <ol>
                            <li>召喚する（脇によけたコマが無くなるまで一ターンに一回まで）→ 召喚したらその駒を必ず盤面に打つ</li>
                            <li>持ち駒を置く</li>
                            <li>盤上の駒を動かす</li>
                        </ol>
                    </li>
                    <li>王手などで王が取られる場合はその限りでない（王手への対応が必要）</li>
                    <li>初期配置の違いと召喚の選択肢があるだけで、他はクラシカルな将棋のルールと同じ</li>
                </ul>

                <h3>操作方法:</h3>
                <ul>
                    <li>駒を動かす: 駒をクリックして、移動可能なマスをクリックする</li>
                    <li>持ち駒を使う: 持ち駒をクリックして、置きたいマスをクリックする</li>
                    <li>召喚する: 「召喚する」ボタンをクリックする（ターンに1回まで）</li>
                    <li>何もしない: 「パス」ボタンをクリックする</li>
                    <li>ゲームをリセット: 「リセット」ボタンをクリックする</li>
                </ul>

                <h3>オンライン対戦:</h3>
                <ul>
                    <li>「部屋を作成」ボタンをクリックして新しいゲームを開始</li>
                    <li>公開された部屋は誰でも参加できます</li>
                    <li>ゲームコードを使って特定の相手と対戦することもできます</li>
                    <li>先手（部屋作成者）から開始</li>
                    <li>ゲーム終了後、「リマッチを申し込む」ボタンでもう一度対戦できます</li>
                    <li>チャット機能を使って対戦相手とコミュニケーションが取れます</li>
                </ul>

                <h3>主な駒の動き:</h3>
                <div class="piece-movement">
                    <div class="move-diagram">
                        <div class="move-grid">
                            <div class="move-cell can-move">↖</div>
                            <div class="move-cell can-move">↑</div>
                            <div class="move-cell can-move">↗</div>
                            <div class="move-cell can-move">←</div>
                            <div class="move-cell piece">王</div>
                            <div class="move-cell can-move">→</div>
                            <div class="move-cell can-move">↙</div>
                            <div class="move-cell can-move">↓</div>
                            <div class="move-cell can-move">↘</div>
                        </div>
                        <div>王将・玉将</div>
                    </div>

                    <div class="move-diagram">
                        <div class="move-grid">
                            <div class="move-cell can-move">↖</div>
                            <div class="move-cell can-move">↑</div>
                            <div class="move-cell can-move">↗</div>
                            <div class="move-cell can-move">←</div>
                            <div class="move-cell piece">金</div>
                            <div class="move-cell can-move">→</div>
                            <div class="move-cell"></div>
                            <div class="move-cell can-move">↓</div>
                            <div class="move-cell"></div>
                        </div>
                        <div>金将</div>
                    </div>

                    <div class="move-diagram">
                        <div class="move-grid">
                            <div class="move-cell can-move">↖</div>
                            <div class="move-cell can-move">↑</div>
                            <div class="move-cell can-move">↗</div>
                            <div class="move-cell"></div>
                            <div class="move-cell piece">銀</div>
                            <div class="move-cell"></div>
                            <div class="move-cell can-move">↙</div>
                            <div class="move-cell"></div>
                            <div class="move-cell can-move">↘</div>
                        </div>
                        <div>銀将</div>
                    </div>

                    <div class="move-diagram">
                        <div class="move-grid">
                            <div class="move-cell"></div>
                            <div class="move-cell can-move">↑</div>
                            <div class="move-cell"></div>
                            <div class="move-cell"></div>
                            <div class="move-cell piece">歩</div>
                            <div class="move-cell"></div>
                            <div class="move-cell"></div>
                            <div class="move-cell"></div>
                            <div class="move-cell"></div>
                        </div>
                        <div>歩兵</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- プロモーションダイアログ -->
        <div class="promotion-dialog" id="promotion-dialog">
            <div class="promotion-content">
                <div class="promotion-title">駒を成りますか？</div>
                <div class="promotion-options">
                    <div class="promotion-option" id="promote">と</div>
                    <div class="promotion-option" id="not-promote">歩</div>
                </div>
                <div>※左が成り駒、右が元の駒です</div>
            </div>
        </div>

        <!-- ログインモーダル -->
        <div class="modal" id="login-modal">
            <div class="modal-content">
                <div class="modal-title">ニックネームを設定</div>
                <p>オンライン対戦を楽しむためのニックネームを入力してください</p>
                <input type="text" id="nickname-input" class="modal-input" placeholder="ニックネーム (2〜10文字)" maxlength="10">
                <div class="modal-error" id="nickname-error">既に使用されているニックネームです。別の名前を入力してください。</div>
                <div class="modal-buttons">
                    <button id="login-button">ログイン</button>
                </div>
            </div>
        </div>

        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>


        <script>
            // Firebase設定
            const firebaseConfig = {
                apiKey: "AIzaSyAjVQZN--ODV3u-LpDtAUEw1PDoqeapCO8",
                authDomain: "summon-shogi.firebaseapp.com",
                projectId: "summon-shogi",
                storageBucket: "summon-shogi.firebasestorage.app",
                messagingSenderId: "964883817096",
                appId: "1:964883817096:web:da421585a4c97c5715353d",
                measurementId: "G-6SY3BS1VHX"
            };

            // Firebaseの初期化
            firebase.initializeApp(firebaseConfig);
            const database = firebase.database();

            // 匿名認証を必ず待つユーティリティ
            async function ensureAnonAuth() {
                const auth = firebase.auth();
                if (!auth.currentUser) {
                    await auth.signInAnonymously();
                    await new Promise((resolve, reject) => {
                        const off = auth.onAuthStateChanged(u => { if (u) { off(); resolve(); } }, reject);
                    });
                }
                return auth.currentUser;
            }

            // Firebaseの初期化コード内または直後に追加
            firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
                .then(() => {
                    console.log('認証の永続化を設定しました');
                })
                .catch((error) => {
                    console.error('認証の永続化の設定に失敗しました:', error);
                });

            // 認証状態の監視（デバッグ用）
            firebase.auth().onAuthStateChanged(function (user) {
                console.log("認証状態:", user ? "認証済み" : "未認証");
            });

            // ページ読み込み時に実行
            document.addEventListener('DOMContentLoaded', function () {
                // Firebase認証状態の監視
                firebase.auth().onAuthStateChanged(async function (user) {
                    if (user) {
                        console.log('ログイン済み:', user.uid);

                        // 前回の対局があれば復帰
                        const savedGameId = localStorage.getItem('currentGameId');
                        const savedRole = localStorage.getItem('playerRole');

                        if (savedGameId) {
                            try {
                                console.log('前回の対局に復帰します:', savedGameId);
                                await resumeSavedGame(savedGameId, savedRole);
                            } catch (e) {
                                console.warn('前回の対局への復帰に失敗しました:', e);
                            }
                        }
                    }
                });
            });


            // DOMContentLoaded内に追加
            firebase.auth().onAuthStateChanged((user) => {
                console.log('認証状態が変更されました:', user ? 'ログイン中' : '未ログイン');

                if (user) {
                    // ユーザーがログインしている場合
                    const userNickname = localStorage.getItem('userNickname');
                    console.log('ログイン中のユーザー:', user.uid, 'ニックネーム:', userNickname);

                    // ニックネームが取得できない場合は再入力を促す
                    if (!userNickname || userNickname.length < 2) {
                        showNicknameModal();
                    }
                } else {
                    // 未ログイン状態の場合、匿名ログインを自動実行
                    firebase.auth().signInAnonymously()
                        .catch((error) => {
                            console.error('匿名ログインに失敗しました:', error);
                        });
                }
            });


            // オンライン対戦用の変数
            let isOnlineGame = false;
            let gameId = null;
            let playerRole = null; // 'sente'または'gote'
            let isSpectator = false;
            let opponentConnected = false;
            let rematchOffered = false;
            let rematchAccepted = false;
            let chatListenerRef = null;
            let rematchListenerRef = null;
            let isBoardFlipped = false;
            let boardFlipPreference = null;

            (function initBoardFlipPreference() {
                const storedFlipPref = localStorage.getItem('boardFlipPreference');
                if (storedFlipPref === 'true' || storedFlipPref === 'false') {
                    boardFlipPreference = storedFlipPref === 'true';
                    isBoardFlipped = boardFlipPreference;
                }
            })();

            // ユーザー認証用の変数
            let userNickname = null;
            let isLoggedIn = false;
            let publicGamesData = []; // 変数名を変更
            let publicGamesRefresh = null;
            let currentPlayers = {};
            let currentSpectators = {};

            // ゲームの状態を管理
            const gameState = {
                currentTurn: 'sente', // 先手（sente）または後手（gote）
                selectedPiece: null,
                selectedCell: null,
                possibleMoves: [],
                board: Array.from({ length: 9 }, () => Array(9).fill(null)),
                senteHand: [],
                goteHand: [],
                summonPool: [],
                hasSummoned: false,
                mustPlaceLastSummoned: false,
                lastSummonedPiece: null,
                gameOver: false,
                winner: null, // 勝者を記録
                inCheck: { sente: false, gote: false },
                lastMove: null,
                pendingPromotion: null,
                lastMoveId: null,
                lastProcessedMoveId: null,
                // タイマー関連
                timeLimit: 0, // 制限時間（秒）、0は制限なし
                senteTimeRemaining: 0, // 先手の残り時間（秒）
                goteTimeRemaining: 0, // 後手の残り時間（秒）
                lastTurnChangeTime: null // 最後に手番が変わった時刻
            };

            // 駒の種類と初期数
            const pieceTypes = {
                '歩': { count: 18, promotion: 'と' },
                '香': { count: 4, promotion: '杏' },
                '桂': { count: 4, promotion: '圭' },
                '銀': { count: 4, promotion: '全' },
                '金': { count: 4, promotion: null },
                '角': { count: 2, promotion: '馬' },
                '飛': { count: 2, promotion: '竜' }
            };

            // 駒の動き
            const pieceMoves = {
                '王': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
                ],
                '玉': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
                ],
                '金': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }
                ],
                '銀': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 1 }, { x: 1, y: 1 }
                ],
                '桂': [
                    { x: -1, y: -2 }, { x: 1, y: -2 }
                ],
                '香': [
                    { x: 0, y: -1, range: 8 }
                ],
                '角': [
                    { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                    { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 }
                ],
                '飛': [
                    { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                    { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 }
                ],
                '歩': [
                    { x: 0, y: -1 }
                ],
                'と': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }
                ],
                '杏': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }
                ],
                '圭': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }
                ],
                '全': [
                    { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }
                ],
                '馬': [
                    { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                    { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 },
                    { x: 0, y: -1 }, { x: -1, y: 0 },
                    { x: 1, y: 0 }, { x: 0, y: 1 }
                ],
                '竜': [
                    { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                    { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 },
                    { x: -1, y: -1 }, { x: 1, y: -1 },
                    { x: -1, y: 1 }, { x: 1, y: 1 }
                ]
            };

            function normalizeOwner(owner) {
                if (owner === 'sente' || owner === 'gote') return owner;
                if (!owner && owner !== 0) return null;
                const normalized = String(owner).toLowerCase();
                if (normalized.includes('sente') || normalized.includes('先手') || normalized.includes('black') || normalized.includes('先攻')) {
                    return 'sente';
                }
                if (normalized.includes('gote') || normalized.includes('後手') || normalized.includes('white') || normalized.includes('後攻')) {
                    return 'gote';
                }
                return null;
            }

            function createPiece(type, owner, fallbackOwner = 'sente') {
                const normalizedOwner = normalizeOwner(owner) || normalizeOwner(fallbackOwner) || 'sente';
                return { type, owner: normalizedOwner };
            }

            function addPieceToHand(owner, pieceType) {
                const normalizedOwner = normalizeOwner(owner);
                if (!normalizedOwner) return;
                if (normalizedOwner === 'sente') {
                    gameState.senteHand.push(pieceType);
                } else if (normalizedOwner === 'gote') {
                    gameState.goteHand.push(pieceType);
                }
            }

            const chatSendQueue = [];
            let isRealtimeConnected = true;
            let isFlushingChatQueue = false;
            const displayedChatMessageIds = new Set();
            let connectionMonitorInitialized = false;

            function serializeBoard(board) {
                const result = {};
                if (!Array.isArray(board)) return result;
                for (let y = 0; y < board.length; y++) {
                    const row = board[y];
                    if (!Array.isArray(row)) continue;
                    for (let x = 0; x < row.length; x++) {
                        const piece = row[x];
                        if (piece) {
                            if (!result[y]) result[y] = {};
                            result[y][x] = createPiece(piece.type, piece.owner);
                        }
                    }
                }
                return result;
            }

            function deserializeBoard(data) {
                const board = Array.from({ length: 9 }, () => Array(9).fill(null));
                if (!data && data !== 0) return board;

                let source = data;
                if (typeof data === 'string') {
                    try {
                        source = JSON.parse(data);
                    } catch (e) {
                        console.warn('盤面データのパースに失敗しました', e);
                        return board;
                    }
                }

                if (Array.isArray(source)) {
                    for (let y = 0; y < source.length && y < 9; y++) {
                        const row = source[y];
                        if (!row) continue;
                        if (Array.isArray(row)) {
                            for (let x = 0; x < row.length && x < 9; x++) {
                                const piece = row[x];
                                if (piece) {
                                    const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                    const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                    board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                                }
                            }
                        } else if (typeof row === 'object') {
                            for (const [xKey, piece] of Object.entries(row)) {
                                const x = Number(xKey);
                                if (Number.isInteger(x) && x >= 0 && x < 9 && piece) {
                                    const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                    const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                    board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                                }
                            }
                        }
                    }
                    return board;
                }

                if (typeof source === 'object' && source) {
                    for (const [yKey, row] of Object.entries(source)) {
                        const y = Number(yKey);
                        if (!Number.isInteger(y) || y < 0 || y >= 9) continue;
                        if (Array.isArray(row)) {
                            for (let x = 0; x < row.length && x < 9; x++) {
                                const piece = row[x];
                                if (piece) {
                                    const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                    const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                    board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                                }
                            }
                        } else if (typeof row === 'object' && row) {
                            for (const [xKey, piece] of Object.entries(row)) {
                                const x = Number(xKey);
                                if (Number.isInteger(x) && x >= 0 && x < 9 && piece) {
                                    const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                    const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                    board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                                }
                            }
                        }
                    }
                }

                return board;
            }

            function normalizeList(data) {
                if (!data && data !== 0) return [];
                if (Array.isArray(data)) return data.filter(item => item !== null && item !== undefined);
                if (typeof data === 'string') {
                    try {
                        const parsed = JSON.parse(data);
                        return normalizeList(parsed);
                    } catch (e) {
                        console.warn('配列データのパースに失敗しました', e);
                        return [];
                    }
                }
                if (typeof data === 'object') {
                    return Object.keys(data)
                        .sort((a, b) => Number(a) - Number(b))
                        .map(key => data[key])
                        .filter(item => item !== null && item !== undefined);
                }
                return [];
            }

            function updateCoordinateLabels() {
                if (columnCoordinates) {
                    const cols = isBoardFlipped ? ['1', '2', '3', '4', '5', '6', '7', '8', '9'] : ['9', '8', '7', '6', '5', '4', '3', '2', '1'];
                    columnCoordinates.innerHTML = '';
                    cols.forEach(label => {
                        const div = document.createElement('div');
                        div.textContent = label;
                        columnCoordinates.appendChild(div);
                    });
                }
                if (rowCoordinates) {
                    const rows = isBoardFlipped ? ['九', '八', '七', '六', '五', '四', '三', '二', '一'] : ['一', '二', '三', '四', '五', '六', '七', '八', '九'];
                    rowCoordinates.innerHTML = '';
                    rows.forEach(label => {
                        const div = document.createElement('div');
                        div.textContent = label;
                        rowCoordinates.appendChild(div);
                    });
                }
            }

            function getAutoBoardFlip() {
                return playerRole === 'gote';
            }

            function updateBoardToggleLabel() {
                if (!flipBoardButton) return;
                flipBoardButton.textContent = isBoardFlipped ? '先手視点に戻す' : '後手視点に切替';
            }

            function updateBoardFlipState(forceRender = false) {
                const autoState = getAutoBoardFlip();
                const targetState = boardFlipPreference !== null ? boardFlipPreference : autoState;
                if (isBoardFlipped !== targetState) {
                    isBoardFlipped = targetState;
                }
                document.body.classList.toggle('board-flipped', isBoardFlipped);
                updateBoardToggleLabel();
                updateCoordinateLabels();
                if (forceRender && typeof renderBoard === 'function') {
                    renderBoard();
                }
            }

            const CHAT_OVERLAY_STORAGE_KEY = 'chatOverlayOpen';

            function isChatOverlayActive() {
                return chatOverlay && chatOverlay.classList.contains('active');
            }

            function openChatOverlay(saveState = true) {
                if (!chatOverlay) return;
                chatOverlay.classList.add('active');
                chatOverlay.setAttribute('aria-hidden', 'false');
                document.body.classList.add('chat-overlay-active');
                if (saveState) localStorage.setItem(CHAT_OVERLAY_STORAGE_KEY, 'true');
                if (chatInput && !chatInput.disabled) {
                    setTimeout(() => chatInput.focus({ preventScroll: true }), 0);
                }
            }

            function closeChatOverlay(saveState = true) {
                if (!chatOverlay) return;
                chatOverlay.classList.remove('active');
                chatOverlay.setAttribute('aria-hidden', 'true');
                document.body.classList.remove('chat-overlay-active');
                if (saveState) localStorage.setItem(CHAT_OVERLAY_STORAGE_KEY, 'false');
            }

            function restoreChatOverlayState() {
                const stored = localStorage.getItem(CHAT_OVERLAY_STORAGE_KEY);
                if (stored === 'true') {
                    openChatOverlay(false);
                } else {
                    closeChatOverlay(false);
                }
            }

            function hideResultOverlay(updateState = true) {
                if (!resultOverlay) return;
                resultOverlay.classList.remove('active');
                resultOverlay.setAttribute('aria-hidden', 'true');
                document.body.classList.remove('result-overlay-active');
                if (updateState) {
                    // No persistence for now; placeholder
                }
            }

            function showResultOverlay(outcome) {
                if (!resultOverlay) return;
                let title = '対局終了';
                let subtitle = '対局が終了しました。';

                if (outcome === 'win') {
                    title = '勝 利';
                    subtitle = 'おめでとうございます！';
                } else if (outcome === 'lose') {
                    title = '敗 北';
                } else if (outcome === 'sente-win') {
                    title = '先手 勝利';
                } else if (outcome === 'gote-win') {
                    title = '後手 勝利';
                }

                if (resultTitle) resultTitle.textContent = title;
                if (resultSubtitle) resultSubtitle.textContent = subtitle;

                resultOverlay.classList.add('active');
                resultOverlay.setAttribute('aria-hidden', 'false');
                document.body.classList.add('result-overlay-active');
            }

            function updateChatInputState() {
                if (!chatInput || !chatSubmit) return;
                const disabled = !isOnlineGame || !gameId;
                chatInput.disabled = disabled;
                chatSubmit.disabled = disabled;
                if (disabled) {
                    chatInput.placeholder = '対局中のみチャットできます';
                } else if (!isRealtimeConnected) {
                    chatInput.placeholder = '接続を待っています…';
                } else {
                    chatInput.placeholder = 'メッセージを入力...';
                }
            }

            async function postChatMessage(payload) {
                await ensureAnonAuth();
                const chatRef = database.ref(`games/${gameId}/chat`).push();
                await chatRef.set(payload);
            }

            async function flushChatQueue() {
                if (!isRealtimeConnected || isFlushingChatQueue || chatSendQueue.length === 0) return;
                isFlushingChatQueue = true;
                try {
                    while (chatSendQueue.length > 0) {
                        const payload = chatSendQueue[0];
                        try {
                            await postChatMessage(payload);
                            chatSendQueue.shift();
                        } catch (err) {
                            console.error('チャットキュー送信に失敗', err);
                            showToast('メッセージの再送信に失敗しました', 'error');
                            break;
                        }
                    }
                } finally {
                    isFlushingChatQueue = false;
                    updateChatInputState();
                }
            }

            function initRealtimeConnectionMonitor() {
                if (connectionMonitorInitialized) return;
                connectionMonitorInitialized = true;
                try {
                    const connectedRef = firebase.database().ref('.info/connected');
                    connectedRef.on('value', snapshot => {
                        const connected = snapshot.val() === true;
                        if (connected) {
                            if (!isRealtimeConnected) {
                                showToast('接続しました', 'success');

                                // 接続が回復したら、プレイヤーのonlineフラグを更新
                                const uid = firebase.auth().currentUser?.uid;
                                if (uid && isOnlineGame && gameId) {
                                    if (!isSpectator) {
                                        database.ref(`games/${gameId}/players/${uid}/online`).set(true);
                                    } else {
                                        database.ref(`games/${gameId}/spectators/${uid}/online`).set(true);
                                    }
                                }
                            }
                            isRealtimeConnected = true;
                            updateChatInputState();
                            flushChatQueue();
                        } else {
                            if (isRealtimeConnected) {
                                showToast('接続が切れました。再接続を待っています', 'warn');
                            }
                            isRealtimeConnected = false;
                            updateChatInputState();
                        }
                    });
                } catch (err) {
                    console.error('接続監視の初期化に失敗', err);
                }

                window.addEventListener('online', () => {
                    showToast('ネットワークに接続しました', 'info');
                });

                window.addEventListener('offline', () => {
                    showToast('ネットワークから切断されました', 'warn');
                    isRealtimeConnected = false;
                    updateChatInputState();
                });
            }

            function showToast(message, type = 'info', duration = 3500) {
                const toastContainer = document.getElementById('toast-container');
                if (!toastContainer) {
                    console[type === 'error' ? 'error' : 'log'](message);
                    return;
                }
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                toastContainer.appendChild(toast);
                requestAnimationFrame(() => {
                    toast.classList.add('visible');
                });
                setTimeout(() => {
                    toast.classList.remove('visible');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, duration);
            }

            function updateParticipantListDisplay() {
                if (!participantsContainer || !participantListElement) return;
                if (!isOnlineGame || !gameId) {
                    participantsContainer.style.display = 'none';
                    participantListElement.innerHTML = '';
                    return;
                }

                participantsContainer.style.display = 'block';
                participantListElement.innerHTML = '';

                const uid = firebase.auth().currentUser?.uid;
                const playerEntries = [];
                for (const [pid, info] of Object.entries(currentPlayers || {})) {
                    if (!info) continue;
                    const role = info.role;
                    let label = 'プレイヤー';
                    let order = 2;
                    if (role === 'sente') { label = '先手'; order = 0; }
                    else if (role === 'gote') { label = '後手'; order = 1; }
                    playerEntries.push({ order, label, pid, info });
                }

                playerEntries.sort((a, b) => a.order - b.order);
                playerEntries.forEach(entry => {
                    const li = document.createElement('li');
                    let text = `${entry.label}: ${entry.info.nickname || '匿名'}`;
                    if (entry.pid === uid) text += ' (あなた)';
                    if (entry.info.online === false) text += ' [離席]';
                    li.textContent = text;
                    participantListElement.appendChild(li);
                });

                const spectatorEntries = [];
                for (const [sid, info] of Object.entries(currentSpectators || {})) {
                    if (!info) continue;
                    spectatorEntries.push({ sid, info });
                }

                spectatorEntries.sort((a, b) => (a.info.joinedAt || 0) - (b.info.joinedAt || 0));
                if (spectatorEntries.length > 0) {
                    const header = document.createElement('li');
                    header.textContent = '--- 観戦者 ---';
                    header.style.fontWeight = 'bold';
                    participantListElement.appendChild(header);

                    spectatorEntries.forEach(entry => {
                        const li = document.createElement('li');
                        let text = `${entry.info.nickname || '匿名'}`;
                        if (entry.sid === uid) text += ' (あなた)';
                        if (entry.info.online === false) text += ' [離席]';
                        li.textContent = text;
                        participantListElement.appendChild(li);
                    });
                }
            }

            function showNicknameModal() {
                // 統一: ログインモーダル表示は showLoginModal に集約
                if (typeof showLoginModal === 'function') {
                    showLoginModal();
                    return;
                }
                loginModal.style.display = 'flex';
                nicknameInput.focus();
            }

            function generateRandomId() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            function generateMoveId() {
                return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
            }

            // 効果音を無効化（ブラウザの互換性問題を回避）
            const sounds = {
                move: null,
                summon: null,
                capture: null,
                check: null,
                gameover: null
            };

            // DOM要素
            const boardElement = document.getElementById('board');
            const senteHandElement = document.getElementById('sente-hand');
            const goteHandElement = document.getElementById('gote-hand');
            const summonPoolElement = document.getElementById('summon-pool');
            const summonButton = document.getElementById('summon-button');
            const statusElement = document.getElementById('status');
            const resetButton = document.getElementById('reset-button');
            const passButton = document.getElementById('pass-button');
            const rulesToggle = document.getElementById('rules-toggle');
            const rulesContent = document.getElementById('rules-content');
            const summonCountElement = document.getElementById('summon-count');
            const senteCountElement = document.getElementById('sente-count');
            const goteCountElement = document.getElementById('gote-count');
            const summonInfoElement = document.getElementById('summon-info');

            // プロモーションダイアログ
            const promotionDialog = document.getElementById('promotion-dialog');
            const promoteOption = document.getElementById('promote');
            const notPromoteOption = document.getElementById('not-promote');

            // オンライン対戦用のUI要素
            const createGameButton = document.getElementById('create-game');
            const joinGameButton = document.getElementById('join-game');
            const gameInfoElement = document.getElementById('game-info');
            const gameCodeElement = document.getElementById('game-code');
            const playerRoleElement = document.getElementById('player-role');
            const joinFormElement = document.getElementById('join-form');
            const gameCodeInput = document.getElementById('game-code-input');
            const joinSubmitButton = document.getElementById('join-submit');
            const turnIndicator = document.getElementById('turn-indicator');
            const roleSelect = document.getElementById('role-select');
            const chooseSenteBtn = document.getElementById('choose-sente');
            const chooseGoteBtn = document.getElementById('choose-gote');
            const roleSelectMsg = document.getElementById('role-select-msg');
            const publicGamesListElement = document.getElementById('public-games-list'); // 変数名を変更
            const spectatorGamesListElement = document.getElementById('spectator-games-list');
            const watchCodeInput = document.getElementById('watch-code-input');
            const watchSubmitButton = document.getElementById('watch-submit');
            const participantsContainer = document.getElementById('participants');
            const participantListElement = document.getElementById('participant-list');
            const flipBoardButton = document.getElementById('flip-board-button');
            const columnCoordinates = document.getElementById('column-coordinates');
            const rowCoordinates = document.getElementById('row-coordinates');

            // プレイヤーの役割を共通処理で反映
            function applyPlayerRole(role) {
                const normalized = role === 'sente' ? 'sente' : (role === 'gote' ? 'gote' : (role === 'spectator' ? 'spectator' : null));
                playerRole = normalized;

                if (playerRoleElement) {
                    if (normalized) {
                        if (normalized === 'sente') {
                            playerRoleElement.textContent = '先手（あなた）';
                        } else if (normalized === 'gote') {
                            playerRoleElement.textContent = '後手（あなた）';
                        } else {
                            playerRoleElement.textContent = '観戦者（あなた）';
                        }
                    } else {
                        playerRoleElement.textContent = '未確定';
                    }
                }

                if (normalized && normalized !== 'spectator') {
                    localStorage.setItem('playerRole', normalized);
                } else if (normalized === 'spectator') {
                    localStorage.setItem('playerRole', 'spectator');
                } else {
                    localStorage.removeItem('playerRole');
                }

                if (typeof updateTurnIndicator === 'function') {
                    updateTurnIndicator();
                }

                if (normalized && isOnlineGame && gameId) {
                    ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
                    if (normalized === 'sente' || normalized === 'gote') {
                        refreshRematchListener().catch(err => console.error('リマッチリスナーの開始に失敗しました', err));
                        if (rematchButton) rematchButton.disabled = false;
                    } else {
                        stopRematchListener();
                        if (rematchControls) rematchControls.style.display = 'none';
                        if (rematchButton) rematchButton.disabled = true;
                    }
                } else if (!normalized) {
                    stopChatListener();
                    stopRematchListener();
                }

                updateBoardFlipState(true);
                updateChatInputState();
            }

            async function resumeSavedGame(savedGameId, savedRole) {
                if (isOnlineGame && gameId === savedGameId) return;
                await ensureAnonAuth();
                const snapshot = await firebase.database().ref(`games/${savedGameId}`).once('value');
                if (!snapshot.exists()) {
                    localStorage.removeItem('currentGameId');
                    localStorage.removeItem('playerRole');
                    throw new Error('保存された対局が見つかりません');
                }

                isOnlineGame = true;
                isSpectator = savedRole === 'spectator';
                gameId = savedGameId;
                localStorage.setItem('currentGameId', savedGameId);

                if (savedRole) {
                    applyPlayerRole(savedRole);
                } else {
                    const uid = firebase.auth().currentUser?.uid;
                    const data = snapshot.val();
                    const inferredRole = uid && data?.players && data.players[uid]?.role ? data.players[uid].role : null;
                    if (inferredRole) {
                        applyPlayerRole(inferredRole);
                    } else {
                        applyPlayerRole(null);
                    }
                }

                if (gameInfoElement) gameInfoElement.style.display = 'block';
                if (gameCodeElement) gameCodeElement.textContent = snapshot.val()?.code || savedGameId;
                if (turnIndicator) turnIndicator.style.display = 'block';

                if (isSpectator) {
                    await registerSpectator(savedGameId);
                }

                await attachGameListeners(savedGameId);
                if (isSpectator) {
                    await ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
                }
                updateChatInputState();
            }

            // タブ切り替え用の要素
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            // リマッチ用のUI要素
            const rematchControls = document.getElementById('rematch-controls');
            const rematchButton = document.getElementById('rematch-button');
            const rematchStatus = document.getElementById('rematch-status');

            // タイマー関連のUI要素
            const timeLimitSelect = document.getElementById('time-limit-select');
            const timerContainer = document.getElementById('timer-container');
            const senteTimer = document.getElementById('sente-timer');
            const goteTimer = document.getElementById('gote-timer');
            const senteTimeElement = document.getElementById('sente-time');
            const goteTimeElement = document.getElementById('gote-time');
            let timerInterval = null;


            // チャット機能用のUI要素
            const chatContainer = document.getElementById('chat-container');
            const chatOverlay = document.getElementById('chat-overlay');
            const chatCloseButton = document.getElementById('chat-close-button');
            const chatToggleButton = document.getElementById('chat-toggle-button');
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatSubmit = document.getElementById('chat-submit');
            const presetMessages = document.querySelectorAll('.preset-message');
            const resultOverlay = document.getElementById('result-overlay');
            const resultTitle = document.getElementById('result-title');
            const resultSubtitle = document.getElementById('result-subtitle');
            const resultRematchButton = document.getElementById('result-rematch-button');
            const resultReplayButton = document.getElementById('result-replay-button');

            // ログイン機能用のUI要素
            const loginModal = document.getElementById('login-modal');
            const nicknameInput = document.getElementById('nickname-input');
            const loginButton = document.getElementById('login-button');
            const nicknameError = document.getElementById('nickname-error');
            const userInfo = document.getElementById('user-info');
            const userAvatar = document.getElementById('user-avatar');
            const userNicknameElement = document.getElementById('user-nickname');

            // 競合する重複初期化を除去（正規のリスナーは下部で設定）

            // イベントハンドラを関数として定義
            function handleRoomCreation() {
                const user = firebase.auth().currentUser;
                const userNickname = localStorage.getItem('userNickname');

                if (!user) {
                    console.error('ユーザーがログインしていません');
                    firebase.auth().signInAnonymously()
                        .then(() => {
                            if (userNickname && userNickname.length >= 2) {
                                setTimeout(createRoom, 500);
                            } else {
                                alert('ログインが必要です。ニックネームを入力してください。');
                                showNicknameModal();
                            }
                        })
                        .catch(error => {
                            console.error('再ログインに失敗:', error);
                            alert('ログインに失敗しました。再読み込みしてお試しください。');
                        });
                    return;
                }

                if (!userNickname || userNickname.length < 2) {
                    alert('ニックネームは2文字以上入力してください');
                    showNicknameModal();
                    return;
                }



                createRoom();
            }


            // ページ読み込み時に実行
            document.addEventListener('DOMContentLoaded', () => {
                // localStorageからユーザー情報を取得
                const savedNickname = localStorage.getItem('userNickname');
                if (savedNickname) {
                    // ニックネームがあれば予約→登録を試みる（失敗したら再入力）
                    setNickname(savedNickname)
                        .catch(() => {
                            showLoginModal();
                        });
                } else {
                    // ニックネームがない場合はログインモーダルを表示
                    showLoginModal();
                }

                // 公開ゲームリストの取得を開始
                startPublicGamesRefresh();

                restoreChatOverlayState();
                initRealtimeConnectionMonitor();
                updateChatInputState();
            });

            // タブ切り替え
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // アクティブなタブを切り替え
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    // 対応するコンテンツを表示
                    const tabId = button.getAttribute('data-tab');
                    tabContents.forEach(content => content.classList.remove('active'));
                    document.getElementById(tabId).classList.add('active');
                });
            });

            // 役割選択ボタンのイベント
            if (chooseSenteBtn) chooseSenteBtn.addEventListener('click', () => chooseRole('sente'));
            if (chooseGoteBtn) chooseGoteBtn.addEventListener('click', () => chooseRole('gote'));

            // オンライン対戦イベントリスナー
            if (createGameButton) createGameButton.addEventListener('click', () => {
                if (!isLoggedIn) {
                    showLoginModal();
                    return;
                }
                createGameRoom();
            });

            if (joinSubmitButton) joinSubmitButton.addEventListener('click', async () => {
                if (!isLoggedIn) {
                    showLoginModal();
                    return;
                }

                const code = gameCodeInput.value.trim().toUpperCase();
                if (code.length !== 6) {
                    alert('有効なゲームコード（6文字）を入力してください');
                    return;
                }
                const gid = await findGameIdByCode(code);
                if (!gid) {
                    alert('そのコードの部屋は見つかりません');
                    return;
                }
                await joinGameRoomById(gid);
            });

            if (watchSubmitButton) watchSubmitButton.addEventListener('click', async () => {
                if (!isLoggedIn) {
                    showLoginModal();
                    return;
                }

                const code = watchCodeInput.value.trim().toUpperCase();
                if (code.length !== 6) {
                    alert('有効なゲームコード（6文字）を入力してください');
                    return;
                }
                const gid = await findGameIdByCode(code);
                if (!gid) {
                    alert('そのコードの部屋は見つかりません');
                    return;
                }
                await watchGameRoomById(gid);
            });

            if (flipBoardButton) {
                flipBoardButton.addEventListener('click', () => {
                    const autoState = getAutoBoardFlip();
                    const newState = !isBoardFlipped;
                    if (newState === autoState) {
                        boardFlipPreference = null;
                        localStorage.removeItem('boardFlipPreference');
                    } else {
                        boardFlipPreference = newState;
                        localStorage.setItem('boardFlipPreference', String(boardFlipPreference));
                    }
                    isBoardFlipped = newState;
                    updateBoardFlipState(true);
                });
            }

            if (chatToggleButton) {
                chatToggleButton.addEventListener('click', () => {
                    if (isChatOverlayActive()) {
                        closeChatOverlay();
                    } else {
                        openChatOverlay();
                    }
                });
            }

            if (chatCloseButton) {
                chatCloseButton.addEventListener('click', () => closeChatOverlay());
            }

            if (chatOverlay) {
                chatOverlay.addEventListener('click', (event) => {
                    if (event.target === chatOverlay) {
                        closeChatOverlay();
                    }
                });
            }

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && isChatOverlayActive()) {
                    event.preventDefault();
                    closeChatOverlay();
                }
                if (event.key === 'Escape' && resultOverlay && resultOverlay.classList.contains('active')) {
                    event.preventDefault();
                    hideResultOverlay();
                }
            });

            if (resultOverlay) {
                resultOverlay.addEventListener('click', (event) => {
                    if (event.target === resultOverlay) {
                        hideResultOverlay();
                    }
                });
            }

            if (resultRematchButton) {
                resultRematchButton.addEventListener('click', () => {
                    hideResultOverlay();
                    if (isOnlineGame && !isSpectator) {
                        offerRematch();
                    } else {
                        initGame();
                    }
                });
            }

            if (resultReplayButton) {
                resultReplayButton.addEventListener('click', () => {
                    hideResultOverlay();
                    console.log('Replay feature is under construction.');
                    alert('リプレイ機能は準備中です。');
                });
            }

            // publicGames の code → gameId を解決
            async function findGameIdByCode(code) {
                await ensureAnonAuth();
                const snap = await firebase.database()
                    .ref('publicGames')
                    .orderByChild('code')
                    .equalTo(code)
                    .once('value');
                if (!snap.exists()) return null;
                return Object.keys(snap.val())[0];
            }

            // ニックネーム予約用ヘルパー（推奨: /nicknames インデックス）
            function toKey(name) { return name.trim().toLowerCase(); }
            async function claimNickname(nickname) {
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser.uid;
                const key = toKey(nickname);
                const ref = firebase.database().ref(`nicknames/${key}`);
                const result = await ref.transaction(cur => cur || uid);
                // 既に自分のUIDが入っている場合もOKとする
                return result.snapshot && result.snapshot.val() === uid;
            }
            async function setNickname(nickname) {
                const ok = await claimNickname(nickname);
                if (!ok) throw new Error('そのニックネームは使用されています');
                await registerUser(nickname);
                hideLoginModal();
            }

            // ログインイベントリスナー（予約→登録）
            if (loginButton) {
                loginButton.addEventListener('click', async () => {
                    const nickname = nicknameInput.value.trim();

                    // 入力チェック
                    if (nickname.length < 2 || nickname.length > 10) {
                        nicknameError.textContent = 'ニックネームは2〜10文字で入力してください';
                        nicknameError.style.display = 'block';
                        return;
                    }

                    try {
                        await setNickname(nickname);
                    } catch (e) {
                        nicknameError.textContent = e.message || 'ニックネームの予約に失敗しました';
                        nicknameError.style.display = 'block';
                    }
                });
            }

            // ニックネーム入力でEnterキーの処理
            if (nicknameInput) {
                nicknameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && loginButton) {
                        loginButton.click();
                    }
                });
            }

            // ニックネームの重複をチェック（認証完了を待機）
            async function checkNicknameAvailability(nickname) {
                await ensureAnonAuth();
                const snap = await database.ref('users')
                    .orderByChild('nickname')
                    .equalTo(nickname)
                    .once('value');
                return !snap.exists();
            }

            // ユーザー登録（uidに統一）
            async function registerUser(nickname) {
                const user = await ensureAnonAuth();
                const uid = user.uid;

                userNickname = nickname;
                isLoggedIn = true;

                await database.ref(`users/${uid}`).set({
                    nickname,
                    lastLoginAt: firebase.database.ServerValue.TIMESTAMP
                });

                // localStorageに保存
                localStorage.setItem('userNickname', nickname);
                localStorage.setItem('userId', uid);

                // UI更新
                userNicknameElement.textContent = nickname;
                userAvatar.textContent = nickname.charAt(0).toUpperCase();
                userInfo.style.display = 'flex';

                // 接続時に消えるよう設定
                database.ref(`users/${uid}`).onDisconnect().remove();
            }

            // ユーザーIDを生成
            function generateUserId() {
                return Math.random().toString(36).substring(2, 15) +
                    Math.random().toString(36).substring(2, 15);
            }

            // ログインモーダルを表示
            function showLoginModal() {
                loginModal.style.display = 'flex';
                nicknameInput.focus();
            }

            // ログインモーダルを非表示
            function hideLoginModal() {
                loginModal.style.display = 'none';
                nicknameError.style.display = 'none';
            }

            // 公開ゲームリストの更新を開始
            async function startPublicGamesRefresh() {
                await ensureAnonAuth();
                // 既存のタイマーがあればクリア
                if (publicGamesRefresh) {
                    clearInterval(publicGamesRefresh);
                }

                // 公開ゲームリストを監視
                database.ref('publicGames').on('value', (snapshot) => {
                    updatePublicGamesList(snapshot);
                });

                // 5秒ごとに更新
                publicGamesRefresh = setInterval(() => {
                    cleanupOldPublicGames();
                }, 5000);
            }

            // 公開ゲームリストを更新
            function updatePublicGamesList(snapshot) {
                publicGamesListElement.innerHTML = '';
                if (spectatorGamesListElement) spectatorGamesListElement.innerHTML = '';
                publicGamesData = [];

                if (!snapshot || !snapshot.exists()) {
                    publicGamesListElement.innerHTML = '<div class="no-games-message">現在公開された部屋はありません</div>';
                    if (spectatorGamesListElement) spectatorGamesListElement.innerHTML = '<div class="no-games-message">現在観戦できる部屋はありません</div>';
                    return;
                }

                const games = snapshot.val();
                const gameItems = Object.entries(games).map(([gameId, game]) => ({
                    id: gameId,
                    host: game.host || '匿名',
                    createdAt: game.createdAt || 0,
                    status: game.status || 'waiting'
                })).sort((a, b) => b.createdAt - a.createdAt);

                const joinable = gameItems.filter(game => game.status !== 'playing');
                const watchable = gameItems;

                const renderList = (container, items, buttonLabel, handlerBuilder) => {
                    if (!container) return;
                    if (items.length === 0) {
                        container.innerHTML = buttonLabel === '参加する'
                            ? '<div class="no-games-message">現在公開された部屋はありません</div>'
                            : '<div class="no-games-message">現在観戦できる部屋はありません</div>';
                        return;
                    }

                    items.forEach(game => {
                        const gameItem = document.createElement('div');
                        gameItem.className = 'public-game-item';

                        const gameInfo = document.createElement('div');
                        gameInfo.className = 'public-game-info';

                        const hostElement = document.createElement('div');
                        hostElement.className = 'public-game-host';
                        hostElement.textContent = `${game.host} の部屋`;

                        const statusElement = document.createElement('div');
                        statusElement.className = 'public-game-status';
                        statusElement.textContent = game.status === 'playing' ? '対局中' : '募集中';

                        gameInfo.appendChild(hostElement);
                        gameInfo.appendChild(statusElement);

                        const timeElement = document.createElement('div');
                        timeElement.className = 'public-game-time';
                        timeElement.textContent = formatTime(game.createdAt);
                        gameInfo.appendChild(timeElement);

                        const actionButton = document.createElement('button');
                        actionButton.className = 'join-public-button';
                        actionButton.textContent = buttonLabel;
                        actionButton.addEventListener('click', handlerBuilder(game));

                        if (buttonLabel === '参加する' && game.status === 'playing') {
                            actionButton.disabled = true;
                            actionButton.textContent = '対局中';
                        }

                        gameItem.appendChild(gameInfo);
                        gameItem.appendChild(actionButton);

                        container.appendChild(gameItem);
                    });
                };

                renderList(publicGamesListElement, joinable, '参加する', game => () => {
                    if (!isLoggedIn) { showLoginModal(); return; }
                    joinGameRoomById(game.id);
                });

                renderList(spectatorGamesListElement, watchable, '観戦する', game => () => {
                    if (!isLoggedIn) { showLoginModal(); return; }
                    watchGameRoomById(game.id);
                });

                publicGamesData = gameItems;
            }

            // 古い公開ゲームをクリーンアップ
            async function cleanupOldPublicGames() {
                const now = Date.now();
                await ensureAnonAuth();
                database.ref('publicGames').once('value', (snapshot) => {
                    if (!snapshot.exists()) return;

                    const games = snapshot.val();
                    for (const gameId in games) {
                        const game = games[gameId];

                        // 30分以上経過したゲームを削除
                        if (now - game.createdAt > 30 * 60 * 1000) {
                            database.ref(`publicGames/${gameId}`).remove();
                            database.ref(`games/${gameId}`).remove();
                        }
                    }
                });
            }

            // 時間を「〜分前」形式に変換
            function formatTime(timestamp) {
                const now = Date.now();
                const diff = now - timestamp;

                if (diff < 60 * 1000) {
                    return 'たった今';
                } else if (diff < 60 * 60 * 1000) {
                    return `${Math.floor(diff / (60 * 1000))}分前`;
                } else if (diff < 24 * 60 * 60 * 1000) {
                    return `${Math.floor(diff / (60 * 60 * 1000))}時間前`;
                } else {
                    return `${Math.floor(diff / (24 * 60 * 60 * 1000))}日前`;
                }
            }

            // リマッチボタンイベントリスナー
            if (rematchButton) rematchButton.addEventListener('click', offerRematch);

            // チャット機能イベントリスナー
            if (chatSubmit) chatSubmit.addEventListener('click', sendChatMessage);
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendChatMessage();
                    }
                });
            }

            // プリセットメッセージのイベントリスナー
            presetMessages.forEach(msg => {
                msg.addEventListener('click', () => {
                    chatInput.value = msg.textContent;
                    sendChatMessage();
                });
            });

            // ルールの表示/非表示
            if (rulesToggle) rulesToggle.addEventListener('click', () => {
                rulesContent.classList.toggle('show');
                rulesToggle.classList.toggle('open');
            });

            // ゲームをリセット
            if (resetButton) resetButton.addEventListener('click', () => {
                if (isOnlineGame) {
                    if (confirm('オンライン対戦中です。ゲームをリセットしますか？')) {
                        // オンライン接続をリセット
                        leaveGameRoom();
                        initGame();
                    }
                } else {
                    initGame();
                }
            });

            // パスボタン
            if (passButton) passButton.addEventListener('click', () => {
                // 召喚後は駒を置かないとパスできない
                if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                    alert('召喚した駒を盤面に打つ必要があります');
                    return;
                }

                // 自分のターンでなければパスできない（オンライン時）
                if (isOnlineGame && !isMyTurn()) {
                    alert('相手の手番です');
                    return;
                }

                // 移動IDを生成して二重処理を防ぐ
                const moveId = generateMoveId();
                gameState.lastMoveId = moveId;
                gameState.lastProcessedMoveId = moveId;

                // 手番を切り替え
                switchTurn();
                playSound('move');

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame && !isSpectator) {
                    syncGameState();
                }
            });

            // 召喚ボタン
            if (summonButton) summonButton.addEventListener('click', summonPiece);

            // プロモーションイベント
            if (promoteOption) promoteOption.addEventListener('click', () => handlePromotion(true));
            if (notPromoteOption) notPromoteOption.addEventListener('click', () => handlePromotion(false));

            // 効果音を再生（現在は無効化しています）
            function playSound(name) {
                // 音声機能は無効化されています
                return;
            }

            // チャットメッセージを送信
            async function sendChatMessage() {
                if (!isOnlineGame || !gameId) {
                    showToast('対局中のみチャットが利用できます', 'warn');
                    return;
                }

                const message = chatInput.value.trim();
                if (message === '') return;

                const timestamp = Date.now();
                const senderUid = firebase.auth().currentUser?.uid || `anon-${timestamp}`;
                let senderRole = playerRole;
                if (!senderRole) {
                    senderRole = isSpectator ? 'spectator' : 'visitor';
                }
                const nicknameToUse = userNickname || localStorage.getItem('userNickname') || '匿名';

                const payload = {
                    message,
                    senderRole,
                    sender: senderRole,
                    senderUid,
                    nickname: nicknameToUse,
                    timestamp
                };

                chatInput.value = '';

                displayChatMessage(payload.message, payload.senderRole, payload.nickname, payload.timestamp, payload.senderUid);

                if (!isRealtimeConnected) {
                    chatSendQueue.push(payload);
                    showToast('接続復帰後に送信します', 'warn');
                    updateChatInputState();
                    return;
                }

                try {
                    await postChatMessage(payload);
                } catch (err) {
                    console.error('チャット送信に失敗', err);
                    showToast('送信できませんでした。再送を試みます', 'error');
                    chatSendQueue.push(payload);
                    isRealtimeConnected = false;
                    updateChatInputState();
                }

                flushChatQueue();

                if (chatInput && !chatInput.disabled) {
                    setTimeout(() => chatInput.focus({ preventScroll: true }), 0);
                }
            }

            // チャットメッセージを表示
            function displayChatMessage(message, senderRole, nickname, timestamp, senderUid, messageKey) {
                if (!chatMessages) return;
                const baseId = `${senderUid || 'anon'}|${timestamp || 'unknown'}`;
                const candidateIds = [messageKey, baseId].filter(Boolean);
                if (candidateIds.some(id => displayedChatMessageIds.has(id))) return;
                candidateIds.forEach(id => displayedChatMessageIds.add(id));

                const messageEl = document.createElement('div');
                const currentUid = firebase.auth().currentUser?.uid;
                const isOwn = senderUid && currentUid && senderUid === currentUid;
                messageEl.className = `chat-message ${isOwn ? 'sent' : 'received'}`;

                const senderInfo = document.createElement('div');
                senderInfo.style.fontWeight = 'bold';
                senderInfo.style.marginBottom = '3px';
                const roleLabelMap = {
                    sente: '先手',
                    gote: '後手',
                    spectator: '観戦者',
                    visitor: '参加者'
                };
                const roleLabel = senderRole && roleLabelMap[senderRole] ? `（${roleLabelMap[senderRole]}）` : '';
                if (isOwn) {
                    senderInfo.textContent = roleLabel ? `あなた${roleLabel}` : 'あなた';
                } else {
                    senderInfo.textContent = `${nickname || '匿名'}${roleLabel}`;
                }

                const textEl = document.createElement('div');
                textEl.textContent = message;

                const timeEl = document.createElement('div');
                timeEl.className = 'chat-message-time';

                // タイムスタンプを整形
                const date = timestamp ? new Date(timestamp) : new Date();
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                timeEl.textContent = `${hours}:${minutes}`;

                messageEl.appendChild(senderInfo);
                messageEl.appendChild(textEl);
                messageEl.appendChild(timeEl);

                chatMessages.appendChild(messageEl);

                if (chatMessages.children.length > 200) {
                    const first = chatMessages.firstChild;
                    if (first) first.remove();
                }

                // 最新のメッセージが見えるようにスクロール
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // リマッチを申し込む
            async function offerRematch() {
                if (!isOnlineGame || !gameId || !(playerRole === 'sente' || playerRole === 'gote')) return;

                rematchButton.disabled = true;
                rematchStatus.textContent = 'リマッチを申し込み中...';

                // リマッチ情報をFirebaseに保存
                await ensureAnonAuth();
                database.ref(`games/${gameId}/rematch/${playerRole}`).set({
                    offered: true,
                    nickname: userNickname
                });

                // 相手のリマッチ受諾状態をチェック
                const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';
                database.ref(`games/${gameId}/rematch/${opponentRole}`).once('value')
                    .then((snapshot) => {
                        if (snapshot.exists() && snapshot.val().offered === true) {
                            // 両者がリマッチを希望
                            startRematch();
                        }
                    });
            }

            // リマッチを開始
            async function startRematch() {
                rematchStatus.textContent = 'リマッチが成立しました！新しいゲームを開始します...';

                // リマッチフラグをリセット
                await ensureAnonAuth();
                database.ref(`games/${gameId}/rematch`).remove();

                // 配置データをクリア（デッキルール用）
                database.ref(`games/${gameId}/placement`).remove();

                // ゲームのルールを取得
                const ruleSnapshot = await database.ref(`games/${gameId}/rule`).once('value');
                const gameRule = ruleSnapshot.val() || 'classic';

                // 役割を入れ替え（先手・後手を交代）
                const previousRole = playerRole;
                const nextRole = previousRole === 'sente' ? 'gote' : 'sente';
                applyPlayerRole(nextRole);

                const uid = firebase.auth().currentUser?.uid;
                if (uid && gameId) {
                    await database.ref(`games/${gameId}/players/${uid}/role`).set(nextRole);
                    await database.ref(`games/${gameId}/roles`).transaction(roles => {
                        if (!roles) return roles;
                        const currentSente = roles.sente;
                        const currentGote = roles.gote;
                        if (previousRole === 'sente' && currentSente === uid) {
                            roles.sente = currentGote || null;
                            roles.gote = uid;
                            return roles;
                        }
                        if (previousRole === 'gote' && currentGote === uid) {
                            roles.sente = uid;
                            roles.gote = currentSente || null;
                            return roles;
                        }
                        return roles;
                    });
                }

                // ルールに応じて適切な初期化関数を呼ぶ
                if (gameRule === 'deck') {
                    // デッキルール: initDeckGameで配置フェーズに戻る
                    initDeckGame();
                } else {
                    // クラシック: 通常のinitGame
                    initGame();
                    // ゲーム状態をFirebaseに初期化
                    syncGameState();
                }

                // リマッチコントロールを更新
                setTimeout(() => {
                    rematchButton.disabled = false;
                    rematchStatus.textContent = '';
                    rematchControls.style.display = 'none';
                }, 3000);

                // 状態を更新
                updateTurnIndicator();
            }

            // 作成: ゲームを waiting で作って待機し、開始を監視
            async function createGameRoom() {
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser.uid;
                const code = generateRandomId();
                const id = code; // 便宜上 code をそのまま gameId に
                const now = Date.now();

                // 制限時間を取得
                const timeLimit = timeLimitSelect ? parseInt(timeLimitSelect.value) : 0;

                const gameRef = database.ref(`games/${id}`);
                await gameRef.set({
                    code, createdAt: now,
                    status: { phase: 'waiting', turn: 'sente' },
                    players: {
                        [uid]: { role: 'sente', nickname: localStorage.getItem('userNickname'), online: true, joinedAt: now }
                    },
                    roles: { sente: uid, gote: null },
                    timeLimit: timeLimit, // 制限時間を保存
                    rule: selectedRule || 'classic' // ルールを保存
                });

                // 公開リスト（任意）
                await database.ref(`publicGames/${id}`).set({
                    code,
                    host: localStorage.getItem('userNickname'),
                    createdAt: now,
                    status: 'waiting',
                    rule: selectedRule || 'classic' // ルールを保存
                });

                // 接続切れ処理
                gameRef.child(`players/${uid}/online`).onDisconnect().set(false);

                isOnlineGame = true;
                isSpectator = false;
                gameId = id;
                localStorage.setItem('currentGameId', id);
                applyPlayerRole('sente');
                gameInfoElement.style.display = 'block';
                gameCodeElement.textContent = code;
                turnIndicator.style.display = 'block';
                turnIndicator.textContent = '対戦相手の接続を待っています…';

                // タイマーを初期化
                gameState.timeLimit = timeLimit;
                gameState.senteTimeRemaining = timeLimit;
                gameState.goteTimeRemaining = timeLimit;
                updateTimerDisplay();

                await attachGameListeners(id);
                restoreChatOverlayState();
                updateChatInputState();
                updateChatInputState();
            }

            function initialBoardState() {
                return {
                    ranks: {
                        1: {
                            e: { type: '王将', owner: 'sente' }
                        },
                        9: {
                            e: { type: '王将', owner: 'gote' }
                        }
                    },
                    captured: {
                        sente: [],
                        gote: []
                    },
                    turn: 'sente'
                };
            }



            // 参加: roles を原子的に確保し、players に反映（同時参加でも一意）
            async function joinGameRoomById(id) {
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser.uid;
                const nickname = localStorage.getItem('userNickname') || '匿名';
                const gameRef = database.ref(`games/${id}`);
                const gameSnap = await gameRef.once('value');
                if (!gameSnap.exists()) { alert('部屋が見つかりません'); return; }

                // ルールチェック: 部屋のルールと選択したルールが一致するか確認
                const roomRule = gameSnap.val().rule || 'classic';
                const playerRule = selectedRule || 'classic';
                if (roomRule !== playerRule) {
                    const ruleNames = { classic: 'クラシック', deck: 'デッキルール', deluxe: 'デラックス' };
                    alert(`この部屋は「${ruleNames[roomRule]}」モードです。\n「${ruleNames[playerRule]}」を選択した場合は参加できません。`);
                    return;
                }

                const now = Date.now();
                let decidedRole = null;
                // 旧部屋互換: roles がない場合は players から推定
                const existingPlayers = (gameSnap.child('players').val() || {});
                const inferred = { sente: null, gote: null };
                for (const [pid, p] of Object.entries(existingPlayers)) {
                    if (p?.role === 'sente') inferred.sente = pid;
                    if (p?.role === 'gote') inferred.gote = pid;
                }

                const roleTxn = await gameRef.child('roles').transaction(cur => {
                    const roles = cur || { sente: null, gote: null };
                    // 空いているところに推定を反映（既存プレイヤーの役割を尊重）
                    if (!roles.sente && inferred.sente) roles.sente = inferred.sente;
                    if (!roles.gote && inferred.gote) roles.gote = inferred.gote;
                    // すでに自分が入っている場合はそのまま
                    if (roles.sente === uid || roles.gote === uid) return roles;
                    // 典型: 先手が埋まっているので後手を確保
                    if (roles.sente && !roles.gote) { decidedRole = 'gote'; roles.gote = uid; return roles; }
                    // 先手が空いている場合は先手へ
                    if (!roles.sente) { decidedRole = 'sente'; roles.sente = uid; return roles; }
                    // それ以外は満員
                    return; // abort
                });

                if (!roleTxn.committed) { alert('この部屋は満員です'); return; }
                // roles に基づき players を更新
                if (!decidedRole) {
                    const rolesNow = roleTxn.snapshot.val() || {};
                    decidedRole = rolesNow.sente === uid ? 'sente' : 'gote';
                }
                await gameRef.child(`players/${uid}`).set({ role: decidedRole, nickname, online: true, joinedAt: now });

                // 接続切れ時のフラグ
                gameRef.child(`players/${uid}/online`).onDisconnect().set(false);

                // ローカル状態/表示
                isOnlineGame = true;
                isSpectator = false;
                gameId = id;
                localStorage.setItem('currentGameId', id);
                applyPlayerRole(decidedRole);
                if (gameInfoElement) gameInfoElement.style.display = 'block';
                if (gameCodeElement) gameCodeElement.textContent = gameSnap.val().code || id;
                if (turnIndicator) turnIndicator.style.display = 'block';

                await attachGameListeners(id);
                restoreChatOverlayState();
                updateChatInputState();
            }

            async function registerSpectator(gameId) {
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser.uid;
                const nickname = localStorage.getItem('userNickname') || '匿名';
                const spectatorRef = database.ref(`games/${gameId}/spectators/${uid}`);
                await spectatorRef.set({ nickname, online: true, joinedAt: Date.now() });
                spectatorRef.onDisconnect().remove();
            }

            async function watchGameRoomById(id) {
                await ensureAnonAuth();
                if (isOnlineGame && gameId && gameId !== id) {
                    await leaveGameRoom();
                }
                const uid = firebase.auth().currentUser.uid;
                const nickname = localStorage.getItem('userNickname') || '匿名';
                const gameRef = database.ref(`games/${id}`);
                const gameSnap = await gameRef.once('value');
                if (!gameSnap.exists()) { alert('部屋が見つかりません'); return; }

                await registerSpectator(id);

                isOnlineGame = true;
                isSpectator = true;
                gameId = id;
                localStorage.setItem('currentGameId', id);
                localStorage.setItem('playerRole', 'spectator');
                applyPlayerRole('spectator');

                if (gameInfoElement) gameInfoElement.style.display = 'block';
                if (gameCodeElement) gameCodeElement.textContent = gameSnap.val()?.code || id;
                if (turnIndicator) turnIndicator.style.display = 'block';
                restoreChatOverlayState();
                updateChatInputState();
                if (rematchControls) rematchControls.style.display = 'none';
                if (rematchButton) rematchButton.disabled = true;

                await attachGameListeners(id);
                await ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
                if (watchCodeInput) watchCodeInput.value = '';
                updateChatInputState();
            }

            // 入力制御・初期state一括書き込みユーティリティ
            function setInputEnabled(enabled) {
                if (typeof summonButton !== 'undefined' && summonButton) summonButton.disabled = !enabled;
                if (typeof passButton !== 'undefined' && passButton) passButton.disabled = !enabled;
            }

            async function pushInitialStateOnce(gameRef) {
                await gameRef.child('meta/startedAt').transaction(v => v || Date.now());

                // 召喚プールを生成（38枚）
                const pool = [];
                for (const [piece, info] of Object.entries(pieceTypes)) {
                    for (let i = 0; i < (info.count || 0); i++) pool.push(piece);
                }
                // フィッシャー–イェーツでシャッフル
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }

                const boardData = serializeBoard(gameState.board);

                // タイマー情報を取得
                const timeLimitSnapshot = await gameRef.child('timeLimit').once('value');
                const timeLimit = timeLimitSnapshot.val() || 0;

                const init = {
                    currentTurn: 'sente',
                    board: boardData,
                    senteHand: [], goteHand: [],
                    summonPool: pool,
                    hasSummoned: false,
                    mustPlaceLastSummoned: false,
                    lastSummonedPiece: null,
                    gameOver: false,
                    winner: null,
                    inCheck: { sente: false, gote: false },
                    lastMove: null,
                    lastMoveId: null,
                    timeLimit: timeLimit,
                    senteTimeRemaining: timeLimit,
                    goteTimeRemaining: timeLimit,
                    lastTurnChangeTime: Date.now()
                };
                await gameRef.child('state').set(init);

                // 互換: 旧ロジック向けにトップレベルにも保存
                const legacy = {
                    currentTurn: init.currentTurn,
                    board: JSON.stringify(boardData),
                    senteHand: JSON.stringify(init.senteHand),
                    goteHand: JSON.stringify(init.goteHand),
                    summonPool: JSON.stringify(init.summonPool),
                    hasSummoned: init.hasSummoned,
                    mustPlaceLastSummoned: init.mustPlaceLastSummoned,
                    lastSummonedPiece: init.lastSummonedPiece,
                    gameOver: init.gameOver,
                    winner: init.winner,
                    inCheck: JSON.stringify(init.inCheck),
                    lastMove: JSON.stringify(init.lastMove),
                    lastMoveId: init.lastMoveId,
                    timeLimit: init.timeLimit,
                    senteTimeRemaining: init.senteTimeRemaining,
                    goteTimeRemaining: init.goteTimeRemaining,
                    lastTurnChangeTime: init.lastTurnChangeTime,
                    lastUpdate: Date.now()
                };
                await gameRef.update(legacy);
            }

            // 2人になったら開始、state購読でUI同期
            // リスナー管理用変数
            let stateListenerRef = null;
            let legacyListenerRef = null;
            let connectionListenerActive = false;

            async function attachGameListeners(gameId) {
                await ensureAnonAuth();
                const gameRef = firebase.database().ref(`games/${gameId}`);

                // 既存リスナーを解除（重複防止）
                if (stateListenerRef) {
                    stateListenerRef.off();
                    stateListenerRef = null;
                }
                if (legacyListenerRef) {
                    legacyListenerRef.off();
                    legacyListenerRef = null;
                }

                // players 監視: 2人揃ったら開始処理 + 自分のrole反映
                gameRef.child('players').on('value', async snap => {
                    const players = snap.val() || {};
                    const count = Object.keys(players).length;

                    currentPlayers = players;

                    // 自分のroleをDBから確定してUIに反映
                    const me = firebase.auth().currentUser?.uid;
                    if (!isSpectator && me && players[me]?.role) {
                        applyPlayerRole(players[me].role);
                    }

                    // 役割マップがある場合はそちらを優先して反映
                    const rolesSnap = await gameRef.child('roles').once('value');
                    const roles = rolesSnap.val();
                    if (roles && me) {
                        const roleFromMap = roles.sente === me ? 'sente' : (roles.gote === me ? 'gote' : null);
                        if (roleFromMap && !isSpectator) {
                            applyPlayerRole(roleFromMap);
                        } else if (!roleFromMap && !isSpectator && playerRole) {
                            applyPlayerRole(null);
                        }
                    }

                    if (isSpectator) {
                        applyPlayerRole('spectator');
                        if (roleSelect) roleSelect.style.display = 'none';
                        if (roleSelectMsg) roleSelectMsg.textContent = '観戦モードです';
                    }

                    opponentConnected = count === 2;

                    // 公開リストのステータス更新（先手のみ）
                    const hostUid = roles && roles.sente;
                    if (hostUid && hostUid === firebase.auth().currentUser?.uid) {
                        try {
                            await firebase.database().ref(`publicGames/${gameId}`).update({
                                status: count >= 2 ? 'playing' : 'waiting'
                            });
                        } catch (e) {
                            console.warn('publicGames status 更新失敗', e);
                        }
                    }

                    if (count === 2) {
                        // 状態: 対局中へ
                        try { await gameRef.child('status/phase').set('playing'); } catch (e) { console.warn('status/phase 書き込み失敗', e); }
                        // 先手が初期state投入（1回だけ）
                        if (playerRole === 'sente') {
                            try {
                                const started = (await gameRef.child('meta/startedAt').once('value')).val();
                                if (!started) await pushInitialStateOnce(gameRef);
                            } catch (e) {
                                console.error('初期状態の書き込みに失敗しました。ルールで games/<id>/state と meta の書き込みを許可してください。', e);
                            }
                        }
                        if (gameInfoElement) gameInfoElement.style.display = 'block';
                        if (turnIndicator) turnIndicator.style.display = 'block';
                        restoreChatOverlayState();
                        if (typeof updateTurnIndicator === 'function') updateTurnIndicator();
                    }

                    // 役割選択UIの表示制御
                    const uid = firebase.auth().currentUser?.uid;
                    const myRoleKnown = !!(players[uid]?.role || (roles && (roles.sente === uid || roles.gote === uid)));
                    if (!gameState.gameOver && isOnlineGame && !isSpectator) {
                        // 両役埋まっていない or 自分の役が未確定 → 表示
                        const bothAssigned = !!(roles && roles.sente && roles.gote);
                        roleSelect.style.display = (!bothAssigned || !myRoleKnown) ? 'block' : 'none';
                        roleSelectMsg.textContent = (!bothAssigned) ? '役割を選んでください（先着優先）' : '';
                    } else {
                        roleSelect.style.display = 'none';
                    }

                    updateParticipantListDisplay();
                });

                // roles ノードの変化を監視してロールを常に同期
                gameRef.child('roles').on('value', snap => {
                    const roles = snap.val() || {};
                    const me = firebase.auth().currentUser?.uid;
                    if (!me) return;
                    if (isSpectator) {
                        applyPlayerRole('spectator');
                        return;
                    }
                    if (roles.sente === me) {
                        applyPlayerRole('sente');
                    } else if (roles.gote === me) {
                        applyPlayerRole('gote');
                    } else if (playerRole) {
                        applyPlayerRole(null);
                    }
                });

                gameRef.child('spectators').on('value', snap => {
                    currentSpectators = snap.val() || {};
                    updateParticipantListDisplay();
                });

                // state 監視: UI反映・入力制御
                stateListenerRef = gameRef.child('state');
                stateListenerRef.on('value', snap => {
                    const st = snap.val();
                    if (!st) return;

                    // 改善: lastMoveIdチェック（初回は必ず適用）
                    const shouldSkip = st.lastMoveId &&
                        gameState.lastProcessedMoveId &&
                        st.lastMoveId === gameState.lastProcessedMoveId;
                    if (shouldSkip) {
                        return;
                    }
                    if ('currentTurn' in st) gameState.currentTurn = st.currentTurn;
                    if ('board' in st) gameState.board = deserializeBoard(st.board);
                    if ('senteHand' in st) gameState.senteHand = normalizeList(st.senteHand);
                    if ('goteHand' in st) gameState.goteHand = normalizeList(st.goteHand);
                    if ('summonPool' in st) gameState.summonPool = normalizeList(st.summonPool);
                    if ('hasSummoned' in st) gameState.hasSummoned = !!st.hasSummoned;
                    if ('mustPlaceLastSummoned' in st) gameState.mustPlaceLastSummoned = !!st.mustPlaceLastSummoned;
                    if ('lastSummonedPiece' in st) gameState.lastSummonedPiece = st.lastSummonedPiece || null;
                    if ('inCheck' in st) gameState.inCheck = st.inCheck || { sente: false, gote: false };
                    if ('gameOver' in st) gameState.gameOver = !!st.gameOver;
                    if ('winner' in st) gameState.winner = st.winner || null;
                    if ('timeLimit' in st) gameState.timeLimit = st.timeLimit || 0;
                    if ('senteTimeRemaining' in st) gameState.senteTimeRemaining = st.senteTimeRemaining || 0;
                    if ('goteTimeRemaining' in st) gameState.goteTimeRemaining = st.goteTimeRemaining || 0;
                    if ('lastTurnChangeTime' in st) gameState.lastTurnChangeTime = st.lastTurnChangeTime;
                    if ('lastMoveId' in st) {
                        gameState.lastMoveId = st.lastMoveId;
                        gameState.lastProcessedMoveId = st.lastMoveId;
                    }

                    // 既存の描画系を呼ぶ（関数が存在する前提）
                    if (typeof renderBoard === 'function') renderBoard();
                    if (typeof renderHands === 'function') renderHands();
                    if (typeof renderSummonPool === 'function') renderSummonPool();
                    if (typeof updateStatus === 'function') updateStatus();
                    if (typeof updateCounters === 'function') updateCounters();
                    if (typeof updateTimerDisplay === 'function') updateTimerDisplay();

                    // タイマーを開始（自分の手番の場合のみ）
                    if (isMyTurn() && !gameState.gameOver && gameState.timeLimit > 0) {
                        startTimer();
                    }

                    setInputEnabled(isMyTurn());
                    if (turnIndicator) {
                        turnIndicator.textContent = isMyTurn() ? 'あなたの手番です' : '相手の手番です';
                    }
                });

                // 互換: state が使えない環境向けにトップレベルも監視
                legacyListenerRef = gameRef;
                legacyListenerRef.on('value', snap => {
                    if (!snap.exists()) {
                        alert('ゲームルームが削除されました');
                        leaveGameRoom().catch(err => console.error('ルーム離脱処理に失敗しました', err));
                        initGame();
                        return;
                    }

                    const st = snap.child('state').val();
                    if (st) return; // state が使えているならこちらは不要
                    const data = snap.val();
                    if (!data) return;
                    try {
                        // 改善: lastMoveIdチェック（初回は必ず適用）
                        const shouldSkip = data.lastMoveId &&
                            gameState.lastProcessedMoveId &&
                            data.lastMoveId === gameState.lastProcessedMoveId;
                        if (shouldSkip) {
                            return;
                        }
                        if ('currentTurn' in data) gameState.currentTurn = data.currentTurn || gameState.currentTurn;
                        if ('board' in data) gameState.board = deserializeBoard(data.board);
                        if ('senteHand' in data) gameState.senteHand = normalizeList(data.senteHand);
                        if ('goteHand' in data) gameState.goteHand = normalizeList(data.goteHand);
                        if ('summonPool' in data) gameState.summonPool = normalizeList(data.summonPool);
                        if ('hasSummoned' in data) gameState.hasSummoned = !!data.hasSummoned;
                        if ('mustPlaceLastSummoned' in data) gameState.mustPlaceLastSummoned = !!data.mustPlaceLastSummoned;
                        if ('lastSummonedPiece' in data) gameState.lastSummonedPiece = data.lastSummonedPiece || null;
                        if ('inCheck' in data) {
                            try {
                                gameState.inCheck = typeof data.inCheck === 'string' ? JSON.parse(data.inCheck) : (data.inCheck || { sente: false, gote: false });
                            } catch (e) {
                                gameState.inCheck = { sente: false, gote: false };
                            }
                        }
                        if ('gameOver' in data) gameState.gameOver = !!data.gameOver;
                        if ('winner' in data) gameState.winner = data.winner || null;
                        if ('timeLimit' in data) gameState.timeLimit = data.timeLimit || 0;
                        if ('senteTimeRemaining' in data) gameState.senteTimeRemaining = data.senteTimeRemaining || 0;
                        if ('goteTimeRemaining' in data) gameState.goteTimeRemaining = data.goteTimeRemaining || 0;
                        if ('lastTurnChangeTime' in data) gameState.lastTurnChangeTime = data.lastTurnChangeTime;
                        if ('lastMoveId' in data) {
                            gameState.lastMoveId = data.lastMoveId;
                            gameState.lastProcessedMoveId = data.lastMoveId;
                        }

                        if (typeof renderBoard === 'function') renderBoard();
                        if (typeof renderHands === 'function') renderHands();
                        if (typeof renderSummonPool === 'function') renderSummonPool();
                        if (typeof updateStatus === 'function') updateStatus();
                        if (typeof updateCounters === 'function') updateCounters();
                        if (typeof updateTimerDisplay === 'function') updateTimerDisplay();

                        setInputEnabled(isMyTurn());
                        if (turnIndicator) {
                            turnIndicator.textContent = isMyTurn() ? 'あなたの手番です' : '相手の手番です';
                        }
                    } catch (e) {
                        console.warn('レガシー状態の反映に失敗', e);
                    }
                });

                // 接続状態の監視（再接続時に自動同期）
                if (!connectionListenerActive) {
                    connectionListenerActive = true;
                    database.ref('.info/connected').on('value', snap => {
                        if (snap.val() === true) {
                            console.log('Firebase接続復帰');
                            // 再接続時に強制同期
                            if (isOnlineGame && gameId) {
                                setTimeout(() => {
                                    forceSync();
                                    console.log('再接続時の自動同期を実行');
                                }, 500);
                            }
                        } else {
                            console.log('Firebase接続が切断されました');
                        }
                    });
                }

                isOnlineGame = true;
            }

            // 2人オンラインなら phase を playing に
            async function startGameIfReady(id) {
                const gameRef = database.ref(`games/${id}`);
                const ps = (await gameRef.child('players').once('value')).val() || {};
                const count = Object.values(ps).filter(p => p && p.online !== false).length;
                if (count === 2) await gameRef.child('status/phase').set('playing');
            }

            // 役割選択（先手/後手）の確定処理（transactionで原子的に確保）
            async function chooseRole(role) {
                if (!isOnlineGame || !gameId || isSpectator) return;
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser.uid;
                const ref = database.ref(`games/${gameId}`);
                const tx = await ref.child('roles').transaction(cur => {
                    const roles = cur || { sente: null, gote: null };
                    // 既に自分がどちらかに入っていたら解放してから希望に入る
                    if (roles.sente === uid && role === 'gote') roles.sente = null;
                    if (roles.gote === uid && role === 'sente') roles.gote = null;
                    // 既に他人がその役を取っていたら中止
                    if (role === 'sente' && roles.sente && roles.sente !== uid) return; // abort
                    if (role === 'gote' && roles.gote && roles.gote !== uid) return; // abort
                    // 確保
                    if (role === 'sente') roles.sente = uid; else roles.gote = uid;
                    return roles;
                });
                if (!tx.committed) { roleSelectMsg.textContent = 'その役は既に埋まっています'; return; }
                await ref.child(`players/${uid}/role`).set(role);
                applyPlayerRole(role);
                roleSelectMsg.textContent = '役割を確定しました';
            }

            // phase 変更を監視してUIを有効化
            function watchGameStart(id) {
                const sRef = database.ref(`games/${id}/status/phase`);
                sRef.on('value', s => {
                    if (s && s.val() === 'playing') {
                        turnIndicator.textContent = playerRole === 'sente' ? 'あなたの先手番です' : '先手の着手待ち';
                        // TODO: 既存の盤面初期化/ボタン有効化などを呼ぶ
                        // 例: initGame(); enableBoardForOnline(); 等
                    } else {
                        turnIndicator.textContent = '対戦相手の接続を待っています…';
                    }
                });
            }

            // コードから gameId を検索
            async function findGameIdByCode(code) {
                await ensureAnonAuth();
                const snap = await firebase.database()
                    .ref('publicGames')
                    .orderByChild('code')
                    .equalTo(code)
                    .once('value');
                if (!snap.exists()) return null;
                return Object.keys(snap.val())[0];
            }

            // ゲームルームから離脱
            async function leaveGameRoom() {
                if (isOnlineGame && gameId) {
                    await ensureAnonAuth();
                    const uid = firebase.auth().currentUser?.uid;
                    const exitingRole = playerRole;
                    const wasSpectator = isSpectator;

                    // 監視を解除
                    database.ref(`games/${gameId}`).off();

                    if (uid) {
                        if (wasSpectator) {
                            await database.ref(`games/${gameId}/spectators/${uid}`).remove();
                        } else {
                            // players から自身を削除
                            await database.ref(`games/${gameId}/players/${uid}`).remove();
                            // roles マップを更新
                            await database.ref(`games/${gameId}/roles`).transaction(roles => {
                                if (!roles) return roles;
                                if (roles.sente === uid) roles.sente = null;
                                if (roles.gote === uid) roles.gote = null;
                                return roles;
                            });
                        }
                    }

                    if (exitingRole === 'sente') {
                        await database.ref(`publicGames/${gameId}`).remove();
                    }

                    stopChatListener();
                    stopRematchListener();

                    // リセット
                    isOnlineGame = false;
                    gameId = null;
                    opponentConnected = false;
                    isSpectator = false;
                    currentPlayers = {};
                    currentSpectators = {};
                    applyPlayerRole(null);
                    localStorage.removeItem('currentGameId');
                    updateParticipantListDisplay();
                    hideResultOverlay(false);

                    // UI更新
                    gameInfoElement.style.display = 'none';
                    turnIndicator.style.display = 'none';
                    rematchControls.style.display = 'none';
                    closeChatOverlay(false);
                    if (chatMessages) chatMessages.innerHTML = '';
                    displayedChatMessageIds.clear();
                    chatSendQueue.length = 0;
                    isFlushingChatQueue = false;
                    updateChatInputState();
                    if (createGameButton) createGameButton.disabled = false;
                    if (joinGameButton) joinGameButton.disabled = false;
                }
            }

            async function ensureChatListener() {
                if (!isOnlineGame || !gameId || chatListenerRef) return;
                await ensureAnonAuth();
                if (chatMessages) chatMessages.innerHTML = '';
                displayedChatMessageIds.clear();
                chatListenerRef = database.ref(`games/${gameId}/chat`);
                chatListenerRef.on('child_added', (snapshot) => {
                    const message = snapshot.val();
                    if (!message) return;
                    const role = message.senderRole || message.sender || 'visitor';
                    displayChatMessage(
                        message.message,
                        role,
                        message.nickname,
                        message.timestamp,
                        message.senderUid,
                        snapshot.key
                    );
                });
            }

            function stopChatListener() {
                if (chatListenerRef) {
                    chatListenerRef.off();
                    chatListenerRef = null;
                }
                displayedChatMessageIds.clear();
            }

            async function refreshRematchListener() {
                if (rematchListenerRef) {
                    rematchListenerRef.off();
                    rematchListenerRef = null;
                }

                if (!isOnlineGame || !gameId || !(playerRole === 'sente' || playerRole === 'gote')) return;

                const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';
                await ensureAnonAuth();
                rematchListenerRef = database.ref(`games/${gameId}/rematch/${opponentRole}`);
                rematchListenerRef.on('value', (snapshot) => {
                    if (snapshot.exists() && snapshot.val().offered === true) {
                        const opponentNickname = snapshot.val().nickname;
                        rematchStatus.textContent = `${opponentNickname}さんからリマッチの申し込みがあります`;
                        rematchControls.style.display = 'block';

                        database.ref(`games/${gameId}/rematch/${playerRole}`).once('value')
                            .then((mySnapshot) => {
                                if (mySnapshot.exists() && mySnapshot.val().offered === true) {
                                    startRematch();
                                }
                            });
                    }
                });
            }

            function stopRematchListener() {
                if (rematchListenerRef) {
                    rematchListenerRef.off();
                    rematchListenerRef = null;
                }
            }

            // ゲーム状態をFirebaseに同期（state 下へフラット保存）
            async function syncGameState() {
                if (!isOnlineGame || !gameId || isSpectator) return;
                await ensureAnonAuth();
                const boardData = serializeBoard(gameState.board);
                const st = {
                    currentTurn: gameState.currentTurn,
                    board: boardData,
                    senteHand: gameState.senteHand,
                    goteHand: gameState.goteHand,
                    summonPool: gameState.summonPool,
                    hasSummoned: gameState.hasSummoned,
                    mustPlaceLastSummoned: gameState.mustPlaceLastSummoned,
                    lastSummonedPiece: gameState.lastSummonedPiece,
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    inCheck: gameState.inCheck,
                    lastMove: gameState.lastMove,
                    lastMoveId: gameState.lastMoveId,
                    timeLimit: gameState.timeLimit,
                    senteTimeRemaining: gameState.senteTimeRemaining,
                    goteTimeRemaining: gameState.goteTimeRemaining,
                    lastTurnChangeTime: gameState.lastTurnChangeTime
                };
                await database.ref(`games/${gameId}/state`).set(st);

                // 互換: 旧ロジック向けにトップレベルにも保存
                const legacy = {
                    currentTurn: gameState.currentTurn,
                    board: JSON.stringify(boardData),
                    senteHand: JSON.stringify(gameState.senteHand),
                    goteHand: JSON.stringify(gameState.goteHand),
                    summonPool: JSON.stringify(gameState.summonPool),
                    hasSummoned: gameState.hasSummoned,
                    mustPlaceLastSummoned: gameState.mustPlaceLastSummoned,
                    lastSummonedPiece: gameState.lastSummonedPiece,
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    inCheck: JSON.stringify(gameState.inCheck),
                    lastMove: JSON.stringify(gameState.lastMove),
                    lastMoveId: gameState.lastMoveId,
                    timeLimit: gameState.timeLimit,
                    senteTimeRemaining: gameState.senteTimeRemaining,
                    goteTimeRemaining: gameState.goteTimeRemaining,
                    lastTurnChangeTime: gameState.lastTurnChangeTime,
                    lastUpdate: Date.now()
                };
                await database.ref(`games/${gameId}`).update(legacy);
            }

            // 自分のターンかどうかを確認
            function isMyTurn() {
                return isOnlineGame && playerRole === gameState.currentTurn && !gameState.gameOver;
            }

            // 手動同期：Firebaseから最新状態を強制取得
            async function forceSync() {
                if (!isOnlineGame || !gameId) {
                    window.showToast('オンラインゲームではありません', 'warn');
                    return;
                }

                const syncBtn = document.getElementById('manual-sync-btn');
                if (syncBtn) syncBtn.classList.add('syncing');

                try {
                    // まずゲーム状態を確認
                    const stateSnapshot = await database.ref(`games/${gameId}/state`).once('value');
                    const st = stateSnapshot.val();

                    if (st) {
                        // ゲームが開始している場合
                        // 強制的に状態を更新（lastMoveIdチェックを無視）
                        if ('currentTurn' in st) gameState.currentTurn = st.currentTurn;
                        if ('board' in st) gameState.board = deserializeBoard(st.board);
                        if ('senteHand' in st) gameState.senteHand = normalizeList(st.senteHand);
                        if ('goteHand' in st) gameState.goteHand = normalizeList(st.goteHand);
                        if ('summonPool' in st) gameState.summonPool = normalizeList(st.summonPool);
                        if ('hasSummoned' in st) gameState.hasSummoned = !!st.hasSummoned;
                        if ('mustPlaceLastSummoned' in st) gameState.mustPlaceLastSummoned = !!st.mustPlaceLastSummoned;
                        if ('lastSummonedPiece' in st) gameState.lastSummonedPiece = st.lastSummonedPiece || null;
                        if ('inCheck' in st) gameState.inCheck = st.inCheck || { sente: false, gote: false };
                        if ('gameOver' in st) gameState.gameOver = !!st.gameOver;
                        if ('winner' in st) gameState.winner = st.winner || null;
                        if ('timeLimit' in st) gameState.timeLimit = st.timeLimit || 0;
                        if ('senteTimeRemaining' in st) gameState.senteTimeRemaining = st.senteTimeRemaining || 0;
                        if ('goteTimeRemaining' in st) gameState.goteTimeRemaining = st.goteTimeRemaining || 0;
                        if ('lastTurnChangeTime' in st) gameState.lastTurnChangeTime = st.lastTurnChangeTime;
                        if ('lastMoveId' in st) {
                            gameState.lastMoveId = st.lastMoveId;
                            gameState.lastProcessedMoveId = st.lastMoveId;
                        }

                        // UI更新
                        renderBoard();
                        renderHands();
                        renderSummonPool();
                        updateStatus();
                        updateCounters();
                        updateTimerDisplay();
                        updateTurnIndicator();
                        updateButtonsState();

                        window.showToast('同期完了', 'success');
                    } else {
                        // ゲームがまだ開始していない（配置フェーズ中）
                        const placementSnapshot = await database.ref(`games/${gameId}/placement`).once('value');
                        const placement = placementSnapshot.val();

                        if (placement) {
                            const myRole = window.getPlayerRole();
                            const opponentRole = myRole === 'sente' ? 'gote' : 'sente';

                            if (placement[opponentRole] && placement[opponentRole].completed) {
                                // 相手は配置完了している → ゲーム開始処理を再実行
                                if (placement.sente && placement.sente.completed && placement.gote && placement.gote.completed) {
                                    window.showToast('両者配置完了を検出、ゲームを開始します', 'success');
                                    startGameFromPlacementData(placement);
                                }
                            } else {
                                window.showToast('相手の配置を待っています...', 'info');
                            }
                        } else {
                            window.showToast('配置データがありません', 'warn');
                        }
                    }
                } catch (error) {
                    console.error('同期エラー:', error);
                    window.showToast('同期に失敗しました', 'error');
                } finally {
                    if (syncBtn) syncBtn.classList.remove('syncing');
                }
            }



            // ターン表示を更新
            function updateTurnIndicator() {
                if (!isOnlineGame) {
                    turnIndicator.style.display = 'none';
                    return;
                }

                turnIndicator.style.display = 'block';

                if (!opponentConnected) {
                    turnIndicator.textContent = '対戦相手の接続を待っています...';
                    turnIndicator.className = 'turn-indicator';
                    return;
                }

                if (gameState.gameOver) {
                    const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                    turnIndicator.textContent = `ゲーム終了 - ${winnerText}の勝利`;
                    turnIndicator.className = 'turn-indicator';

                    // ゲーム終了時はリマッチコントロールを表示
                    rematchControls.style.display = 'block';
                    return;
                }

                if (isSpectator) {
                    const currentText = gameState.currentTurn === 'sente' ? '先手の手番です' : '後手の手番です';
                    turnIndicator.textContent = `観戦中: ${currentText}`;
                    turnIndicator.className = 'turn-indicator';
                    return;
                }

                if (isMyTurn()) {
                    turnIndicator.textContent = 'あなたの手番です';
                    turnIndicator.className = 'turn-indicator your-turn';
                } else {
                    turnIndicator.textContent = '相手の手番です';
                    turnIndicator.className = 'turn-indicator opponent-turn';
                }
            }

            // タイマー関連の関数
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            function updateTimerDisplay() {
                if (!timerContainer) return;

                if (gameState.timeLimit === 0) {
                    timerContainer.style.display = 'none';
                    return;
                }

                timerContainer.style.display = 'flex';

                if (senteTimeElement) {
                    senteTimeElement.textContent = formatTime(gameState.senteTimeRemaining);
                }
                if (goteTimeElement) {
                    goteTimeElement.textContent = formatTime(gameState.goteTimeRemaining);
                }

                // アクティブなタイマーをハイライト
                if (senteTimer && goteTimer) {
                    senteTimer.classList.toggle('active', gameState.currentTurn === 'sente' && !gameState.gameOver);
                    goteTimer.classList.toggle('active', gameState.currentTurn === 'gote' && !gameState.gameOver);

                    // 残り時間が30秒以下で警告表示
                    senteTimer.classList.toggle('warning', gameState.senteTimeRemaining <= 30 && gameState.senteTimeRemaining > 0);
                    goteTimer.classList.toggle('warning', gameState.goteTimeRemaining <= 30 && gameState.goteTimeRemaining > 0);
                }
            }

            function startTimer() {
                if (gameState.timeLimit === 0 || gameState.gameOver) return;

                stopTimer(); // 既存のタイマーを停止

                gameState.lastTurnChangeTime = Date.now();

                timerInterval = setInterval(() => {
                    if (gameState.gameOver || !isOnlineGame) {
                        stopTimer();
                        return;
                    }

                    const currentPlayer = gameState.currentTurn;
                    const timeKey = currentPlayer === 'sente' ? 'senteTimeRemaining' : 'goteTimeRemaining';

                    if (gameState[timeKey] > 0) {
                        gameState[timeKey]--;
                        updateTimerDisplay();

                        // 時間切れチェック
                        if (gameState[timeKey] === 0) {
                            handleTimeUp(currentPlayer);
                        }

                        // オンライン対戦時は状態を同期
                        if (isOnlineGame && isMyTurn()) {
                            syncGameState();
                        }
                    }
                }, 1000);
            }

            function stopTimer() {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            }

            function handleTimeUp(player) {
                stopTimer();
                gameState.gameOver = true;
                gameState.winner = player === 'sente' ? 'gote' : 'sente';

                const loserText = player === 'sente' ? '先手' : '後手';
                const winnerText = player === 'sente' ? '後手' : '先手';

                statusElement.innerHTML = `<strong>${winnerText}の勝利！</strong><br>${loserText}の時間切れ`;

                playSound('gameover');

                // 結果オーバーレイを表示
                if (isOnlineGame) {
                    if (playerRole === gameState.winner) {
                        showResultOverlay('win');
                    } else if (playerRole) {
                        showResultOverlay('lose');
                    } else {
                        showResultOverlay(gameState.winner === 'sente' ? 'sente-win' : 'gote-win');
                    }
                } else {
                    showResultOverlay(gameState.winner === 'sente' ? 'sente-win' : 'gote-win');
                }

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame && !isSpectator) {
                    syncGameState();
                }

                updateStatus();
                renderBoard();
            }


            // ゲームを初期化
            function initGame() {
                hideResultOverlay(false);
                // ボードをクリア
                gameState.board = Array(9).fill().map(() => Array(9).fill(null));
                gameState.senteHand = [];
                gameState.goteHand = [];
                gameState.selectedPiece = null;
                gameState.selectedCell = null;
                gameState.possibleMoves = [];
                gameState.currentTurn = 'sente';
                gameState.hasSummoned = false;
                gameState.mustPlaceLastSummoned = false; // 召喚した駒を置かなければならないフラグ
                gameState.lastSummonedPiece = null; // 最後に召喚した駒の種類
                gameState.gameOver = false;
                gameState.winner = null; // 勝者をリセット
                gameState.inCheck = { sente: false, gote: false };
                gameState.lastMove = null;
                gameState.pendingPromotion = null;
                gameState.lastMoveId = null;
                gameState.lastProcessedMoveId = null;

                // 召喚プールを初期化
                gameState.summonPool = [];
                for (const [piece, info] of Object.entries(pieceTypes)) {
                    for (let i = 0; i < info.count; i++) {
                        gameState.summonPool.push(piece);
                    }
                }

                // 王将と玉将を初期配置
                gameState.board[8][4] = createPiece('王', 'sente');
                gameState.board[0][4] = createPiece('玉', 'gote');

                // UIを更新
                updateBoardFlipState();
                renderBoard();
                renderHands();
                renderSummonPool();
                updateStatus();
                updateCounters();

                // 召喚ボタンを有効化
                updateButtonsState();

                // 召喚情報を更新
                updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame && !isSpectator) {
                    syncGameState();
                }

                updateChatInputState();

                // タイマーを停止して表示を更新
                stopTimer();
                updateTimerDisplay();
            }

            // ボタンの状態を更新
            function updateButtonsState() {
                const canAct = !isOnlineGame || isMyTurn();

                // 召喚ボタンの状態
                summonButton.disabled = gameState.summonPool.length === 0 ||
                    gameState.hasSummoned ||
                    gameState.gameOver ||
                    !canAct;

                // パスボタンの状態
                passButton.disabled = gameState.gameOver ||
                    (gameState.hasSummoned && gameState.mustPlaceLastSummoned) ||
                    !canAct;
            }

            // カウンターを更新
            function updateCounters() {
                summonCountElement.textContent = `${gameState.summonPool.length}枚`;
                senteCountElement.textContent = `${gameState.senteHand.length}枚`;
                goteCountElement.textContent = `${gameState.goteHand.length}枚`;
            }

            // 召喚情報を更新
            function updateSummonInfo(text) {
                summonInfoElement.textContent = text;
            }

            // ボードをレンダリング
            function renderBoard() {
                boardElement.innerHTML = '';
                updateCoordinateLabels();
                boardElement.classList.toggle('flipped', isBoardFlipped);

                const rowOrder = isBoardFlipped ? [...Array(9).keys()].reverse() : [...Array(9).keys()];
                const colOrder = isBoardFlipped ? [...Array(9).keys()].reverse() : [...Array(9).keys()];

                for (const boardY of rowOrder) {
                    for (const boardX of colOrder) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = boardX;
                        cell.dataset.y = boardY;

                        // 駒があれば表示
                        const piece = gameState.board[boardY][boardX];
                        if (piece && piece.type) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.owner}`;
                            if (gameState.selectedCell && gameState.selectedCell.x === boardX && gameState.selectedCell.y === boardY) {
                                pieceElement.classList.add('selected');
                            }

                            // 最後に動かした駒にアニメーションを適用
                            if (gameState.lastMove && gameState.lastMove.toX === boardX && gameState.lastMove.toY === boardY) {
                                pieceElement.classList.add('animated');
                            }

                            pieceElement.textContent = piece.type;
                            cell.appendChild(pieceElement);
                        }

                        // セルのハイライト
                        if (gameState.possibleMoves.some(move => {
                            if (move.x === boardX && move.y === boardY) {
                                const targetPiece = gameState.board[boardY][boardX];
                                if (targetPiece && targetPiece.owner !== gameState.currentTurn) {
                                    cell.classList.add('highlight-attack');
                                } else {
                                    cell.classList.add('highlight-move');
                                }
                                return true;
                            }
                            return false;
                        })) {
                            // ハイライトは上記のif文で適用済み
                        }

                        // クリックイベント
                        cell.addEventListener('click', () => handleCellClick(boardX, boardY));

                        boardElement.appendChild(cell);
                    }
                }
            }

            // 持ち駒をレンダリング
            function renderHands() {
                // 先手の持ち駒
                senteHandElement.innerHTML = '';

                // 持ち駒を種類ごとに集計
                const senteHandCount = gameState.senteHand.reduce((acc, piece) => {
                    acc[piece] = (acc[piece] || 0) + 1;
                    return acc;
                }, {});

                // 持ち駒を種類順に並べる
                const sortedSentePieces = Object.keys(senteHandCount).sort((a, b) => {
                    const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                    return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
                });

                for (const piece of sortedSentePieces) {
                    const count = senteHandCount[piece];
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'hand-piece sente';

                    // 召喚した駒の場合はsummonedクラスを追加
                    if (gameState.mustPlaceLastSummoned &&
                        gameState.lastSummonedPiece === piece &&
                        gameState.currentTurn === 'sente') {
                        pieceElement.classList.add('summoned');
                    }

                    pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                    pieceElement.dataset.type = piece;
                    pieceElement.addEventListener('click', () => {
                        if (isOnlineGame && playerRole !== 'sente') return; // オンライン対戦時は自分の持ち駒だけ
                        handleHandPieceClick(piece, 'sente');
                    });
                    senteHandElement.appendChild(pieceElement);
                }

                // 後手の持ち駒
                goteHandElement.innerHTML = '';

                // 持ち駒を種類ごとに集計
                const goteHandCount = gameState.goteHand.reduce((acc, piece) => {
                    acc[piece] = (acc[piece] || 0) + 1;
                    return acc;
                }, {});

                // 持ち駒を種類順に並べる
                const sortedGotePieces = Object.keys(goteHandCount).sort((a, b) => {
                    const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                    return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
                });

                for (const piece of sortedGotePieces) {
                    const count = goteHandCount[piece];
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'hand-piece gote';

                    // 召喚した駒の場合はsummonedクラスを追加
                    if (gameState.mustPlaceLastSummoned &&
                        gameState.lastSummonedPiece === piece &&
                        gameState.currentTurn === 'gote') {
                        pieceElement.classList.add('summoned');
                    }

                    pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                    pieceElement.dataset.type = piece;
                    pieceElement.addEventListener('click', () => {
                        if (isOnlineGame && playerRole !== 'gote') return; // オンライン対戦時は自分の持ち駒だけ
                        handleHandPieceClick(piece, 'gote');
                    });
                    goteHandElement.appendChild(pieceElement);
                }
            }

            // 召喚プールをレンダリング
            function renderSummonPool() {
                summonPoolElement.innerHTML = '';

                // 召喚プールの駒の数を表示
                const pieceCounts = gameState.summonPool.reduce((acc, piece) => {
                    acc[piece] = (acc[piece] || 0) + 1;
                    return acc;
                }, {});

                // 駒を種類順に並べる
                const sortedPieces = Object.keys(pieceCounts).sort((a, b) => {
                    const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                    return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
                });

                for (const piece of sortedPieces) {
                    const count = pieceCounts[piece];
                    const pieceElement = document.createElement('div');
                    pieceElement.className = 'summon-piece';
                    pieceElement.textContent = `${piece}×${count}`;
                    summonPoolElement.appendChild(pieceElement);
                }

                // ボタンの状態を更新
                updateButtonsState();
            }

            // ステータスを更新
            function updateStatus() {
                statusElement.className = 'status';

                if (gameState.gameOver) {
                    const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                    statusElement.textContent = `${winnerText}の勝利！`;
                    statusElement.classList.add('gameover');
                    const outcome = (isSpectator || !(playerRole === 'sente' || playerRole === 'gote'))
                        ? (gameState.winner === 'sente' ? 'sente-win' : 'gote-win')
                        : (gameState.winner === playerRole ? 'win' : 'lose');
                    showResultOverlay(outcome);
                } else if (gameState.inCheck.sente) {
                    statusElement.textContent = '先手の王が王手です！';
                    statusElement.classList.add('check');
                    hideResultOverlay(false);
                } else if (gameState.inCheck.gote) {
                    statusElement.textContent = '後手の玉が王手です！';
                    statusElement.classList.add('check');
                    hideResultOverlay(false);
                } else {
                    statusElement.textContent = gameState.currentTurn === 'sente' ? '先手の手番です' : '後手の手番です';
                    statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');
                    hideResultOverlay(false);
                }

                // ボタンの状態を更新
                updateButtonsState();
            }

            // セルがクリックされたときの処理
            function handleCellClick(x, y) {
                if (gameState.gameOver) return;

                // オンライン対戦時は自分のターンのみ操作可能
                if (isOnlineGame && !isMyTurn()) {
                    return;
                }

                const clickedPiece = gameState.board[y][x];

                // 選択中の駒があり、有効な移動先がクリックされた場合
                if (gameState.selectedPiece && gameState.possibleMoves.some(move => move.x === x && move.y === y)) {
                    movePiece(x, y);
                    return;
                }

                // 選択をクリア
                gameState.selectedPiece = null;
                gameState.selectedCell = null;
                gameState.possibleMoves = [];

                // 自分の駒をクリックした場合
                if (clickedPiece && clickedPiece.owner === gameState.currentTurn) {
                    gameState.selectedPiece = clickedPiece;
                    gameState.selectedCell = { x, y };
                    gameState.possibleMoves = calculatePossibleMoves(x, y, clickedPiece);
                }

                renderBoard();
            }

            // 持ち駒がクリックされたときの処理
            function handleHandPieceClick(pieceType, owner) {
                const normalizedOwner = normalizeOwner(owner);
                if (gameState.gameOver || normalizedOwner !== gameState.currentTurn) return;

                // オンライン対戦時は自分のターンのみ操作可能
                if (isOnlineGame && !isMyTurn()) {
                    return;
                }

                // 召喚後の場合は、その駒だけを選べるようにする
                if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                    // 最後に召喚した駒以外は選べないようにする（実装の簡略化のため省略）
                }

                // 選択をクリア
                gameState.selectedPiece = { type: pieceType, owner: normalizedOwner, fromHand: true };
                gameState.selectedCell = null;
                gameState.possibleMoves = calculateDropPositions(pieceType);

                renderBoard();

                // 召喚後は駒を置くよう促す
                if (gameState.hasSummoned) {
                    updateSummonInfo(`召喚した${pieceType}を盤面に打ってください`);
                }
            }

            // 駒を移動
            function movePiece(toX, toY) {
                const { selectedPiece, selectedCell } = gameState;
                const movingOwner = normalizeOwner(selectedPiece.owner) || gameState.currentTurn;

                // 持ち駒を置く場合
                if (selectedPiece.fromHand) {
                    // 持ち駒から削除
                    const hand = movingOwner === 'sente' ? gameState.senteHand : gameState.goteHand;
                    const index = hand.indexOf(selectedPiece.type);
                    if (index !== -1) {
                        hand.splice(index, 1);
                    }

                    // ボードに配置
                    gameState.board[toY][toX] = createPiece(selectedPiece.type, movingOwner);

                    // 最後の移動を記録
                    gameState.lastMove = {
                        fromX: null,
                        fromY: null,
                        toX,
                        toY,
                        isFromHand: true
                    };

                    playSound('move');

                    // 召喚した駒を置いた場合、そのフラグをリセット
                    if (gameState.hasSummoned) {
                        gameState.mustPlaceLastSummoned = false;
                        gameState.lastSummonedPiece = null;
                    }
                } else {
                    // 盤上の駒を移動
                    const fromX = selectedCell.x;
                    const fromY = selectedCell.y;

                    // 移動先に相手の駒があれば持ち駒にする
                    const targetPiece = gameState.board[toY][toX];
                    if (targetPiece) {
                        // 成り駒は元に戻す
                        let capturedType = targetPiece.type;
                        for (const [original, info] of Object.entries(pieceTypes)) {
                            if (info.promotion === capturedType) {
                                capturedType = original;
                                break;
                            }
                        }

                        // 王や玉は取れない（念のためチェック）
                        if (capturedType !== '王' && capturedType !== '玉') {
                            addPieceToHand(movingOwner, capturedType);
                        }

                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    // 駒を移動
                    gameState.board[toY][toX] = createPiece(selectedPiece.type, movingOwner);
                    gameState.board[fromY][fromX] = null;

                    // 最後の移動を記録
                    gameState.lastMove = { fromX, fromY, toX, toY, isFromHand: false };

                    // 成りの確認
                    const canPromote = checkCanPromote(fromX, fromY, toX, toY, selectedPiece);
                    if (canPromote) {
                        // 成りのダイアログを表示
                        showPromotionDialog(toX, toY, selectedPiece);
                        return; // 処理を中断して成りのダイアログを表示
                    }
                }

                // 処理を完了
                finalizeTurnAfterMove();
            }

            // 成りの可能性をチェック
            function checkCanPromote(fromX, fromY, toX, toY, piece) {
                const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
                if (!promotionInfo || !promotionInfo[1].promotion) return false;

                // 成れる条件（敵陣3段目以内に入った、または敵陣から出た）
                const isInPromotionZone = (piece.owner === 'sente' && (toY <= 2 || fromY <= 2)) ||
                    (piece.owner === 'gote' && (toY >= 6 || fromY >= 6));

                if (isInPromotionZone) {
                    return true;
                }

                // 成らないと動けない場合は自動的に成る
                const mustPromote = (piece.type === '歩' || piece.type === '香') &&
                    ((piece.owner === 'sente' && toY === 0) ||
                        (piece.owner === 'gote' && toY === 8)) ||
                    (piece.type === '桂' &&
                        ((piece.owner === 'sente' && toY <= 1) ||
                            (piece.owner === 'gote' && toY >= 7)));

                if (mustPromote) {
                    // 自動的に成る
                    const promoted = promotionInfo[1].promotion;
                    gameState.board[toY][toX].type = promoted;
                    return false;
                }

                return false;
            }

            // 成りダイアログを表示
            function showPromotionDialog(x, y, piece) {
                const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
                if (!promotionInfo || !promotionInfo[1].promotion) return;

                const promoted = promotionInfo[1].promotion;

                // ダイアログの内容を設定
                promoteOption.textContent = promoted;
                notPromoteOption.textContent = piece.type;

                // 成り駒の位置を記録
                gameState.pendingPromotion = { x, y, piece };

                // ダイアログを表示
                promotionDialog.style.display = 'flex';
            }

            // 成りの選択を処理
            function handlePromotion(doPromote) {
                const { x, y, piece } = gameState.pendingPromotion;

                if (doPromote) {
                    const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
                    if (promotionInfo && promotionInfo[1].promotion) {
                        gameState.board[y][x].type = promotionInfo[1].promotion;
                    }
                }

                // ダイアログを閉じる
                promotionDialog.style.display = 'none';
                gameState.pendingPromotion = null;

                // ターンを完了
                finalizeTurnAfterMove();
            }

            // 駒の移動後にターンを完了
            function finalizeTurnAfterMove() {
                // 選択をクリア
                gameState.selectedPiece = null;
                gameState.selectedCell = null;
                gameState.possibleMoves = [];

                // 王手をチェック
                checkForCheck();

                // 手番を進める前に相手側の詰みチェック
                const nextPlayer = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
                gameState.currentTurn = nextPlayer; // 一時的に次のプレイヤーにして詰みをチェック

                // チェックメイトをチェック
                if (isCheckmate()) {
                    gameState.gameOver = true;
                    // 勝者を記録（現在の手番が詰まされているので、元の手番のプレイヤーが勝者）
                    gameState.winner = nextPlayer === 'sente' ? 'gote' : 'sente';

                    // ゲーム終了処理
                    endGame();
                    return;
                }

                // 重要: 召喚フラグをリセット
                gameState.hasSummoned = false;
                gameState.mustPlaceLastSummoned = false;
                gameState.lastSummonedPiece = null;

                const moveId = generateMoveId();
                gameState.lastMoveId = moveId;
                gameState.lastProcessedMoveId = moveId;

                // UI更新
                updateStatus();
                renderBoard();
                renderHands();
                renderSummonPool();
                updateCounters();

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame && !isSpectator) {
                    syncGameState();
                }
            }

            // ゲーム終了処理
            function endGame() {
                updateStatus();
                renderBoard();
                updateCounters();
                playSound('gameover');

                // ボタンを無効化
                summonButton.disabled = true;
                passButton.disabled = true;

                // 勝利メッセージをより目立たせる
                const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                const loserText = gameState.winner === 'sente' ? '後手' : '先手';
                statusElement.innerHTML = `<strong>${winnerText}の勝利！</strong><br>${loserText}の${gameState.winner === 'sente' ? '玉' : '王'}が詰みました`;

                // 詰みの場所をハイライト
                const kingPos = findKing(gameState.winner === 'sente' ? 'gote' : 'sente');
                if (kingPos) {
                    const cells = document.querySelectorAll('.cell');
                    cells.forEach(cell => {
                        const x = parseInt(cell.dataset.x);
                        const y = parseInt(cell.dataset.y);
                        if (x === kingPos.x && y === kingPos.y) {
                            cell.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                            cell.style.boxShadow = '0 0 10px red';
                        }
                    });
                }

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame) {
                    syncGameState();

                    // リマッチコントロールを表示
                    rematchControls.style.display = 'block';
                }

                // ターン表示を更新
                updateTurnIndicator();

                const winner = gameState.winner;
                let outcomeKey = null;
                if (winner) {
                    if (isSpectator || !(playerRole === 'sente' || playerRole === 'gote')) {
                        outcomeKey = winner === 'sente' ? 'sente-win' : 'gote-win';
                    } else {
                        outcomeKey = winner === playerRole ? 'win' : 'lose';
                    }
                }
                if (outcomeKey) {
                    showResultOverlay(outcomeKey);
                } else {
                    hideResultOverlay(false);
                }
            }

            // 王手の確認
            function checkForCheck() {
                const senteKingPos = findKing('sente');
                const goteKingPos = findKing('gote');

                const senteWasInCheck = gameState.inCheck.sente;
                const goteWasInCheck = gameState.inCheck.gote;

                gameState.inCheck.sente = isPositionUnderAttack(senteKingPos.x, senteKingPos.y, 'gote');
                gameState.inCheck.gote = isPositionUnderAttack(goteKingPos.x, goteKingPos.y, 'sente');

                // 新たに王手になった場合に効果音を再生
                if (!senteWasInCheck && gameState.inCheck.sente ||
                    !goteWasInCheck && gameState.inCheck.gote) {
                    playSound('check');
                }
            }

            // 詰み判定（シンプルで確実なアルゴリズム）
            function isCheckmate() {
                const currentPlayer = gameState.currentTurn;

                // 王手がかかっていなければ詰みではない
                if ((currentPlayer === 'sente' && !gameState.inCheck.sente) ||
                    (currentPlayer === 'gote' && !gameState.inCheck.gote)) {
                    return false;
                }

                // 王の位置を取得
                const kingPos = findKing(currentPlayer);
                if (!kingPos) return false; // 念のためチェック

                // すべての可能な手を試す（王の移動、駒の移動、持ち駒の使用）

                // 1. 王が移動できるかチェック
                const kingPiece = gameState.board[kingPos.y][kingPos.x];
                const kingMoves = calculatePossibleMoves(kingPos.x, kingPos.y, kingPiece);

                for (const move of kingMoves) {
                    const tmpBoard = cloneBoard(gameState.board);
                    // 王を移動
                    tmpBoard[move.y][move.x] = tmpBoard[kingPos.y][kingPos.x];
                    tmpBoard[kingPos.y][kingPos.x] = null;

                    // 移動後も王手されているかチェック
                    if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                        // 王手回避できる
                        return false;
                    }
                }

                // 2. 他の駒を動かして王手を回避できるかチェック
                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const piece = gameState.board[y][x];
                        if (piece && piece.owner === currentPlayer &&
                            (piece.type !== '王' && piece.type !== '玉')) {

                            const moves = calculatePossibleMoves(x, y, piece);
                            for (const move of moves) {
                                const tmpBoard = cloneBoard(gameState.board);
                                // 駒を移動（移動先に相手の駒があれば取る）
                                tmpBoard[move.y][move.x] = tmpBoard[y][x];
                                tmpBoard[y][x] = null;

                                // 移動後も王手されているかチェック
                                if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                                    // 王手回避できる
                                    return false;
                                }
                            }
                        }
                    }
                }

                // 3. 持ち駒を使って王手を回避できるかチェック
                const hand = currentPlayer === 'sente' ? gameState.senteHand : gameState.goteHand;
                const uniquePieces = [...new Set(hand)]; // 重複を排除

                for (const pieceType of uniquePieces) {
                    const dropPositions = calculateDropPositions(pieceType);
                    for (const pos of dropPositions) {
                        const tmpBoard = cloneBoard(gameState.board);
                        // 持ち駒を配置
                        tmpBoard[pos.y][pos.x] = { type: pieceType, owner: currentPlayer };

                        // 配置後も王手されているかチェック
                        if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                            // 王手回避できる
                            return false;
                        }
                    }
                }

                // すべての手を試しても王手を回避できないため詰み
                return true;
            }

            // 盤面をコピー
            function cloneBoard(board) {
                return JSON.parse(JSON.stringify(board));
            }

            // 指定した盤面で王が王手されているかをチェック
            function isKingInCheckWithBoard(player, board) {
                const kingPos = findKingInBoard(player, board);
                if (!kingPos) return false;

                const opponentPlayer = player === 'sente' ? 'gote' : 'sente';
                return isPositionUnderAttackWithBoard(kingPos.x, kingPos.y, opponentPlayer, board);
            }

            // 指定した盤面で王の位置を探す
            function findKingInBoard(player, board) {
                const kingType = player === 'sente' ? '王' : '玉';

                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const piece = board[y][x];
                        if (piece && piece.owner === player && piece.type === kingType) {
                            return { x, y };
                        }
                    }
                }

                return null;
            }

            // 王の位置を探す
            function findKing(player) {
                const kingType = player === 'sente' ? '王' : '玉';

                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const piece = gameState.board[y][x];
                        if (piece && piece.owner === player && piece.type === kingType) {
                            return { x, y };
                        }
                    }
                }

                return null;
            }

            // 位置が攻撃を受けているかチェック
            function isPositionUnderAttack(x, y, attackerPlayer) {
                for (let cy = 0; cy < 9; cy++) {
                    for (let cx = 0; cx < 9; cx++) {
                        const piece = gameState.board[cy][cx];
                        if (piece && piece.owner === attackerPlayer) {
                            // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                            const moves = calculateRawPossibleMoves(cx, cy, piece, true);
                            if (moves.some(move => move.x === x && move.y === y)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // 盤面で位置が攻撃を受けているかチェック
            function isPositionUnderAttackWithBoard(x, y, attackerPlayer, board) {
                for (let cy = 0; cy < 9; cy++) {
                    for (let cx = 0; cx < 9; cx++) {
                        const piece = board[cy][cx];
                        if (piece && piece.owner === attackerPlayer) {
                            // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                            const moves = calculateRawPossibleMovesWithBoard(cx, cy, piece, board, true);
                            if (moves.some(move => move.x === x && move.y === y)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            // 生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
            function calculateRawPossibleMoves(x, y, piece, checkingAttack = false) {
                return calculateRawPossibleMovesWithBoard(x, y, piece, gameState.board, checkingAttack);
            }

            // 盤面での生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
            function calculateRawPossibleMovesWithBoard(x, y, piece, board, checkingAttack = false) {
                const moves = [];
                const movePatterns = pieceMoves[piece.type];

                if (!movePatterns) return moves;

                for (const pattern of movePatterns) {
                    const range = pattern.range || 1;

                    for (let i = 1; i <= range; i++) {
                        let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                        let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                        const newX = x + dx * i;
                        const newY = y + dy * i;

                        // ボード外ならスキップ
                        if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                            break;
                        }

                        const targetPiece = board[newY][newX];

                        // 自分の駒があれば移動不可
                        if (targetPiece && targetPiece.owner === piece.owner) {
                            break;
                        }

                        // マスを追加
                        moves.push({ x: newX, y: newY });

                        // 駒があれば次のマスには移動できない
                        if (targetPiece) {
                            break;
                        }
                    }
                }

                return moves;
            }

            // 可能な移動先を計算
            function calculatePossibleMoves(x, y, piece, checkingAttack = false) {
                const moves = [];
                const movePatterns = pieceMoves[piece.type];
                const isKing = piece.type === '王' || piece.type === '玉';
                const opponentPlayer = piece.owner === 'sente' ? 'gote' : 'sente';

                if (!movePatterns) return moves;

                for (const pattern of movePatterns) {
                    const range = pattern.range || 1;

                    for (let i = 1; i <= range; i++) {
                        let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                        let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                        const newX = x + dx * i;
                        const newY = y + dy * i;

                        // ボード外ならスキップ
                        if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                            break;
                        }

                        const targetPiece = gameState.board[newY][newX];

                        // 自分の駒があれば移動不可
                        if (targetPiece && targetPiece.owner === piece.owner) {
                            break;
                        }

                        // 王手チェック時は相手の駒を取れるか確認のみ
                        if (checkingAttack) {
                            moves.push({ x: newX, y: newY });

                            // 駒があれば次のマスには移動できない
                            if (targetPiece) {
                                break;
                            }
                        } else {
                            // 通常の移動チェック
                            // 王手がかかっている場合は、王手を回避する手だけを許可
                            const isChecked = piece.owner === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;

                            // 王の場合は、移動先が相手の利きに入っていないことを確認
                            if (isKing) {
                                // 移動後の盤面をシミュレート
                                const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                                tmpBoard[newY][newX] = tmpBoard[y][x];
                                tmpBoard[y][x] = null;

                                // 移動先が安全かチェック
                                const wouldBeInCheck = isPositionUnderAttackWithBoard(
                                    newX, newY,
                                    opponentPlayer,
                                    tmpBoard
                                );

                                if (!wouldBeInCheck) {
                                    moves.push({ x: newX, y: newY });
                                }
                            } else if (isChecked) {
                                // 王以外の駒で、王手がかかっている場合
                                // 一時的に移動させて王手が解消されるかチェック
                                const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                                tmpBoard[newY][newX] = tmpBoard[y][x];
                                tmpBoard[y][x] = null;

                                const kingPos = findKing(piece.owner);
                                const isStillChecked = isPositionUnderAttackWithBoard(
                                    kingPos.x, kingPos.y,
                                    opponentPlayer,
                                    tmpBoard
                                );

                                if (!isStillChecked) {
                                    moves.push({ x: newX, y: newY });
                                }
                            } else {
                                // 王手がかかっていない通常の状態
                                moves.push({ x: newX, y: newY });
                            }

                            // 駒があれば次のマスには移動できない
                            if (targetPiece) {
                                break;
                            }
                        }
                    }
                }

                return moves;
            }

            // 持ち駒を置ける場所を計算
            function calculateDropPositions(pieceType) {
                const positions = [];
                const currentPlayer = gameState.currentTurn;

                // 二歩のチェック用
                const hasPawnInColumn = Array(9).fill(false);
                if (pieceType === '歩') {
                    for (let y = 0; y < 9; y++) {
                        for (let x = 0; x < 9; x++) {
                            const piece = gameState.board[y][x];
                            if (piece && piece.type === '歩' && piece.owner === currentPlayer) {
                                hasPawnInColumn[x] = true;
                            }
                        }
                    }
                }

                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        // 既に駒がある場所には置けない
                        if (gameState.board[y][x]) continue;

                        // 二歩のチェック
                        if (pieceType === '歩' && hasPawnInColumn[x]) continue;

                        // 行き所のない駒のチェック
                        if (pieceType === '歩' || pieceType === '香') {
                            if ((currentPlayer === 'sente' && y === 0) ||
                                (currentPlayer === 'gote' && y === 8)) {
                                continue;
                            }
                        }

                        if (pieceType === '桂') {
                            if ((currentPlayer === 'sente' && y <= 1) ||
                                (currentPlayer === 'gote' && y >= 7)) {
                                continue;
                            }
                        }

                        // 王手回避のチェック
                        const isChecked = currentPlayer === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;
                        if (isChecked) {
                            // 一時的に駒を置いて王手が解消されるかチェック
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[y][x] = { type: pieceType, owner: currentPlayer };

                            const kingPos = findKing(currentPlayer);
                            const isStillChecked = isPositionUnderAttackWithBoard(
                                kingPos.x, kingPos.y,
                                currentPlayer === 'sente' ? 'gote' : 'sente',
                                tmpBoard
                            );

                            if (!isStillChecked) {
                                positions.push({ x, y });
                            }
                        } else {
                            // 打ち歩詰めのチェック（歩を打って相手を詰ませることは反則）
                            if (pieceType === '歩') {
                                const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                                tmpBoard[y][x] = { type: pieceType, owner: currentPlayer };

                                const opponentPlayer = currentPlayer === 'sente' ? 'gote' : 'sente';
                                const opponentKingPos = findKingInBoard(opponentPlayer, tmpBoard);

                                if (opponentKingPos) {
                                    // 歩を打った後、相手の王が王手されているかチェック
                                    const isOpponentInCheck = isPositionUnderAttackWithBoard(
                                        opponentKingPos.x,
                                        opponentKingPos.y,
                                        currentPlayer,
                                        tmpBoard
                                    );

                                    if (isOpponentInCheck) {
                                        // 相手が詰んでいるかチェック
                                        const savedBoard = gameState.board;
                                        const savedTurn = gameState.currentTurn;

                                        gameState.board = tmpBoard;
                                        gameState.currentTurn = opponentPlayer;

                                        const isOpponentCheckmated = isCheckmate();

                                        gameState.board = savedBoard;
                                        gameState.currentTurn = savedTurn;

                                        // 打ち歩詰めの場合はこの位置を除外
                                        if (isOpponentCheckmated) {
                                            continue;
                                        }
                                    }
                                }
                            }

                            positions.push({ x, y });
                        }
                    }
                }

                return positions;
            }

            // 召喚の処理
            function summonPiece() {
                if (gameState.summonPool.length === 0 || gameState.hasSummoned || gameState.gameOver) {
                    // もう一度召喚できない理由をログに出力（デバッグ用）
                    console.log("召喚できない理由:", {
                        "プールが空": gameState.summonPool.length === 0,
                        "すでに召喚済み": gameState.hasSummoned,
                        "ゲーム終了": gameState.gameOver
                    });
                    return;
                }

                // オンライン対戦時は自分のターンのみ操作可能
                if (isOnlineGame && !isMyTurn()) {
                    return;
                }

                // ランダムに一つ選ぶ
                const randomIndex = Math.floor(Math.random() * gameState.summonPool.length);
                const piece = gameState.summonPool[randomIndex];

                // 召喚プールから削除
                gameState.summonPool.splice(randomIndex, 1);

                // 持ち駒に追加
                addPieceToHand(gameState.currentTurn, piece);

                // 召喚済みフラグを立てる
                gameState.hasSummoned = true;
                gameState.mustPlaceLastSummoned = true;
                gameState.lastSummonedPiece = piece;

                // 効果音を再生
                playSound('summon');

                // UIを更新
                renderHands();
                renderSummonPool();
                updateCounters();

                // 召喚情報を更新
                updateSummonInfo(`${piece}を召喚しました！その駒を盤面に打ってください`);

                // 召喚した駒を自動的に選択状態にする
                handleHandPieceClick(piece, gameState.currentTurn);

                // ステータスを更新して次のアクションを促す
                statusElement.textContent = `召喚した${piece}を盤面に打ってください`;
                statusElement.className = 'status';
                statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');

                // パスボタンを無効化（駒を打つ必要があるため）
                passButton.disabled = true;

                // 召喚ボタンの状態を更新
                updateStatus();

                // 移動IDを生成して二重処理を防ぐ
                const moveId = generateMoveId();
                gameState.lastMoveId = moveId;
                gameState.lastProcessedMoveId = moveId;

                // オンライン対戦の場合は状態を同期
                if (isOnlineGame) {
                    syncGameState();
                }
            }

            // ターンを切り替え
            function switchTurn() {
                // 選択をクリア
                gameState.selectedPiece = null;
                gameState.selectedCell = null;
                gameState.possibleMoves = [];

                // ターンを切り替え
                gameState.currentTurn = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
                gameState.hasSummoned = false;
                gameState.mustPlaceLastSummoned = false;
                gameState.lastSummonedPiece = null;

                // タイマーを切り替え
                if (gameState.timeLimit > 0 && isOnlineGame) {
                    gameState.lastTurnChangeTime = Date.now();
                    updateTimerDisplay();
                    if (isMyTurn()) {
                        startTimer();
                    } else {
                        stopTimer();
                    }
                }

                // UI更新
                renderBoard();
                updateStatus();
                renderHands();
                renderSummonPool();
                updateCounters();

                // 召喚情報を更新
                if (gameState.summonPool.length > 0) {
                    updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');
                } else {
                    updateSummonInfo('召喚プールに駒が残っていません。');
                }

                if (isOnlineGame) {
                    syncGameState();
                }

                // ターン表示を更新
                updateTurnIndicator();
            }

            // 初期状態ではゲームを初期化しない（ルール選択後に初期化）
            // initGame();

            // グローバルに公開（画面遷移スクリプトからアクセス用）
            window.gameState = gameState;
            window.pieceTypes = pieceTypes;
            window.createPiece = createPiece;
            window.initGame = initGame;
            window.updateBoardFlipState = updateBoardFlipState;
            window.renderBoard = renderBoard;
            window.renderHands = renderHands;
            window.updateStatus = updateStatus;
            window.updateStatus = updateStatus;
            window.showToast = showToast;

            // 待機オーバーレイの制御
            window.showGameWaitingOverlay = () => {
                const overlay = document.getElementById('game-waiting-overlay');
                if (overlay) overlay.classList.remove('hidden');
            };
            window.hideGameWaitingOverlay = () => {
                const overlay = document.getElementById('game-waiting-overlay');
                if (overlay) overlay.classList.add('hidden');
            };

            // オンラインプレイ用の変数を公開（アクセサー関数）
            window.getIsOnlineGame = () => isOnlineGame;
            window.getPlayerRole = () => playerRole;
            window.setIsOnlineGame = (val) => { isOnlineGame = val; };
            window.setPlayerRole = (val) => { playerRole = val; };
            window.setGameId = (val) => { gameId = val; };
            window.setGameId = (val) => { gameId = val; };
        </script>

        <!-- 対戦相手待機オーバーレイ -->
        <div id="game-waiting-overlay"
            class="hidden absolute top-0 left-0 w-full h-full bg-black bg-opacity-80 flex flex-col items-center justify-center z-50">
            <div class="text-white text-2xl mb-4 font-bold">対戦相手の配置を待っています...</div>
            <div class="spinner"
                style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff; border-radius: 50%; animation: spin 1s linear infinite;">
            </div>
        </div>
    </div> <!-- game-screen の終了タグ -->

    <!-- 画面遷移のスクリプト -->
    <script>
        // 画面遷移の処理
        const titleScreen = document.getElementById('title-screen');
        const ruleSelectionScreen = document.getElementById('rule-selection-screen');
        const playModeScreen = document.getElementById('play-mode-screen');
        const gameScreen = document.getElementById('game-screen');
        const startButton = document.getElementById('start-button');
        const backToTitleButton = document.getElementById('back-to-title');
        const backToTitleFromModeButton = document.getElementById('back-to-title-from-mode');
        const backToTitleGameButton = document.getElementById('back-to-title-game');
        const localPlayBtn = document.getElementById('local-play-btn');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const spectateModeBtn = document.getElementById('spectate-mode-btn');
        const ruleCards = document.querySelectorAll('.rule-card');
        const manualSyncBtn = document.getElementById('manual-sync-btn');


        let selectedRule = null;
        let playMode = null; // 'local', 'online', 'spectate'

        // タイトル画面から プレイモード選択画面へ
        startButton.addEventListener('click', (e) => {
            e.preventDefault();
            titleScreen.classList.add('hidden');
            playModeScreen.classList.remove('hidden');
        });

        // プレイモード選択画面からタイトル画面へ戻る
        if (backToTitleFromModeButton) {
            backToTitleFromModeButton.addEventListener('click', (e) => {
                e.preventDefault();
                playModeScreen.classList.add('hidden');
                titleScreen.classList.remove('hidden');
            });
        }

        // ローカルプレイを選択 → ルール選択画面へ
        if (localPlayBtn) {
            localPlayBtn.addEventListener('click', (e) => {
                e.preventDefault();
                playMode = 'local';
                playModeScreen.classList.add('hidden');
                ruleSelectionScreen.classList.remove('hidden');
            });
        }

        // 部屋を作成を選択 → ルール選択画面へ
        if (createRoomBtn) {
            createRoomBtn.addEventListener('click', (e) => {
                e.preventDefault();
                playMode = 'create';
                playModeScreen.classList.add('hidden');
                ruleSelectionScreen.classList.remove('hidden');
            });
        }

        // 部屋に参加を選択 → ルール選択画面へ
        if (joinRoomBtn) {
            joinRoomBtn.addEventListener('click', (e) => {
                e.preventDefault();
                playMode = 'join';
                playModeScreen.classList.add('hidden');
                ruleSelectionScreen.classList.remove('hidden');
            });
        }

        // 観戦を選択 → ルール選択画面へ
        if (spectateModeBtn) {
            spectateModeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                playMode = 'spectate';
                playModeScreen.classList.add('hidden');
                ruleSelectionScreen.classList.remove('hidden');
            });
        }

        // ルール選択画面からプレイモード選択画面へ戻る
        backToTitleButton.addEventListener('click', (e) => {
            e.preventDefault();
            ruleSelectionScreen.classList.add('hidden');
            playModeScreen.classList.remove('hidden');
        });

        // ゲーム画面からタイトル画面へ戻る
        if (backToTitleGameButton) {
            backToTitleGameButton.addEventListener('click', (e) => {
                e.preventDefault();
                // 確認ダイアログを表示
                if (confirm('タイトル画面に戻りますか？\n進行中のゲームは失われます。')) {
                    gameScreen.classList.remove('active');
                    gameScreen.style.display = 'none';
                    titleScreen.classList.remove('hidden');
                    titleScreen.style.display = 'flex';

                    // ゲーム状態をリセット
                    selectedRule = null;
                }
            });
        } else {
            console.error('back-to-title-game button not found');
        }

        // 手動同期ボタン
        if (manualSyncBtn) {
            manualSyncBtn.addEventListener('click', async () => {
                await forceSync();
            });
        }


        // ルールカードのクリック処理
        ruleCards.forEach(card => {
            card.addEventListener('click', () => {
                const rule = card.dataset.rule;
                const isDisabled = card.classList.contains('disabled');

                if (isDisabled) {
                    showToast('このルールは近日公開予定です', 'info');
                    return;
                }

                selectedRule = rule;
                ruleSelectionScreen.classList.add('hidden');
                gameScreen.classList.add('active');
                gameScreen.style.display = 'block';

                // ルールに応じてゲーム初期化
                function initGameByRule() {
                    if (rule === 'deck') {
                        initDeckGame();
                    } else {
                        window.initGame();
                    }
                }

                // playModeに応じてゲーム初期化とタブ選択
                if (playMode === 'local') {
                    // ローカルプレイ
                    initGameByRule();
                    // 同期ボタンを非表示
                    if (manualSyncBtn) manualSyncBtn.style.display = 'none';
                } else if (playMode === 'create') {
                    // 部屋作成 - まずゲーム画面を初期化してマッチング待機画面を表示
                    window.initGame();
                    showMatchingOverlay(rule);
                    // 同期ボタンを表示
                    if (manualSyncBtn) manualSyncBtn.style.display = 'block';
                } else if (playMode === 'join') {
                    // 部屋参加 - 参加画面を表示
                    window.initGame();
                    showJoinOverlay(rule);
                    // 同期ボタンを表示
                    if (manualSyncBtn) manualSyncBtn.style.display = 'block';
                } else if (playMode === 'spectate') {
                    // 観戦
                    window.initGame();
                    const watchTab = document.querySelector('[data-tab="watch-tab"]');
                    if (watchTab) watchTab.click();
                    window.showToast(`ルール: ${getRuleName(rule)}の対局を観戦`, 'info');
                    // 同期ボタンを表示
                    if (manualSyncBtn) manualSyncBtn.style.display = 'block';
                }
            });
        });

        // ルール名を取得
        function getRuleName(rule) {
            const names = {
                'classic': 'クラシック',
                'deck': 'デッキルール',
                'deluxe': 'デラックス'
            };
            return names[rule] || rule;
        }

        // マッチング待機画面の要素
        const matchingOverlay = document.getElementById('matching-overlay');
        const matchingCodeEl = document.getElementById('matching-code');
        const matchingRuleBadge = document.getElementById('matching-rule-badge');
        const matchingStatusText = document.getElementById('matching-status-text');
        const matchingCopyBtn = document.getElementById('matching-copy-btn');
        const matchingCancelBtn = document.getElementById('matching-cancel-btn');

        let matchingGameId = null;
        let matchingListener = null;

        // マッチング待機画面を表示
        async function showMatchingOverlay(rule) {
            // ルールバッジを更新
            matchingRuleBadge.textContent = getRuleName(rule);
            matchingStatusText.textContent = '対戦相手の参加を待っています...';

            // マッチング画面を表示
            matchingOverlay.classList.add('active');

            try {
                // Firebase認証を確保
                await window.firebase.auth().signInAnonymously();
                const uid = window.firebase.auth().currentUser.uid;

                // ゲームIDを生成
                const code = Math.random().toString(36).substring(2, 8).toUpperCase();
                matchingGameId = code;
                matchingCodeEl.textContent = code;

                // 制限時間を取得（デフォルト0）
                const timeLimit = 0;

                // Firebaseにゲームを作成
                const gameRef = window.firebase.database().ref(`games/${code}`);
                await gameRef.set({
                    code,
                    createdAt: Date.now(),
                    status: { phase: 'waiting', turn: 'sente' },
                    players: {
                        [uid]: { role: 'sente', nickname: localStorage.getItem('userNickname') || '先手', online: true, joinedAt: Date.now() }
                    },
                    roles: { sente: uid, gote: null },
                    timeLimit,
                    rule: rule,
                    placement: {
                        sente: { completed: false, pieces: [] },
                        gote: { completed: false, pieces: [] }
                    }
                });

                // 公開リストに追加
                await window.firebase.database().ref(`publicGames/${code}`).set({
                    code,
                    host: localStorage.getItem('userNickname') || '先手',
                    createdAt: Date.now(),
                    status: 'waiting',
                    rule: rule
                });

                // 相手の参加を監視
                matchingListener = gameRef.child('roles/gote').on('value', async (snapshot) => {
                    const goteUid = snapshot.val();
                    if (goteUid) {
                        // 相手が参加した！
                        matchingStatusText.textContent = '対戦相手が見つかりました！';

                        // 少し待ってから配置フェーズへ
                        setTimeout(() => {
                            hideMatchingOverlay();

                            // グローバル変数を設定
                            window.setGameId(matchingGameId);
                            window.setIsOnlineGame(true);
                            window.setPlayerRole('sente'); // 作成者は先手

                            // デッキルールの場合は配置フェーズへ
                            if (rule === 'deck') {
                                initDeckGame();
                            } else {
                                window.initGame();
                            }

                            // ゲーム状態をオンラインに設定（メインスクリプトの変数を更新できないので、window経由で同期）
                            window.showToast('対戦相手が見つかりました！ゲーム開始！', 'success');
                        }, 1000);
                    }
                });

            } catch (error) {
                console.error('マッチング作成エラー:', error);
                window.showToast('部屋の作成に失敗しました', 'error');
                hideMatchingOverlay();
            }
        }

        // マッチング待機画面を閉じる
        function hideMatchingOverlay() {
            matchingOverlay.classList.remove('active');
            if (matchingListener && matchingGameId) {
                window.firebase.database().ref(`games/${matchingGameId}/roles/gote`).off('value', matchingListener);
                matchingListener = null;
            }
        }

        // コードをコピー
        if (matchingCopyBtn) {
            matchingCopyBtn.addEventListener('click', () => {
                navigator.clipboard.writeText(matchingCodeEl.textContent);
                window.showToast('コードをコピーしました！', 'success');
            });
        }

        // キャンセル
        if (matchingCancelBtn) {
            matchingCancelBtn.addEventListener('click', async () => {
                if (matchingGameId) {
                    // Firebaseからゲームを削除
                    try {
                        await window.firebase.database().ref(`games/${matchingGameId}`).remove();
                        await window.firebase.database().ref(`publicGames/${matchingGameId}`).remove();
                    } catch (e) {
                        console.error('ゲーム削除エラー:', e);
                    }
                }
                hideMatchingOverlay();
                // タイトル画面に戻る
                gameScreen.classList.remove('active');
                gameScreen.style.display = 'none';
                playModeScreen.classList.remove('hidden');
            });
        }

        // ========== 部屋参加画面 ==========
        const joinOverlay = document.getElementById('join-overlay');
        const joinRuleBadge = document.getElementById('join-rule-badge');
        const joinCodeInput = document.getElementById('join-code-input');
        const joinSubmitBtn = document.getElementById('join-room-submit-btn');
        const joinCancelBtn = document.getElementById('join-cancel-btn');

        let joinSelectedRule = null;

        // 部屋参加画面を表示
        function showJoinOverlay(rule) {
            joinSelectedRule = rule;
            joinRuleBadge.textContent = getRuleName(rule);
            joinCodeInput.value = '';
            joinOverlay.classList.add('active');
        }

        // 部屋参加画面を閉じる
        function hideJoinOverlay() {
            joinOverlay.classList.remove('active');
        }

        // 参加ボタン
        if (joinSubmitBtn) {
            joinSubmitBtn.addEventListener('click', async () => {
                const code = joinCodeInput.value.trim().toUpperCase();
                if (!code || code.length < 4) {
                    window.showToast('招待コードを入力してください', 'error');
                    return;
                }

                try {
                    // Firebase認証
                    await window.firebase.auth().signInAnonymously();
                    const uid = window.firebase.auth().currentUser.uid;

                    // 部屋を検索
                    const gameRef = window.firebase.database().ref(`games/${code}`);
                    const snapshot = await gameRef.once('value');

                    if (!snapshot.exists()) {
                        window.showToast('この招待コードの部屋は見つかりません', 'error');
                        return;
                    }

                    const gameData = snapshot.val();

                    // ルールチェック
                    const roomRule = gameData.rule || 'classic';
                    if (roomRule !== joinSelectedRule) {
                        const ruleNames = { classic: 'クラシック', deck: 'デッキルール', deluxe: 'デラックス' };
                        window.showToast(`この部屋は「${ruleNames[roomRule]}」モードです`, 'error');
                        return;
                    }

                    // 既に満員でないか確認
                    if (gameData.roles && gameData.roles.gote) {
                        window.showToast('この部屋は既に満員です', 'error');
                        return;
                    }

                    // 部屋に参加
                    const now = Date.now();
                    await gameRef.child('roles/gote').set(uid);
                    await gameRef.child(`players/${uid}`).set({
                        role: 'gote',
                        nickname: localStorage.getItem('userNickname') || '後手',
                        online: true,
                        joinedAt: now
                    });

                    // 参加成功
                    hideJoinOverlay();
                    window.showToast('部屋に参加しました！', 'success');

                    // グローバル変数を設定
                    window.setGameId(code);
                    window.setIsOnlineGame(true);
                    window.setPlayerRole('gote'); // 参加者は後手

                    // デッキルールの場合は配置フェーズへ
                    if (joinSelectedRule === 'deck') {
                        initDeckGame();
                    } else {
                        window.initGame();
                    }

                } catch (error) {
                    console.error('部屋参加エラー:', error);
                    window.showToast('部屋への参加に失敗しました', 'error');
                }
            });
        }

        // 参加キャンセル
        if (joinCancelBtn) {
            joinCancelBtn.addEventListener('click', () => {
                hideJoinOverlay();
                gameScreen.classList.remove('active');
                gameScreen.style.display = 'none';
                playModeScreen.classList.remove('hidden');
            });
        }

        // ========== デッキルール用の変数と関数 ==========

        // 駒のコスト
        const pieceCosts = {
            '歩': 1, '香': 3, '桂': 3,
            '銀': 5, '金': 6, '角': 8, '飛': 10
        };

        // 配置フェーズの状態
        let placementState = {
            active: false,
            hand: [],           // 配置する駒の配列
            placedPieces: [],   // 配置済みの駒 [{piece, x, y}, ...]
            selectedPiece: null,// 選択中の駒インデックス
            timer: 60,
            timerInterval: null,
            playerSide: 'sente' // ローカルプレイ用
        };

        // 配置フェーズの要素
        const placementOverlay = document.getElementById('placement-phase-overlay');
        const placementHandEl = document.getElementById('placement-hand');
        const placementTimerEl = document.getElementById('placement-timer-value');
        const placementCompleteBtn = document.getElementById('placement-complete-btn');
        const placementWaiting = document.getElementById('placement-waiting');

        // デッキルール用のゲーム初期化
        function initDeckGame() {
            const gameState = window.gameState;
            const pieceTypes = window.pieceTypes;
            const createPiece = window.createPiece;

            // ボードをクリア
            gameState.board = Array(9).fill().map(() => Array(9).fill(null));
            gameState.senteHand = [];
            gameState.goteHand = [];
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];
            gameState.currentTurn = 'sente';
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false;
            gameState.lastSummonedPiece = null;
            gameState.gameOver = false;
            gameState.winner = null;
            gameState.inCheck = { sente: false, gote: false };
            gameState.lastMove = null;
            gameState.pendingPromotion = null;
            gameState.summonPool = [];

            // 召喚プールを初期化（デッキルール用）
            for (const [piece, info] of Object.entries(pieceTypes)) {
                for (let i = 0; i < info.count; i++) {
                    gameState.summonPool.push(piece);
                }
            }

            // 王将と玉将を初期配置
            gameState.board[8][4] = createPiece('王', 'sente');
            gameState.board[0][4] = createPiece('玉', 'gote');

            // UIを更新
            window.updateBoardFlipState();
            window.renderBoard();
            window.renderHands();
            window.updateStatus();

            // オンラインプレイかどうかを確認
            const isOnline = window.getIsOnlineGame ? window.getIsOnlineGame() : false;
            const myRole = window.getPlayerRole ? window.getPlayerRole() : null;

            if (isOnline && myRole) {
                // オンラインプレイ: 自分のロールの配置のみ開始
                startPlacementPhase(myRole);
            } else {
                // ローカルプレイ: 先手から開始
                startPlacementPhase('sente');
            }
        }

        // ランダムに駒を引く
        function drawRandomPieces(count) {
            const gameState = window.gameState;
            const drawn = [];
            const pool = [...gameState.summonPool];

            for (let i = 0; i < count && pool.length > 0; i++) {
                const index = Math.floor(Math.random() * pool.length);
                drawn.push(pool.splice(index, 1)[0]);
            }

            // 召喚プールから引いた駒を削除
            for (const piece of drawn) {
                const idx = gameState.summonPool.indexOf(piece);
                if (idx !== -1) {
                    gameState.summonPool.splice(idx, 1);
                }
            }

            return drawn;
        }

        // 配置フェーズを開始
        function startPlacementPhase(side) {
            placementState.active = true;
            placementState.playerSide = side;
            placementState.placedPieces = [];
            placementState.selectedPiece = null;
            placementState.timer = 60;

            // オーバーレイを表示
            if (placementOverlay) {
                placementOverlay.classList.add('active');
                placementOverlay.style.display = 'flex';
            }

            // プレイヤー交代確認画面を表示
            showPlayerSwitchScreen(side);

            // インラインプレイの場合は確認画面をスキップ
            if (window.getIsOnlineGame && window.getIsOnlineGame()) {
                setTimeout(() => {
                    const readyBtn = document.getElementById('player-ready-btn');
                    if (readyBtn) readyBtn.click();
                }, 100);
            }
        }

        // プレイヤー交代確認画面を表示
        function showPlayerSwitchScreen(side) {
            const switchScreen = document.getElementById('player-switch-screen');
            const switchPlayerName = document.getElementById('switch-player-name');
            const switchMessage = document.getElementById('switch-message');
            const playerReadyBtn = document.getElementById('player-ready-btn');
            const placementHeader = document.querySelector('.placement-header');
            const placementHandArea = document.querySelector('.placement-hand-area');
            const placementBoardContainer = document.getElementById('placement-board-container');
            const placementCompleteBtnEl = document.getElementById('placement-complete-btn');
            const placementInfoEl = document.querySelector('.placement-info');

            // 配置UI要素を隠す
            if (placementHeader) placementHeader.style.display = 'none';
            if (placementHandArea) placementHandArea.style.display = 'none';
            if (placementBoardContainer) placementBoardContainer.style.display = 'none';
            if (placementCompleteBtnEl) placementCompleteBtnEl.style.display = 'none';
            if (placementInfoEl) placementInfoEl.style.display = 'none';

            // 交代確認画面を設定
            const playerName = side === 'sente' ? '先手' : '後手';
            const opponentName = side === 'sente' ? '後手' : '先手';

            switchPlayerName.textContent = `${opponentName}さん`;
            switchMessage.textContent = `${playerName}の番です。${playerName}プレイヤーは「準備OK」を押してください。`;

            // 交代確認画面を表示
            if (switchScreen) {
                switchScreen.style.display = 'block';
            }

            // 準備OKボタンのイベント
            playerReadyBtn.onclick = () => {
                // 交代確認画面を隠す
                switchScreen.style.display = 'none';

                // 配置UI要素を表示
                if (placementHeader) placementHeader.style.display = 'flex';
                if (placementHandArea) placementHandArea.style.display = 'block';
                if (placementBoardContainer) placementBoardContainer.style.display = 'block';
                if (placementCompleteBtnEl) placementCompleteBtnEl.style.display = 'block';
                if (placementInfoEl) placementInfoEl.style.display = 'block';

                // タイトルを更新
                const placementTitle = document.getElementById('placement-title');
                if (placementTitle) {
                    placementTitle.textContent = `${playerName}の配置フェーズ`;
                }

                // 駒を引いて配置フェーズを本格開始
                // 駒を引いて配置フェーズを本格開始
                placementState.hand = drawRandomPieces(3);
                placementWaiting.classList.remove('active');

                // 手札を描画
                renderPlacementHand();

                // 盤面を描画（配置モード）
                renderPlacementBoard();

                // タイマー開始
                startPlacementTimer();
            };
        }

        // 配置用の手札を描画
        function renderPlacementHand() {
            placementHandEl.innerHTML = '';

            placementState.hand.forEach((piece, index) => {
                const pieceEl = document.createElement('div');
                pieceEl.className = 'placement-piece';

                // 配置済みかチェック
                const isPlaced = placementState.placedPieces.some(p => p.handIndex === index);
                if (isPlaced) {
                    pieceEl.classList.add('placed');
                }

                // 選択中かチェック
                if (placementState.selectedPiece === index && !isPlaced) {
                    pieceEl.classList.add('selected');
                }

                pieceEl.textContent = piece;

                if (!isPlaced) {
                    pieceEl.addEventListener('click', () => {
                        placementState.selectedPiece = index;
                        renderPlacementHand();
                        renderPlacementBoard();
                    });
                }

                placementHandEl.appendChild(pieceEl);
            });
        }

        // 配置用の盤面を描画
        function renderPlacementBoard() {
            const gameState = window.gameState;
            const boardContainer = document.getElementById('placement-board-container');
            if (!boardContainer) {
                console.error('placement-board-container not found');
                return;
            }

            // コンテナをクリアして新しい盤面を作成
            boardContainer.innerHTML = '';

            // 盤面要素を作成
            const boardEl = document.createElement('div');
            boardEl.className = 'board';
            boardEl.id = 'placement-board';
            boardEl.style.cssText = 'display: grid; grid-template-columns: repeat(9, 1fr); gap: 1px; background: #000; width: 360px; height: 360px;';

            const side = placementState.playerSide;
            const validRows = side === 'sente' ? [6, 7, 8] : [0, 1, 2]; // 自陣3行

            // オンラインの後手なら盤面を反転して表示
            const isOnline = window.getIsOnlineGame ? window.getIsOnlineGame() : false;
            const shouldFlip = isOnline && side === 'gote';

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    // 表示用座標から論理座標へ変換
                    const y = shouldFlip ? 8 - row : row;
                    const x = shouldFlip ? 8 - col : col;

                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.style.cssText = 'background: #DEB887; display: flex; justify-content: center; align-items: center; cursor: pointer;';

                    // 駒があれば表示
                    const piece = gameState.board[y][x];
                    if (piece && piece.type) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.owner}`;
                        pieceElement.style.cssText = 'font-size: 1.5em; font-weight: bold;';

                        // 駒の向き
                        if (shouldFlip) {
                            // 反転表示時：相手（先手）の駒を逆さまに
                            if (piece.owner === 'sente') {
                                pieceElement.style.transform = 'rotate(180deg)';
                            }
                        } else {
                            // 通常表示時：相手（後手）の駒を逆さまに
                            if (piece.owner === 'gote') {
                                pieceElement.style.transform = 'rotate(180deg)';
                            }
                        }

                        pieceElement.textContent = piece.type;
                        cell.appendChild(pieceElement);
                    }

                    // 配置可能なセルをハイライト
                    if (placementState.selectedPiece !== null &&
                        validRows.includes(y) &&
                        !gameState.board[y][x]) {

                        const selectedPieceType = placementState.hand[placementState.selectedPiece];

                        // 二歩チェック
                        if (selectedPieceType === '歩') {
                            const hasPawnInColumn = checkPawnInColumn(x, side);
                            if (!hasPawnInColumn) {
                                cell.classList.add('placement-valid');
                                cell.style.background = 'rgba(50, 255, 50, 0.5)';
                            }
                        } else {
                            cell.classList.add('placement-valid');
                            cell.style.background = 'rgba(50, 255, 50, 0.5)';
                        }
                    }

                    // クリックイベント
                    cell.addEventListener('click', () => {
                        handlePlacementCellClick(x, y);
                    });

                    boardEl.appendChild(cell);
                }
            }

            // 盤面をコンテナに追加
            boardContainer.appendChild(boardEl);
        }

        // 列に歩があるかチェック（二歩チェック）
        function checkPawnInColumn(col, owner) {
            const gameState = window.gameState;
            for (let y = 0; y < 9; y++) {
                const piece = gameState.board[y][col];
                if (piece && piece.type === '歩' && piece.owner === owner) {
                    return true;
                }
            }
            return false;
        }

        // 配置セルクリック処理
        function handlePlacementCellClick(x, y) {
            const gameState = window.gameState;
            const createPiece = window.createPiece;
            const showToast = window.showToast;

            if (placementState.selectedPiece === null) return;

            const side = placementState.playerSide;
            const validRows = side === 'sente' ? [6, 7, 8] : [0, 1, 2];

            // 有効な配置位置かチェック
            if (!validRows.includes(y)) {
                showToast('自陣3行以内に配置してください', 'warn');
                return;
            }

            // すでに駒があるかチェック
            if (gameState.board[y][x]) {
                showToast('そこにはすでに駒があります', 'warn');
                return;
            }

            const selectedPieceType = placementState.hand[placementState.selectedPiece];

            // 二歩チェック
            if (selectedPieceType === '歩' && checkPawnInColumn(x, side)) {
                showToast('二歩は禁止です', 'warn');
                return;
            }

            // 駒を配置
            gameState.board[y][x] = createPiece(selectedPieceType, side);

            // 配置済みに追加
            placementState.placedPieces.push({
                handIndex: placementState.selectedPiece,
                piece: selectedPieceType,
                x: x,
                y: y
            });

            // 選択をクリア
            placementState.selectedPiece = null;

            // 再描画
            renderPlacementHand();
            renderPlacementBoard();
            renderBoard();
        }

        // 配置タイマー開始
        function startPlacementTimer() {
            const timerContainer = document.querySelector('.placement-timer');

            placementState.timerInterval = setInterval(() => {
                placementState.timer--;
                placementTimerEl.textContent = placementState.timer;

                if (placementState.timer <= 10) {
                    timerContainer.classList.add('warning');
                }

                if (placementState.timer <= 0) {
                    // タイムアウト - 配置完了として処理
                    completePlacement();
                }
            }, 1000);
        }

        // 配置タイマー停止
        function stopPlacementTimer() {
            if (placementState.timerInterval) {
                clearInterval(placementState.timerInterval);
                placementState.timerInterval = null;
            }
        }

        // 配置完了
        function completePlacement() {
            const showToast = window.showToast;
            stopPlacementTimer();

            // オンラインプレイかどうかを確認
            const isOnline = window.getIsOnlineGame ? window.getIsOnlineGame() : false;

            if (isOnline) {
                const myRole = window.getPlayerRole();
                // gameIdはクロージャ内の変数を使用（setGameIdで更新されているはず）
                if (!gameId) {
                    console.error('Game ID not found in completePlacement');
                    showToast('エラー：ゲームIDが見つかりません', 'error');
                    return;
                }

                // 配置データを整形
                const placedPiecesData = placementState.placedPieces.map(p => ({
                    type: p.piece, // p.pieceは文字列（駒の種類）
                    owner: myRole, // roleは現在のプレイヤー
                    x: p.x,
                    y: p.y
                }));

                // Firebaseに配置完了を通知
                window.firebase.database().ref(`games/${gameId}/placement/${myRole}`).set({
                    completed: true,
                    pieces: placedPiecesData
                })
                    .then(() => {
                        showToast('配置が完了しました！相手を待っています...', 'success');
                        // 待機画面へ遷移
                        navigateToGameWaiting();
                        waitForOpponentPlacement(gameId);
                    })
                    .catch(err => {
                        console.error('Firebase update error:', err);
                        showToast('送信に失敗しました', 'error');
                    });
            } else {
                // ローカルプレイの場合は先手と後手を順番に
                if (placementState.playerSide === 'sente') {
                    // 先手の配置が完了、後手の配置へ
                    showToast('先手の配置が完了しました。後手の配置を開始します。', 'success');
                    startPlacementPhase('gote');
                } else {
                    // 両者の配置が完了、ゲームスタート画面を表示
                    // ローカルプレイではplacementState.placedPiecesに全ての駒があるわけではない？
                    // startPlacementPhase('gote')のときにboardはクリアされている？
                    // ローカルプレイのロジックを確認する必要があるが、とりあえず既存のshowGameStartScreenを呼ぶ
                    // （ただしローカルプレイの統合ロジックが未実装なら修正が必要）

                    // ローカルプレイの仕様：
                    // sente配置 -> boardに反映 -> boardクリア -> gote配置 -> board反映 -> マージ？
                    // 現状のstartPlacementPhaseはboardをクリアしていないかもしれない。
                    // 既存ロジックを維持するなら showGameStartScreen() でよい。
                    showGameStartScreen();
                }
            }
        }

        // 相手の配置待ち画面へ遷移（ゲーム画面＋待機オーバーレイ）
        function navigateToGameWaiting() {
            const placementOverlay = document.getElementById('placement-phase-overlay');
            const waitingOverlay = document.getElementById('game-waiting-overlay');

            // 配置オーバーレイを隠す
            if (placementOverlay) {
                placementOverlay.classList.remove('active');
                placementOverlay.style.display = 'none';
            }
            // 待機オーバーレイを表示
            if (waitingOverlay) waitingOverlay.classList.remove('hidden');

            // 自分の駒を仮表示（gameState.boardに反映）
            // 自分の駒を仮表示（gameState.boardに反映）
            gameState.board = Array(9).fill(null).map(() => Array(9).fill(null));

            // 王将と玉将を再配置（ボードクリアで消えるため）
            gameState.board[8][4] = window.createPiece('王', 'sente');
            gameState.board[0][4] = window.createPiece('玉', 'gote');

            // placementStateの駒を反映
            placementState.placedPieces.forEach(p => {
                // createPieceを使用
                gameState.board[p.y][p.x] = createPiece(p.piece, placementState.playerSide); // p.pieceは文字列型
            });

            // 盤面を描画
            renderBoard();
        }

        // 相手の配置完了を監視
        function waitForOpponentPlacement(gid) {
            const placementRef = window.firebase.database().ref(`games/${gid}/placement`);
            placementRef.on('value', (snapshot) => {
                const placement = snapshot.val();
                if (placement && placement.sente && placement.sente.completed && placement.gote && placement.gote.completed) {
                    // 両者完了
                    placementRef.off();
                    startGameFromPlacementData(placement);
                }
            });
        }

        // 配置データからゲームを開始
        function startGameFromPlacementData(placement) {
            // 盤面をクリア
            gameState.board = Array(9).fill(null).map(() => Array(9).fill(null));

            // 王将と玉将を再配置（ボードクリアで消えるため）
            gameState.board[8][4] = window.createPiece('王', 'sente');
            gameState.board[0][4] = window.createPiece('玉', 'gote');
            // 手持ち駒もクリア
            gameState.senteHand = [];
            gameState.goteHand = [];

            // 駒を配置
            // 先手の駒
            if (placement.sente && placement.sente.pieces) {
                placement.sente.pieces.forEach(p => {
                    // 既存のcreatePieceを使用
                    gameState.board[p.y][p.x] = createPiece(p.type, 'sente');
                });
            }
            // 後手の駒
            if (placement.gote && placement.gote.pieces) {
                placement.gote.pieces.forEach(p => {
                    gameState.board[p.y][p.x] = createPiece(p.type, 'gote');
                });
            }

            // 待機表示を消す
            const waitingOverlay = document.getElementById('game-waiting-overlay');
            if (waitingOverlay) waitingOverlay.classList.add('hidden');

            // 盤面を描画（相手の駒も表示）
            renderBoard();
            renderHands();
            updateStatus();

            showToast('両者の配置が完了しました！', 'success');
            showGameStartScreen();
        }

        // ゲームスタート画面を表示
        function showGameStartScreen() {
            const gameState = window.gameState;

            // 配置UI要素を隠す
            document.querySelector('.placement-header').style.display = 'none';
            document.querySelector('.placement-hand-area').style.display = 'none';
            document.getElementById('placement-board-container').style.display = 'none';
            document.getElementById('placement-complete-btn').style.display = 'none';
            document.querySelector('.placement-info').style.display = 'none';

            // コスト計算
            const senteCost = calculateTotalCost('sente');
            const goteCost = calculateTotalCost('gote');

            // コスト表示を更新
            document.getElementById('sente-cost').textContent = senteCost;
            document.getElementById('gote-cost').textContent = goteCost;

            // 先攻を決定
            const firstPlayer = senteCost <= goteCost ? 'sente' : 'gote';
            const firstPlayerName = firstPlayer === 'sente' ? '先手' : '後手';
            document.getElementById('first-player-msg').textContent = `${firstPlayerName}が先攻です！`;

            // gameStateに保存
            gameState.currentTurn = firstPlayer;

            // ゲームスタート画面を表示
            document.getElementById('game-start-ready').style.display = 'block';
        }

        // 配置フェーズ終了、ゲーム開始
        function finishPlacementPhase() {
            const gameState = window.gameState;
            const showToast = window.showToast;

            console.log('finishPlacementPhase called');

            placementState.active = false;

            // オーバーレイを完全に閉じる
            placementOverlay.classList.remove('active');
            placementOverlay.style.display = 'none';

            // 先攻後攻はすでにshowGameStartScreenで設定済み
            const firstPlayer = gameState.currentTurn === 'sente' ? '先手' : '後手';
            showToast(`${firstPlayer}の番です！ゲームスタート！`, 'success');

            // UIを更新
            window.renderBoard();
            window.renderHands();
            window.updateStatus();

            console.log('Game started, current turn:', gameState.currentTurn);
        }

        // 配置した駒のコスト合計を計算
        function calculateTotalCost(owner) {
            const gameState = window.gameState;
            let total = 0;
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = gameState.board[y][x];
                    if (piece && piece.owner === owner && pieceCosts[piece.type]) {
                        total += pieceCosts[piece.type];
                    }
                }
            }
            return total;
        }

        // 配置完了ボタン
        placementCompleteBtn.addEventListener('click', (e) => {
            e.preventDefault();
            completePlacement();
        });

        // ゲームスタートボタン
        const gameStartBtn = document.getElementById('game-start-btn');
        if (gameStartBtn) {
            gameStartBtn.addEventListener('click', (e) => {
                e.preventDefault();
                finishPlacementPhase();
            });
        }
    </script>

</body>

</html>
