<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オンライン対戦対応 召喚将棋 (改良版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@600&display=swap');

        :root {
            --board-bg: #E8C99B;
            --board-border: #8B4513;
            --cell-bg: #F0D9B5;
            --cell-hover: #FFE4B5;
            --highlight: #FFFF99;
            --highlight-move: rgba(50, 255, 50, 0.4);
            --highlight-attack: rgba(255, 50, 50, 0.4);
            --main-bg: #F5F5DC;
            --text-color: #333;
            --button-primary: #8B4513;
            --button-hover: #A0522D;
            --button-disabled: #cccccc;
            --sente-color: #000;
            --gote-color: #000;
            --header-bg: #8B4513;
            --header-text: #FFF;
            --promotion-bg: rgba(0, 0, 0, 0.7);
            --chat-bg: #fff;
            --chat-border: #ddd;
            --chat-message-sent: #e1f5fe;
            --chat-message-received: #f5f5f5;
            --piece-sente-bg: #f9e0a2;
            --piece-sente-border: #c19a6b;
            --piece-gote-bg: #f0f0f0;
            --piece-gote-border: #bbbbbb;
            --piece-shadow: rgba(0, 0, 0, 0.3);
            --modal-bg: rgba(0, 0, 0, 0.7);
            --game-list-hover: #f0f0f0;
            --game-list-active: #e6f7ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--main-bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            position: relative;
        }

        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            width: 100%;
            padding: 15px 20px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8rem;
            margin: 0;
        }

        .user-info {
            display: flex;
            align-items: center;
            margin-top: 10px;
            color: white;
            font-size: 0.9em;
        }

        .user-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
            color: #333;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }

        .board-area {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            overflow: auto;
            padding-bottom: 120px;
        }

        .board-toolbar {
            display: flex;
            justify-content: flex-end;
            width: 100%;
            margin-bottom: 6px;
            gap: 8px;
        }

        .board-toggle-button {
            background-color: var(--button-primary);
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.85em;
            cursor: pointer;
            transition: background-color 0.2s;
            flex: none;
        }

        .board-toggle-button:hover {
            background-color: var(--button-hover);
        }

        #chat-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: flex-end;
            padding: 40px;
            box-sizing: border-box;
            z-index: 9999;
        }

        #chat-overlay.active {
            display: flex;
        }

        body.chat-overlay-active {
            overflow: hidden;
        }

        .chat-panel {
            position: relative;
            width: min(420px, 90vw);
            max-height: 90vh;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.35);
            padding: 24px 24px 18px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            pointer-events: auto;
        }

        #result-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }

        #result-overlay.active {
            display: flex;
        }

        body.result-overlay-active {
            overflow: hidden;
        }

        .result-panel {
            background: radial-gradient(circle at top, rgba(255, 255, 255, 0.98), rgba(245, 245, 245, 0.95));
            border-radius: 20px;
            padding: 48px 56px;
            text-align: center;
            box-shadow: 0 40px 80px rgba(0, 0, 0, 0.4);
            max-width: 520px;
            width: 90vw;
            transform: scale(0.85);
            opacity: 0;
            animation: result-pop-in 0.4s ease-out forwards;
        }

        #result-title {
            font-size: 3rem;
            margin-bottom: 12px;
            font-family: 'Noto Serif JP', serif;
            letter-spacing: 0.2em;
        }

        #result-subtitle {
            font-size: 1.1rem;
            color: #555;
            margin-bottom: 28px;
        }

        .result-buttons {
            display: flex;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .result-button {
            min-width: 140px;
            padding: 12px 18px;
            border-radius: 999px;
            border: none;
            font-weight: bold;
            background: var(--button-primary);
            color: #fff;
            cursor: pointer;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            flex: none;
        }

        .result-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
            background: var(--button-hover);
        }

        .result-button:active {
            transform: translateY(1px);
        }

        @keyframes result-pop-in {
            0% {
                opacity: 0;
                transform: scale(0.85);
            }

            60% {
                opacity: 1;
                transform: scale(1.05);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
            pointer-events: none;
        }

        .toast {
            min-width: 240px;
            max-width: 420px;
            padding: 12px 18px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-weight: bold;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .toast-info {
            background: rgba(33, 150, 243, 0.9);
        }

        .toast-success {
            background: rgba(46, 204, 113, 0.9);
        }

        .toast-warn {
            background: rgba(241, 196, 15, 0.92);
            color: #4a3600;
        }

        .toast-error {
            background: rgba(231, 76, 60, 0.92);
        }

        .chat-close-button {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: none;
            color: #444;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease, transform 0.2s ease;
            flex: none;
        }

        .chat-close-button:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .chat-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #summon-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #e60000;
            color: #fff;
            font-size: 1.1em;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: upright;
            letter-spacing: 0.2em;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(230, 0, 0, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            padding: 0;
            flex: none;
            z-index: 5;
        }

        #summon-button:hover:not(:disabled),
        #summon-button:focus-visible:not(:disabled) {
            background-color: #e60000;
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 14px 30px rgba(230, 0, 0, 0.45);
        }

        #summon-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: translateX(-50%);
            box-shadow: none;
            background-color: #e60000;
        }

        #summon-button:active:not(:disabled) {
            transform: translateX(-50%) scale(0.96);
        }

        .coordinates {
            display: flex;
            justify-content: space-around;
            width: 450px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .row-coordinates {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 450px;
            font-weight: bold;
            margin-right: 5px;
        }

        .board-with-coords {
            display: flex;
            align-items: center;
        }

        .board {
            width: 450px;
            height: 450px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            background-color: var(--board-border);
            padding: 2px;
            border: 5px solid var(--board-border);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .board::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23E8C99B" fill-opacity="0.5"/><path d="M0,20 L100,20 M0,40 L100,40 M0,60 L100,60 M0,80 L100,80 M20,0 L20,100 M40,0 L40,100 M60,0 L60,100 M80,0 L80,100" stroke="%238B4513" stroke-width="0.5" stroke-opacity="0.3"/></svg>');
            background-size: 50px 50px;
            opacity: 0.5;
            z-index: 0;
            pointer-events: none;
        }

        .cell {
            background-color: var(--cell-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .cell:hover {
            background-color: var(--cell-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .cell.highlighted {
            background-color: var(--highlight);
        }

        .cell.highlight-move {
            background-color: var(--highlight-move);
        }

        .cell.highlight-attack {
            background-color: var(--highlight-attack);
        }

        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5em;
            font-weight: bold;
            user-select: none;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 2;
            --piece-rotation: 0deg;
            transform: rotate(var(--piece-rotation));

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            --piece-rotation: 0deg;
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            --piece-rotation: 180deg;
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        body.board-flipped .piece.sente {
            --piece-rotation: 180deg;
        }

        body.board-flipped .piece.gote {
            --piece-rotation: 0deg;
        }

        .piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .piece.selected {
            box-shadow: 0 0 0 3px #ff0, 0 4px 6px var(--piece-shadow);
            transform: rotate(var(--piece-rotation)) scale(1.1);
        }

        .piece.animated {
            animation: pop-in 0.3s ease-out forwards;
        }

        @keyframes pop-in {
            0% {
                transform: rotate(var(--piece-rotation)) scale(0.5);
                opacity: 0;
            }

            70% {
                transform: rotate(var(--piece-rotation)) scale(1.1);
            }

            100% {
                transform: rotate(var(--piece-rotation)) scale(1);
                opacity: 1;
            }
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 450px;
        }

        .status-panel {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            background-color: #f0f0f0;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status.sente-turn {
            background-color: #ffe6e6;
        }

        .status.gote-turn {
            background-color: #e6f0ff;
        }

        .status.check {
            background-color: #ffcccc;
            animation: pulse 1.5s infinite;
        }

        .status.gameover {
            background-color: #ffcc00;
            font-size: 1.2em;
            padding: 15px;
            animation: victory-pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes victory-pulse {
            0% {
                transform: scale(1);
                background-color: #ffcc00;
            }

            50% {
                transform: scale(1.05);
                background-color: #ffd700;
            }

            100% {
                transform: scale(1);
                background-color: #ffcc00;
            }
        }

        .hand-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .hand-title {
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hand-title span {
            font-size: 0.9em;
            color: #777;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 60px;
        }

        .hand-piece {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-weight: bold;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;
            --hand-rotation: 0deg;
            transform: rotate(var(--hand-rotation));

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .hand-piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            --hand-rotation: 0deg;
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        .hand-piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            --hand-rotation: 180deg;
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        body.board-flipped .hand-piece.sente {
            --hand-rotation: 180deg;
        }

        body.board-flipped .hand-piece.gote {
            --hand-rotation: 0deg;
        }

        .hand-piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .hand-piece:hover {
            background-color: var(--highlight);
            transform: rotate(var(--hand-rotation)) scale(1.05);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .hand-piece.gote:hover {
            transform: translateY(-2px) rotate(180deg);
        }

        .summon-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .summon-title {
            margin-bottom: 10px;
            font-weight: bold;
        }

        .summon-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
            margin-bottom: 10px;
        }

        .summon-piece {
            padding: 5px 8px;
            background-color: #f0d9b5;
            border: 1px solid #c19a6b;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 12px;
            background-color: var(--button-primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.2s ease;
            flex: 1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .rules-container {
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .rules-toggle {
            cursor: pointer;
            color: var(--button-primary);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .rules-toggle::after {
            content: "▼";
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .rules-toggle.open::after {
            transform: rotate(180deg);
        }

        .rules-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .rules-content.show {
            max-height: 800px;
        }

        .rules-content ul,
        .rules-content ol {
            padding-left: 20px;
            margin: 10px 0;
        }

        .rules-content li {
            margin-bottom: 8px;
        }

        .piece-movement {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .move-diagram {
            text-align: center;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 90px;
            height: 90px;
            margin: 0 auto 5px;
        }

        .move-cell {
            width: 30px;
            height: 30px;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
        }

        .move-cell.can-move {
            background-color: var(--highlight);
        }

        .move-cell.piece {
            background-color: #ffedcc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* プロモーションダイアログ */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--promotion-bg);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 300px;
            width: 100%;
        }

        .promotion-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .promotion-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .promotion-option {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8em;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .promotion-option:nth-child(1) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option:nth-child(2) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .promotion-option:hover {
            background-color: var(--highlight);
            transform: scale(1.1);
        }

        /* オンライン対戦用スタイル */
        .online-controls {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            width: 100%;
            max-width: 450px;
        }

        .online-controls h3 {
            margin-bottom: 15px;
            text-align: center;
            color: var(--board-border);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }

        .tab-button {
            padding: 8px 15px;
            background-color: transparent;
            color: #666;
            border: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            box-shadow: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background-color: #f5f5f5;
            box-shadow: none;
        }

        .tab-button.active {
            color: var(--button-primary);
            border-bottom: 3px solid var(--button-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #game-info {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
        }

        #game-code {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--board-border);
        }

        #player-role {
            font-weight: bold;
        }

        #join-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #game-code-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        #join-submit {
            white-space: nowrap;
        }

        .public-games-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .public-game-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .public-game-item:last-child {
            border-bottom: none;
        }

        .public-game-item:hover {
            background-color: var(--game-list-hover);
        }

        .public-game-info {
            display: flex;
            flex-direction: column;
        }

        .public-game-host {
            font-weight: bold;
        }

        .public-game-time {
            font-size: 0.8em;
            color: #888;
        }

        .public-game-status {
            font-size: 0.75em;
            color: #a0522d;
            font-weight: bold;
        }

        .join-public-button {
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .join-public-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .no-games-message {
            padding: 15px;
            text-align: center;
            color: #999;
        }

        .wait-message {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }

        .turn-indicator {
            padding: 5px 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .your-turn {
            background-color: #d4edda;
            color: #155724;
        }

        .opponent-turn {
            background-color: #f8d7da;
            color: #721c24;
        }

        /* リマッチ対応 */
        #rematch-controls {
            display: none;
            margin-top: 15px;
            text-align: center;
        }

        #rematch-button {
            width: 100%;
            background-color: #4caf50;
        }

        #rematch-button:hover {
            background-color: #45a049;
        }

        #rematch-status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        /* チャット機能のスタイル */
        .chat-container {
            background-color: var(--chat-bg);
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            display: none;
        }

        .chat-container h3 {
            margin-bottom: 10px;
            text-align: center;
            color: var(--board-border);
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fafafa;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            max-width: 80%;
            word-break: break-word;
        }

        .chat-message.sent {
            background-color: var(--chat-message-sent);
            margin-left: auto;
            border-bottom-right-radius: 0;
        }

        .chat-message.received {
            background-color: var(--chat-message-received);
            margin-right: auto;
            border-bottom-left-radius: 0;
        }

        .chat-message-time {
            font-size: 0.7em;
            color: #888;
            text-align: right;
            margin-top: 2px;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
        }

        #chat-input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            font-size: 1em;
        }

        #chat-submit {
            white-space: nowrap;
            background-color: #4caf50;
        }

        #chat-submit:hover {
            background-color: #45a049;
        }

        /* プリセットメッセージ */
        .preset-messages {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .preset-message {
            font-size: 0.8em;
            padding: 5px 8px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-message:hover {
            background-color: #e0e0e0;
        }

        /* ログインモーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-bg);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .modal-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: var(--board-border);
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 1em;
        }

        .modal-error {
            color: #dc3545;
            font-size: 0.9em;
            margin-bottom: 15px;
            display: none;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .game-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .board {
                width: 90vw;
                height: 90vw;
                max-width: 450px;
                max-height: 450px;
            }

            .coordinates,
            .row-coordinates {
                font-size: 0.8em;
            }

            .coordinates {
                width: 90vw;
                max-width: 450px;
            }

            .row-coordinates {
                height: 90vw;
                max-height: 450px;
            }

            .controls,
            .online-controls,
            .chat-container {
                width: 90vw;
                max-width: 450px;
            }

            .piece {
                font-size: 3.5vw;
            }

            .rules-container {
                width: 90vw;
                padding: 15px;
            }

            .button-group {
                flex-direction: column;
            }

            .tab-button {
                padding: 8px 10px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .piece {
                font-size: 4vw;
            }

            .hand-piece {
                width: 35px;
                height: 35px;
                font-size: 0.9em;
            }

            .action-buttons {
                flex-direction: column;
            }
        }

        /* 縦長レイアウト用 (スマホ向け) */
        @media (max-width: 768px) and (orientation: portrait) {
            .game-layout {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            /* .controls 内の子要素の並びを固定化 */
            .controls {
                width: 100%;
            }

            #gote-hand-container {
                order: 0;
            }

            #board-area {
                order: 1;
                margin-bottom: 15px;
                width: 100%;
            }

            #sente-hand-container {
                order: 2;
                margin-top: 10px;
            }

            /* スマホではボタン等を先に、その後に召喚プール */
            .status-panel {
                order: 3;
            }

            .summon-container {
                order: 4;
            }
        }
    </style>

    <!-- Firebase SDK -->
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script> -->
</head>

<body>
    <div id="version-banner"
        style="width:100%;background:#fffbcc;color:#8B4513;padding:6px 10px;text-align:center;font-weight:bold;border:1px solid #e6d87a;border-radius:6px;margin-bottom:8px;">
        ver3.2.1召喚ボタン・チャットオーバーレイ・決着時表示大など
    </div>
    <div class="header">
        <h1>オンライン対戦対応 召喚将棋</h1>
        <div class="user-info" id="user-info" style="display: none;">
            <div class="user-avatar" id="user-avatar">N</div>
            <span id="user-nickname">未ログイン</span>
        </div>
    </div>

    <div id="chat-overlay" aria-hidden="true">
        <div class="chat-panel" role="dialog" aria-modal="true" aria-labelledby="chat-title">
            <button id="chat-close-button" class="chat-close-button" aria-label="チャットを閉じる">×</button>
            <div class="chat-container" id="chat-container">
                <h3 id="chat-title">チャット</h3>
                <div class="preset-messages">
                    <div class="preset-message">よろしくお願いします</div>
                    <div class="preset-message">いい勝負でした</div>
                    <div class="preset-message">考え中です</div>
                    <div class="preset-message">ありがとうございました</div>
                    <div class="preset-message">また対戦しましょう</div>
                </div>
                <div class="chat-messages" id="chat-messages"></div>
                <div class="chat-input-container">
                    <input type="text" id="chat-input" placeholder="メッセージを入力...">
                    <button id="chat-submit">送信</button>
                </div>
            </div>
        </div>
    </div>

    <div id="result-overlay" aria-hidden="true">
        <div class="result-panel" role="dialog" aria-modal="true" aria-labelledby="result-title">
            <div id="result-title">勝利</div>
            <p id="result-subtitle">おめでとうございます！</p>
            <div class="result-buttons">
                <button id="result-rematch-button" class="result-button">もう一局</button>
                <button id="result-replay-button" class="result-button">リプレイ</button>
            </div>
        </div>
    </div>

    <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

    <div class="online-controls">
        <h3>オンライン対戦</h3>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="create-tab">部屋を作成</button>
            <button class="tab-button" data-tab="join-tab">部屋に参加</button>
            <button class="tab-button" data-tab="watch-tab">観戦する</button>
        </div>

        <div class="tab-content active" id="create-tab">
            <button id="create-game" class="create-game-button">部屋を作成する</button>
        </div>

        <div class="tab-content" id="join-tab">
            <div class="public-games-list" id="public-games-list">
                <div class="no-games-message">現在公開された部屋はありません</div>
            </div>

            <div id="join-form">
                <input type="text" id="game-code-input" placeholder="ゲームコードを入力して参加">
                <button id="join-submit">参加</button>
            </div>
        </div>

        <div class="tab-content" id="watch-tab">
            <div class="public-games-list" id="spectator-games-list">
                <div class="no-games-message">現在観戦できる部屋はありません</div>
            </div>

            <div id="watch-form">
                <input type="text" id="watch-code-input" placeholder="ゲームコードを入力して観戦">
                <button id="watch-submit">観戦を開始</button>
            </div>
        </div>

        <!-- 役割選択（先手/後手） -->
        <div id="role-select" class="role-select" style="display: none; margin-top:10px;">
            <div style="display:flex; gap:8px; justify-content:center;">
                <button id="choose-sente"
                    style="background:#8B4513; color:#fff; padding:8px 12px; border:none; border-radius:4px; font-weight:bold;">先手になる</button>
                <button id="choose-gote"
                    style="background:#2d6a4f; color:#fff; padding:8px 12px; border:none; border-radius:4px; font-weight:bold;">後手になる</button>
            </div>
            <div id="role-select-msg" style="margin-top:6px; text-align:center; color:#8B4513; font-size:0.9em;"></div>
        </div>

        <div id="game-info" style="display: none;">
            <p>ゲームコード: <span id="game-code"></span></p>
            <p>あなたは<span id="player-role"></span>です</p>
        </div>

        <div id="participants" style="display:none; margin-top:10px;">
            <h4 style="margin-bottom:6px;">参加者一覧</h4>
            <ul id="participant-list"
                style="list-style:none; padding:0; margin:0; font-size:0.95em; display:flex; flex-direction:column; gap:4px;">
            </ul>
        </div>

        <div id="turn-indicator" class="turn-indicator" style="display: none;">
            待機中...
        </div>

        <div id="rematch-controls" style="display: none;">
            <button id="rematch-button">リマッチを申し込む</button>
            <div id="rematch-status"></div>
        </div>
    </div>

    <div class="game-container game-layout">
        <div class="controls">
            <!-- 後手の持ち駒 -->
            <div class="hand-container" id="gote-hand-container">
                <div class="hand-title">後手の持ち駒 <span id="gote-count">0枚</span></div>
                <div class="hand" id="gote-hand"></div>
            </div>

            <!-- 盤面 -->
            <div class="board-area" id="board-area">
                <div class="board-toolbar">
                    <button id="flip-board-button" class="board-toggle-button">盤面反転</button>
                    <button id="chat-toggle-button" class="board-toggle-button">チャット</button>
                </div>
                <div class="coordinates" id="column-coordinates">
                    <div>9</div>
                    <div>8</div>
                    <div>7</div>
                    <div>6</div>
                    <div>5</div>
                    <div>4</div>
                    <div>3</div>
                    <div>2</div>
                    <div>1</div>
                </div>
                <div class="board-with-coords">
                    <div class="row-coordinates" id="row-coordinates">
                        <div>一</div>
                        <div>二</div>
                        <div>三</div>
                        <div>四</div>
                        <div>五</div>
                        <div>六</div>
                        <div>七</div>
                        <div>八</div>
                        <div>九</div>
                    </div>
                    <div class="board" id="board"></div>
                </div>
                <button id="summon-button" disabled>召喚</button>
            </div>

            <!-- 先手の持ち駒 -->
            <div class="hand-container" id="sente-hand-container">
                <div class="hand-title">先手の持ち駒 <span id="sente-count">0枚</span></div>
                <div class="hand" id="sente-hand"></div>
            </div>

            <!-- 召喚プール（任意の位置、ここではボタンの直前） -->
            <div class="summon-container">
                <div class="summon-title">召喚プール <span id="summon-count">38枚</span></div>
                <div class="summon-pool" id="summon-pool"></div>
                <div class="summon-info" id="summon-info">
                    新しい駒を召喚するには「召喚する」ボタンをクリックしてください。
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #8B4513; text-align: center;">
                    ※召喚したら、その駒を必ず盤面に打つ必要があります
                </div>
            </div>

            <!-- ボタン類（最下部） -->
            <div class="status-panel">
                <div class="status" id="status">ゲームを開始します</div>
                <div class="action-buttons">
                    <button id="pass-button" disabled>パス</button>
                    <button id="reset-button">リセット</button>
                </div>
            </div>
        </div>
    </div>

    <div class="rules-container">
        <div class="rules-toggle" id="rules-toggle">召喚将棋のルール</div>
        <div class="rules-content" id="rules-content">
            <h3>基本ルール:</h3>
            <ul>
                <li>最初、盤面には王将と玉将のみが初期配置されている（王将は先手側、玉将は後手側）</li>
                <li>残りのコマは「召喚プール」に置いてあり、ランダムに一コマずつ召喚できる</li>
                <li>先行のプレイヤーから交互に以下の選択肢がある:
                    <ol>
                        <li>召喚する（脇によけたコマが無くなるまで一ターンに一回まで）→ 召喚したらその駒を必ず盤面に打つ</li>
                        <li>持ち駒を置く</li>
                        <li>盤上の駒を動かす</li>
                    </ol>
                </li>
                <li>王手などで王が取られる場合はその限りでない（王手への対応が必要）</li>
                <li>初期配置の違いと召喚の選択肢があるだけで、他はクラシカルな将棋のルールと同じ</li>
            </ul>

            <h3>操作方法:</h3>
            <ul>
                <li>駒を動かす: 駒をクリックして、移動可能なマスをクリックする</li>
                <li>持ち駒を使う: 持ち駒をクリックして、置きたいマスをクリックする</li>
                <li>召喚する: 「召喚する」ボタンをクリックする（ターンに1回まで）</li>
                <li>何もしない: 「パス」ボタンをクリックする</li>
                <li>ゲームをリセット: 「リセット」ボタンをクリックする</li>
            </ul>

            <h3>オンライン対戦:</h3>
            <ul>
                <li>「部屋を作成」ボタンをクリックして新しいゲームを開始</li>
                <li>公開された部屋は誰でも参加できます</li>
                <li>ゲームコードを使って特定の相手と対戦することもできます</li>
                <li>先手（部屋作成者）から開始</li>
                <li>ゲーム終了後、「リマッチを申し込む」ボタンでもう一度対戦できます</li>
                <li>チャット機能を使って対戦相手とコミュニケーションが取れます</li>
            </ul>

            <h3>主な駒の動き:</h3>
            <div class="piece-movement">
                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell can-move">←</div>
                        <div class="move-cell piece">王</div>
                        <div class="move-cell can-move">→</div>
                        <div class="move-cell can-move">↙</div>
                        <div class="move-cell can-move">↓</div>
                        <div class="move-cell can-move">↘</div>
                    </div>
                    <div>王将・玉将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell can-move">←</div>
                        <div class="move-cell piece">金</div>
                        <div class="move-cell can-move">→</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↓</div>
                        <div class="move-cell"></div>
                    </div>
                    <div>金将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell"></div>
                        <div class="move-cell piece">銀</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↙</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↘</div>
                    </div>
                    <div>銀将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell piece">歩</div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                    </div>
                    <div>歩兵</div>
                </div>
            </div>
        </div>
    </div>

    <!-- プロモーションダイアログ -->
    <div class="promotion-dialog" id="promotion-dialog">
        <div class="promotion-content">
            <div class="promotion-title">駒を成りますか？</div>
            <div class="promotion-options">
                <div class="promotion-option" id="promote">と</div>
                <div class="promotion-option" id="not-promote">歩</div>
            </div>
            <div>※左が成り駒、右が元の駒です</div>
        </div>
    </div>

    <!-- ログインモーダル -->
    <div class="modal" id="login-modal">
        <div class="modal-content">
            <div class="modal-title">ニックネームを設定</div>
            <p>オンライン対戦を楽しむためのニックネームを入力してください</p>
            <input type="text" id="nickname-input" class="modal-input" placeholder="ニックネーム (2〜10文字)" maxlength="10">
            <div class="modal-error" id="nickname-error">既に使用されているニックネームです。別の名前を入力してください。</div>
            <div class="modal-buttons">
                <button id="login-button">ログイン</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>


    <script>
        // Firebase設定
        const firebaseConfig = {
            apiKey: "AIzaSyAjVQZN--ODV3u-LpDtAUEw1PDoqeapCO8",
            authDomain: "summon-shogi.firebaseapp.com",
            projectId: "summon-shogi",
            storageBucket: "summon-shogi.firebasestorage.app",
            messagingSenderId: "964883817096",
            appId: "1:964883817096:web:da421585a4c97c5715353d",
            measurementId: "G-6SY3BS1VHX"
        };

        // Firebaseの初期化
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // 匿名認証を必ず待つユーティリティ
        async function ensureAnonAuth() {
            const auth = firebase.auth();
            if (!auth.currentUser) {
                await auth.signInAnonymously();
                await new Promise((resolve, reject) => {
                    const off = auth.onAuthStateChanged(u => { if (u) { off(); resolve(); } }, reject);
                });
            }
            return auth.currentUser;
        }

        // Firebaseの初期化コード内または直後に追加
        firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
            .then(() => {
                console.log('認証の永続化を設定しました');
            })
            .catch((error) => {
                console.error('認証の永続化の設定に失敗しました:', error);
            });

        // 認証状態の監視（デバッグ用）
        firebase.auth().onAuthStateChanged(function (user) {
            console.log("認証状態:", user ? "認証済み" : "未認証");
        });

        // ページ読み込み時に実行
        document.addEventListener('DOMContentLoaded', function () {
            // Firebase認証状態の監視
            firebase.auth().onAuthStateChanged(async function (user) {
                if (user) {
                    console.log('ログイン済み:', user.uid);

                    // 前回の対局があれば復帰
                    const savedGameId = localStorage.getItem('currentGameId');
                    const savedRole = localStorage.getItem('playerRole');

                    if (savedGameId) {
                        try {
                            console.log('前回の対局に復帰します:', savedGameId);
                            await resumeSavedGame(savedGameId, savedRole);
                        } catch (e) {
                            console.warn('前回の対局への復帰に失敗しました:', e);
                        }
                    }
                }
            });
        });


        // DOMContentLoaded内に追加
        firebase.auth().onAuthStateChanged((user) => {
            console.log('認証状態が変更されました:', user ? 'ログイン中' : '未ログイン');

            if (user) {
                // ユーザーがログインしている場合
                const userNickname = localStorage.getItem('userNickname');
                console.log('ログイン中のユーザー:', user.uid, 'ニックネーム:', userNickname);

                // ニックネームが取得できない場合は再入力を促す
                if (!userNickname || userNickname.length < 2) {
                    showNicknameModal();
                }
            } else {
                // 未ログイン状態の場合、匿名ログインを自動実行
                firebase.auth().signInAnonymously()
                    .catch((error) => {
                        console.error('匿名ログインに失敗しました:', error);
                    });
            }
        });


        // オンライン対戦用の変数
        let isOnlineGame = false;
        let gameId = null;
        let playerRole = null; // 'sente'または'gote'
        let isSpectator = false;
        let opponentConnected = false;
        let rematchOffered = false;
        let rematchAccepted = false;
        let chatListenerRef = null;
        let rematchListenerRef = null;
        let isBoardFlipped = false;
        let boardFlipPreference = null;

        (function initBoardFlipPreference() {
            const storedFlipPref = localStorage.getItem('boardFlipPreference');
            if (storedFlipPref === 'true' || storedFlipPref === 'false') {
                boardFlipPreference = storedFlipPref === 'true';
                isBoardFlipped = boardFlipPreference;
            }
        })();

        // ユーザー認証用の変数
        let userNickname = null;
        let isLoggedIn = false;
        let publicGamesData = []; // 変数名を変更
        let publicGamesRefresh = null;
        let currentPlayers = {};
        let currentSpectators = {};

        // ゲームの状態を管理
        const gameState = {
            currentTurn: 'sente', // 先手（sente）または後手（gote）
            selectedPiece: null,
            selectedCell: null,
            possibleMoves: [],
            board: Array.from({ length: 9 }, () => Array(9).fill(null)),
            senteHand: [],
            goteHand: [],
            summonPool: [],
            hasSummoned: false,
            mustPlaceLastSummoned: false,
            lastSummonedPiece: null,
            gameOver: false,
            winner: null, // 勝者を記録
            inCheck: { sente: false, gote: false },
            lastMove: null,
            pendingPromotion: null,
            lastMoveId: null,
            lastProcessedMoveId: null
        };

        // 駒の種類と初期数
        const pieceTypes = {
            '歩': { count: 18, promotion: 'と' },
            '香': { count: 4, promotion: '杏' },
            '桂': { count: 4, promotion: '圭' },
            '銀': { count: 4, promotion: '全' },
            '金': { count: 4, promotion: null },
            '角': { count: 2, promotion: '馬' },
            '飛': { count: 2, promotion: '竜' }
        };

        // 駒の動き
        const pieceMoves = {
            '王': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ],
            '玉': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ],
            '金': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '銀': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 1 }, { x: 1, y: 1 }
            ],
            '桂': [
                { x: -1, y: -2 }, { x: 1, y: -2 }
            ],
            '香': [
                { x: 0, y: -1, range: 8 }
            ],
            '角': [
                { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 }
            ],
            '飛': [
                { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 }
            ],
            '歩': [
                { x: 0, y: -1 }
            ],
            'と': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '杏': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '圭': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '全': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '馬': [
                { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 },
                { x: 0, y: -1 }, { x: -1, y: 0 },
                { x: 1, y: 0 }, { x: 0, y: 1 }
            ],
            '竜': [
                { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 },
                { x: -1, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 1 }, { x: 1, y: 1 }
            ]
        };

        function normalizeOwner(owner) {
            if (owner === 'sente' || owner === 'gote') return owner;
            if (!owner && owner !== 0) return null;
            const normalized = String(owner).toLowerCase();
            if (normalized.includes('sente') || normalized.includes('先手') || normalized.includes('black') || normalized.includes('先攻')) {
                return 'sente';
            }
            if (normalized.includes('gote') || normalized.includes('後手') || normalized.includes('white') || normalized.includes('後攻')) {
                return 'gote';
            }
            return null;
        }

        function createPiece(type, owner, fallbackOwner = 'sente') {
            const normalizedOwner = normalizeOwner(owner) || normalizeOwner(fallbackOwner) || 'sente';
            return { type, owner: normalizedOwner };
        }

        function addPieceToHand(owner, pieceType) {
            const normalizedOwner = normalizeOwner(owner);
            if (!normalizedOwner) return;
            if (normalizedOwner === 'sente') {
                gameState.senteHand.push(pieceType);
            } else if (normalizedOwner === 'gote') {
                gameState.goteHand.push(pieceType);
            }
        }

        const chatSendQueue = [];
        let isRealtimeConnected = true;
        let isFlushingChatQueue = false;
        const displayedChatMessageIds = new Set();
        let connectionMonitorInitialized = false;

        function serializeBoard(board) {
            const result = {};
            if (!Array.isArray(board)) return result;
            for (let y = 0; y < board.length; y++) {
                const row = board[y];
                if (!Array.isArray(row)) continue;
                for (let x = 0; x < row.length; x++) {
                    const piece = row[x];
                    if (piece) {
                        if (!result[y]) result[y] = {};
                        result[y][x] = createPiece(piece.type, piece.owner);
                    }
                }
            }
            return result;
        }

        function deserializeBoard(data) {
            const board = Array.from({ length: 9 }, () => Array(9).fill(null));
            if (!data && data !== 0) return board;

            let source = data;
            if (typeof data === 'string') {
                try {
                    source = JSON.parse(data);
                } catch (e) {
                    console.warn('盤面データのパースに失敗しました', e);
                    return board;
                }
            }

            if (Array.isArray(source)) {
                for (let y = 0; y < source.length && y < 9; y++) {
                    const row = source[y];
                    if (!row) continue;
                    if (Array.isArray(row)) {
                        for (let x = 0; x < row.length && x < 9; x++) {
                            const piece = row[x];
                            if (piece) {
                                const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                            }
                        }
                    } else if (typeof row === 'object') {
                        for (const [xKey, piece] of Object.entries(row)) {
                            const x = Number(xKey);
                            if (Number.isInteger(x) && x >= 0 && x < 9 && piece) {
                                const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                            }
                        }
                    }
                }
                return board;
            }

            if (typeof source === 'object' && source) {
                for (const [yKey, row] of Object.entries(source)) {
                    const y = Number(yKey);
                    if (!Number.isInteger(y) || y < 0 || y >= 9) continue;
                    if (Array.isArray(row)) {
                        for (let x = 0; x < row.length && x < 9; x++) {
                            const piece = row[x];
                            if (piece) {
                                const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                            }
                        }
                    } else if (typeof row === 'object' && row) {
                        for (const [xKey, piece] of Object.entries(row)) {
                            const x = Number(xKey);
                            if (Number.isInteger(x) && x >= 0 && x < 9 && piece) {
                                const normalizedPiece = typeof piece === 'object' ? piece : { type: piece, owner: null };
                                const fallbackOwner = y >= 4 ? 'sente' : 'gote';
                                board[y][x] = createPiece(normalizedPiece.type, normalizedPiece.owner, fallbackOwner);
                            }
                        }
                    }
                }
            }

            return board;
        }

        function normalizeList(data) {
            if (!data && data !== 0) return [];
            if (Array.isArray(data)) return data.filter(item => item !== null && item !== undefined);
            if (typeof data === 'string') {
                try {
                    const parsed = JSON.parse(data);
                    return normalizeList(parsed);
                } catch (e) {
                    console.warn('配列データのパースに失敗しました', e);
                    return [];
                }
            }
            if (typeof data === 'object') {
                return Object.keys(data)
                    .sort((a, b) => Number(a) - Number(b))
                    .map(key => data[key])
                    .filter(item => item !== null && item !== undefined);
            }
            return [];
        }

        function updateCoordinateLabels() {
            if (columnCoordinates) {
                const cols = isBoardFlipped ? ['1', '2', '3', '4', '5', '6', '7', '8', '9'] : ['9', '8', '7', '6', '5', '4', '3', '2', '1'];
                columnCoordinates.innerHTML = '';
                cols.forEach(label => {
                    const div = document.createElement('div');
                    div.textContent = label;
                    columnCoordinates.appendChild(div);
                });
            }
            if (rowCoordinates) {
                const rows = isBoardFlipped ? ['九', '八', '七', '六', '五', '四', '三', '二', '一'] : ['一', '二', '三', '四', '五', '六', '七', '八', '九'];
                rowCoordinates.innerHTML = '';
                rows.forEach(label => {
                    const div = document.createElement('div');
                    div.textContent = label;
                    rowCoordinates.appendChild(div);
                });
            }
        }

        function getAutoBoardFlip() {
            return playerRole === 'gote';
        }

        function updateBoardToggleLabel() {
            if (!flipBoardButton) return;
            flipBoardButton.textContent = isBoardFlipped ? '先手視点に戻す' : '後手視点に切替';
        }

        function updateBoardFlipState(forceRender = false) {
            const autoState = getAutoBoardFlip();
            const targetState = boardFlipPreference !== null ? boardFlipPreference : autoState;
            if (isBoardFlipped !== targetState) {
                isBoardFlipped = targetState;
            }
            document.body.classList.toggle('board-flipped', isBoardFlipped);
            updateBoardToggleLabel();
            updateCoordinateLabels();
            if (forceRender && typeof renderBoard === 'function') {
                renderBoard();
            }
        }

        const CHAT_OVERLAY_STORAGE_KEY = 'chatOverlayOpen';

        function isChatOverlayActive() {
            return chatOverlay && chatOverlay.classList.contains('active');
        }

        function openChatOverlay(saveState = true) {
            if (!chatOverlay) return;
            chatOverlay.classList.add('active');
            chatOverlay.setAttribute('aria-hidden', 'false');
            document.body.classList.add('chat-overlay-active');
            if (saveState) localStorage.setItem(CHAT_OVERLAY_STORAGE_KEY, 'true');
            if (chatInput && !chatInput.disabled) {
                setTimeout(() => chatInput.focus({ preventScroll: true }), 0);
            }
        }

        function closeChatOverlay(saveState = true) {
            if (!chatOverlay) return;
            chatOverlay.classList.remove('active');
            chatOverlay.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('chat-overlay-active');
            if (saveState) localStorage.setItem(CHAT_OVERLAY_STORAGE_KEY, 'false');
        }

        function restoreChatOverlayState() {
            const stored = localStorage.getItem(CHAT_OVERLAY_STORAGE_KEY);
            if (stored === 'true') {
                openChatOverlay(false);
            } else {
                closeChatOverlay(false);
            }
        }

        function hideResultOverlay(updateState = true) {
            if (!resultOverlay) return;
            resultOverlay.classList.remove('active');
            resultOverlay.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('result-overlay-active');
            if (updateState) {
                // No persistence for now; placeholder
            }
        }

        function showResultOverlay(outcome) {
            if (!resultOverlay) return;
            let title = '対局終了';
            let subtitle = '対局が終了しました。';

            if (outcome === 'win') {
                title = '勝 利';
                subtitle = 'おめでとうございます！';
            } else if (outcome === 'lose') {
                title = '敗 北';
            } else if (outcome === 'sente-win') {
                title = '先手 勝利';
            } else if (outcome === 'gote-win') {
                title = '後手 勝利';
            }

            if (resultTitle) resultTitle.textContent = title;
            if (resultSubtitle) resultSubtitle.textContent = subtitle;

            resultOverlay.classList.add('active');
            resultOverlay.setAttribute('aria-hidden', 'false');
            document.body.classList.add('result-overlay-active');
        }

        function updateChatInputState() {
            if (!chatInput || !chatSubmit) return;
            const disabled = !isOnlineGame || !gameId;
            chatInput.disabled = disabled;
            chatSubmit.disabled = disabled;
            if (disabled) {
                chatInput.placeholder = '対局中のみチャットできます';
            } else if (!isRealtimeConnected) {
                chatInput.placeholder = '接続を待っています…';
            } else {
                chatInput.placeholder = 'メッセージを入力...';
            }
        }

        async function postChatMessage(payload) {
            await ensureAnonAuth();
            const chatRef = database.ref(`games/${gameId}/chat`).push();
            await chatRef.set(payload);
        }

        async function flushChatQueue() {
            if (!isRealtimeConnected || isFlushingChatQueue || chatSendQueue.length === 0) return;
            isFlushingChatQueue = true;
            try {
                while (chatSendQueue.length > 0) {
                    const payload = chatSendQueue[0];
                    try {
                        await postChatMessage(payload);
                        chatSendQueue.shift();
                    } catch (err) {
                        console.error('チャットキュー送信に失敗', err);
                        showToast('メッセージの再送信に失敗しました', 'error');
                        break;
                    }
                }
            } finally {
                isFlushingChatQueue = false;
                updateChatInputState();
            }
        }

        function initRealtimeConnectionMonitor() {
            if (connectionMonitorInitialized) return;
            connectionMonitorInitialized = true;
            try {
                const connectedRef = firebase.database().ref('.info/connected');
                connectedRef.on('value', snapshot => {
                    const connected = snapshot.val() === true;
                    if (connected) {
                        if (!isRealtimeConnected) {
                            showToast('接続しました', 'success');

                            // 接続が回復したら、プレイヤーのonlineフラグを更新
                            const uid = firebase.auth().currentUser?.uid;
                            if (uid && isOnlineGame && gameId) {
                                if (!isSpectator) {
                                    database.ref(`games/${gameId}/players/${uid}/online`).set(true);
                                } else {
                                    database.ref(`games/${gameId}/spectators/${uid}/online`).set(true);
                                }
                            }
                        }
                        isRealtimeConnected = true;
                        updateChatInputState();
                        flushChatQueue();
                    } else {
                        if (isRealtimeConnected) {
                            showToast('接続が切れました。再接続を待っています', 'warn');
                        }
                        isRealtimeConnected = false;
                        updateChatInputState();
                    }
                });
            } catch (err) {
                console.error('接続監視の初期化に失敗', err);
            }

            window.addEventListener('online', () => {
                showToast('ネットワークに接続しました', 'info');
            });

            window.addEventListener('offline', () => {
                showToast('ネットワークから切断されました', 'warn');
                isRealtimeConnected = false;
                updateChatInputState();
            });
        }

        function showToast(message, type = 'info', duration = 3500) {
            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                console[type === 'error' ? 'error' : 'log'](message);
                return;
            }
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });
            setTimeout(() => {
                toast.classList.remove('visible');
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, duration);
        }

        function updateParticipantListDisplay() {
            if (!participantsContainer || !participantListElement) return;
            if (!isOnlineGame || !gameId) {
                participantsContainer.style.display = 'none';
                participantListElement.innerHTML = '';
                return;
            }

            participantsContainer.style.display = 'block';
            participantListElement.innerHTML = '';

            const uid = firebase.auth().currentUser?.uid;
            const playerEntries = [];
            for (const [pid, info] of Object.entries(currentPlayers || {})) {
                if (!info) continue;
                const role = info.role;
                let label = 'プレイヤー';
                let order = 2;
                if (role === 'sente') { label = '先手'; order = 0; }
                else if (role === 'gote') { label = '後手'; order = 1; }
                playerEntries.push({ order, label, pid, info });
            }

            playerEntries.sort((a, b) => a.order - b.order);
            playerEntries.forEach(entry => {
                const li = document.createElement('li');
                let text = `${entry.label}: ${entry.info.nickname || '匿名'}`;
                if (entry.pid === uid) text += ' (あなた)';
                if (entry.info.online === false) text += ' [離席]';
                li.textContent = text;
                participantListElement.appendChild(li);
            });

            const spectatorEntries = [];
            for (const [sid, info] of Object.entries(currentSpectators || {})) {
                if (!info) continue;
                spectatorEntries.push({ sid, info });
            }

            spectatorEntries.sort((a, b) => (a.info.joinedAt || 0) - (b.info.joinedAt || 0));
            if (spectatorEntries.length > 0) {
                const header = document.createElement('li');
                header.textContent = '--- 観戦者 ---';
                header.style.fontWeight = 'bold';
                participantListElement.appendChild(header);

                spectatorEntries.forEach(entry => {
                    const li = document.createElement('li');
                    let text = `${entry.info.nickname || '匿名'}`;
                    if (entry.sid === uid) text += ' (あなた)';
                    if (entry.info.online === false) text += ' [離席]';
                    li.textContent = text;
                    participantListElement.appendChild(li);
                });
            }
        }

        function showNicknameModal() {
            // 統一: ログインモーダル表示は showLoginModal に集約
            if (typeof showLoginModal === 'function') {
                showLoginModal();
                return;
            }
            loginModal.style.display = 'flex';
            nicknameInput.focus();
        }

        function generateRandomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function generateMoveId() {
            return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
        }

        // 効果音を無効化（ブラウザの互換性問題を回避）
        const sounds = {
            move: null,
            summon: null,
            capture: null,
            check: null,
            gameover: null
        };

        // DOM要素
        const boardElement = document.getElementById('board');
        const senteHandElement = document.getElementById('sente-hand');
        const goteHandElement = document.getElementById('gote-hand');
        const summonPoolElement = document.getElementById('summon-pool');
        const summonButton = document.getElementById('summon-button');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const passButton = document.getElementById('pass-button');
        const rulesToggle = document.getElementById('rules-toggle');
        const rulesContent = document.getElementById('rules-content');
        const summonCountElement = document.getElementById('summon-count');
        const senteCountElement = document.getElementById('sente-count');
        const goteCountElement = document.getElementById('gote-count');
        const summonInfoElement = document.getElementById('summon-info');

        // プロモーションダイアログ
        const promotionDialog = document.getElementById('promotion-dialog');
        const promoteOption = document.getElementById('promote');
        const notPromoteOption = document.getElementById('not-promote');

        // オンライン対戦用のUI要素
        const createGameButton = document.getElementById('create-game');
        const joinGameButton = document.getElementById('join-game');
        const gameInfoElement = document.getElementById('game-info');
        const gameCodeElement = document.getElementById('game-code');
        const playerRoleElement = document.getElementById('player-role');
        const joinFormElement = document.getElementById('join-form');
        const gameCodeInput = document.getElementById('game-code-input');
        const joinSubmitButton = document.getElementById('join-submit');
        const turnIndicator = document.getElementById('turn-indicator');
        const roleSelect = document.getElementById('role-select');
        const chooseSenteBtn = document.getElementById('choose-sente');
        const chooseGoteBtn = document.getElementById('choose-gote');
        const roleSelectMsg = document.getElementById('role-select-msg');
        const publicGamesListElement = document.getElementById('public-games-list'); // 変数名を変更
        const spectatorGamesListElement = document.getElementById('spectator-games-list');
        const watchCodeInput = document.getElementById('watch-code-input');
        const watchSubmitButton = document.getElementById('watch-submit');
        const participantsContainer = document.getElementById('participants');
        const participantListElement = document.getElementById('participant-list');
        const flipBoardButton = document.getElementById('flip-board-button');
        const columnCoordinates = document.getElementById('column-coordinates');
        const rowCoordinates = document.getElementById('row-coordinates');

        // プレイヤーの役割を共通処理で反映
        function applyPlayerRole(role) {
            const normalized = role === 'sente' ? 'sente' : (role === 'gote' ? 'gote' : (role === 'spectator' ? 'spectator' : null));
            playerRole = normalized;

            if (playerRoleElement) {
                if (normalized) {
                    if (normalized === 'sente') {
                        playerRoleElement.textContent = '先手（あなた）';
                    } else if (normalized === 'gote') {
                        playerRoleElement.textContent = '後手（あなた）';
                    } else {
                        playerRoleElement.textContent = '観戦者（あなた）';
                    }
                } else {
                    playerRoleElement.textContent = '未確定';
                }
            }

            if (normalized && normalized !== 'spectator') {
                localStorage.setItem('playerRole', normalized);
            } else if (normalized === 'spectator') {
                localStorage.setItem('playerRole', 'spectator');
            } else {
                localStorage.removeItem('playerRole');
            }

            if (typeof updateTurnIndicator === 'function') {
                updateTurnIndicator();
            }

            if (normalized && isOnlineGame && gameId) {
                ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
                if (normalized === 'sente' || normalized === 'gote') {
                    refreshRematchListener().catch(err => console.error('リマッチリスナーの開始に失敗しました', err));
                    if (rematchButton) rematchButton.disabled = false;
                } else {
                    stopRematchListener();
                    if (rematchControls) rematchControls.style.display = 'none';
                    if (rematchButton) rematchButton.disabled = true;
                }
            } else if (!normalized) {
                stopChatListener();
                stopRematchListener();
            }

            updateBoardFlipState(true);
            updateChatInputState();
        }

        async function resumeSavedGame(savedGameId, savedRole) {
            if (isOnlineGame && gameId === savedGameId) return;
            await ensureAnonAuth();
            const snapshot = await firebase.database().ref(`games/${savedGameId}`).once('value');
            if (!snapshot.exists()) {
                localStorage.removeItem('currentGameId');
                localStorage.removeItem('playerRole');
                throw new Error('保存された対局が見つかりません');
            }

            isOnlineGame = true;
            isSpectator = savedRole === 'spectator';
            gameId = savedGameId;
            localStorage.setItem('currentGameId', savedGameId);

            if (savedRole) {
                applyPlayerRole(savedRole);
            } else {
                const uid = firebase.auth().currentUser?.uid;
                const data = snapshot.val();
                const inferredRole = uid && data?.players && data.players[uid]?.role ? data.players[uid].role : null;
                if (inferredRole) {
                    applyPlayerRole(inferredRole);
                } else {
                    applyPlayerRole(null);
                }
            }

            if (gameInfoElement) gameInfoElement.style.display = 'block';
            if (gameCodeElement) gameCodeElement.textContent = snapshot.val()?.code || savedGameId;
            if (turnIndicator) turnIndicator.style.display = 'block';

            if (isSpectator) {
                await registerSpectator(savedGameId);
            }

            await attachGameListeners(savedGameId);
            if (isSpectator) {
                await ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
            }
            updateChatInputState();
        }

        // タブ切り替え用の要素
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // リマッチ用のUI要素
        const rematchControls = document.getElementById('rematch-controls');
        const rematchButton = document.getElementById('rematch-button');
        const rematchStatus = document.getElementById('rematch-status');

        // チャット機能用のUI要素
        const chatContainer = document.getElementById('chat-container');
        const chatOverlay = document.getElementById('chat-overlay');
        const chatCloseButton = document.getElementById('chat-close-button');
        const chatToggleButton = document.getElementById('chat-toggle-button');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSubmit = document.getElementById('chat-submit');
        const presetMessages = document.querySelectorAll('.preset-message');
        const resultOverlay = document.getElementById('result-overlay');
        const resultTitle = document.getElementById('result-title');
        const resultSubtitle = document.getElementById('result-subtitle');
        const resultRematchButton = document.getElementById('result-rematch-button');
        const resultReplayButton = document.getElementById('result-replay-button');

        // ログイン機能用のUI要素
        const loginModal = document.getElementById('login-modal');
        const nicknameInput = document.getElementById('nickname-input');
        const loginButton = document.getElementById('login-button');
        const nicknameError = document.getElementById('nickname-error');
        const userInfo = document.getElementById('user-info');
        const userAvatar = document.getElementById('user-avatar');
        const userNicknameElement = document.getElementById('user-nickname');

        // 競合する重複初期化を除去（正規のリスナーは下部で設定）

        // イベントハンドラを関数として定義
        function handleRoomCreation() {
            const user = firebase.auth().currentUser;
            const userNickname = localStorage.getItem('userNickname');

            if (!user) {
                console.error('ユーザーがログインしていません');
                firebase.auth().signInAnonymously()
                    .then(() => {
                        if (userNickname && userNickname.length >= 2) {
                            setTimeout(createRoom, 500);
                        } else {
                            alert('ログインが必要です。ニックネームを入力してください。');
                            showNicknameModal();
                        }
                    })
                    .catch(error => {
                        console.error('再ログインに失敗:', error);
                        alert('ログインに失敗しました。再読み込みしてお試しください。');
                    });
                return;
            }

            if (!userNickname || userNickname.length < 2) {
                alert('ニックネームは2文字以上入力してください');
                showNicknameModal();
                return;
            }



            createRoom();
        }


        // ページ読み込み時に実行
        document.addEventListener('DOMContentLoaded', () => {
            // localStorageからユーザー情報を取得
            const savedNickname = localStorage.getItem('userNickname');
            if (savedNickname) {
                // ニックネームがあれば予約→登録を試みる（失敗したら再入力）
                setNickname(savedNickname)
                    .catch(() => {
                        showLoginModal();
                    });
            } else {
                // ニックネームがない場合はログインモーダルを表示
                showLoginModal();
            }

            // 公開ゲームリストの取得を開始
            startPublicGamesRefresh();

            restoreChatOverlayState();
            initRealtimeConnectionMonitor();
            updateChatInputState();
        });

        // タブ切り替え
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                // アクティブなタブを切り替え
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 対応するコンテンツを表示
                const tabId = button.getAttribute('data-tab');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
            });
        });

        // 役割選択ボタンのイベント
        if (chooseSenteBtn) chooseSenteBtn.addEventListener('click', () => chooseRole('sente'));
        if (chooseGoteBtn) chooseGoteBtn.addEventListener('click', () => chooseRole('gote'));

        // オンライン対戦イベントリスナー
        if (createGameButton) createGameButton.addEventListener('click', () => {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }
            createGameRoom();
        });

        if (joinSubmitButton) joinSubmitButton.addEventListener('click', async () => {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }

            const code = gameCodeInput.value.trim().toUpperCase();
            if (code.length !== 6) {
                alert('有効なゲームコード（6文字）を入力してください');
                return;
            }
            const gid = await findGameIdByCode(code);
            if (!gid) {
                alert('そのコードの部屋は見つかりません');
                return;
            }
            await joinGameRoomById(gid);
        });

        if (watchSubmitButton) watchSubmitButton.addEventListener('click', async () => {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }

            const code = watchCodeInput.value.trim().toUpperCase();
            if (code.length !== 6) {
                alert('有効なゲームコード（6文字）を入力してください');
                return;
            }
            const gid = await findGameIdByCode(code);
            if (!gid) {
                alert('そのコードの部屋は見つかりません');
                return;
            }
            await watchGameRoomById(gid);
        });

        if (flipBoardButton) {
            flipBoardButton.addEventListener('click', () => {
                const autoState = getAutoBoardFlip();
                const newState = !isBoardFlipped;
                if (newState === autoState) {
                    boardFlipPreference = null;
                    localStorage.removeItem('boardFlipPreference');
                } else {
                    boardFlipPreference = newState;
                    localStorage.setItem('boardFlipPreference', String(boardFlipPreference));
                }
                isBoardFlipped = newState;
                updateBoardFlipState(true);
            });
        }

        if (chatToggleButton) {
            chatToggleButton.addEventListener('click', () => {
                if (isChatOverlayActive()) {
                    closeChatOverlay();
                } else {
                    openChatOverlay();
                }
            });
        }

        if (chatCloseButton) {
            chatCloseButton.addEventListener('click', () => closeChatOverlay());
        }

        if (chatOverlay) {
            chatOverlay.addEventListener('click', (event) => {
                if (event.target === chatOverlay) {
                    closeChatOverlay();
                }
            });
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && isChatOverlayActive()) {
                event.preventDefault();
                closeChatOverlay();
            }
            if (event.key === 'Escape' && resultOverlay && resultOverlay.classList.contains('active')) {
                event.preventDefault();
                hideResultOverlay();
            }
        });

        if (resultOverlay) {
            resultOverlay.addEventListener('click', (event) => {
                if (event.target === resultOverlay) {
                    hideResultOverlay();
                }
            });
        }

        if (resultRematchButton) {
            resultRematchButton.addEventListener('click', () => {
                hideResultOverlay();
                if (isOnlineGame && !isSpectator) {
                    offerRematch();
                } else {
                    initGame();
                }
            });
        }

        if (resultReplayButton) {
            resultReplayButton.addEventListener('click', () => {
                hideResultOverlay();
                console.log('Replay feature is under construction.');
                alert('リプレイ機能は準備中です。');
            });
        }

        // publicGames の code → gameId を解決
        async function findGameIdByCode(code) {
            await ensureAnonAuth();
            const snap = await firebase.database()
                .ref('publicGames')
                .orderByChild('code')
                .equalTo(code)
                .once('value');
            if (!snap.exists()) return null;
            return Object.keys(snap.val())[0];
        }

        // ニックネーム予約用ヘルパー（推奨: /nicknames インデックス）
        function toKey(name) { return name.trim().toLowerCase(); }
        async function claimNickname(nickname) {
            await ensureAnonAuth();
            const uid = firebase.auth().currentUser.uid;
            const key = toKey(nickname);
            const ref = firebase.database().ref(`nicknames/${key}`);
            const result = await ref.transaction(cur => cur || uid);
            // 既に自分のUIDが入っている場合もOKとする
            return result.snapshot && result.snapshot.val() === uid;
        }
        async function setNickname(nickname) {
            const ok = await claimNickname(nickname);
            if (!ok) throw new Error('そのニックネームは使用されています');
            await registerUser(nickname);
            hideLoginModal();
        }

        // ログインイベントリスナー（予約→登録）
        if (loginButton) {
            loginButton.addEventListener('click', async () => {
                const nickname = nicknameInput.value.trim();

                // 入力チェック
                if (nickname.length < 2 || nickname.length > 10) {
                    nicknameError.textContent = 'ニックネームは2〜10文字で入力してください';
                    nicknameError.style.display = 'block';
                    return;
                }

                try {
                    await setNickname(nickname);
                } catch (e) {
                    nicknameError.textContent = e.message || 'ニックネームの予約に失敗しました';
                    nicknameError.style.display = 'block';
                }
            });
        }

        // ニックネーム入力でEnterキーの処理
        if (nicknameInput) {
            nicknameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && loginButton) {
                    loginButton.click();
                }
            });
        }

        // ニックネームの重複をチェック（認証完了を待機）
        async function checkNicknameAvailability(nickname) {
            await ensureAnonAuth();
            const snap = await database.ref('users')
                .orderByChild('nickname')
                .equalTo(nickname)
                .once('value');
            return !snap.exists();
        }

        // ユーザー登録（uidに統一）
        async function registerUser(nickname) {
            const user = await ensureAnonAuth();
            const uid = user.uid;

            userNickname = nickname;
            isLoggedIn = true;

            await database.ref(`users/${uid}`).set({
                nickname,
                lastLoginAt: firebase.database.ServerValue.TIMESTAMP
            });

            // localStorageに保存
            localStorage.setItem('userNickname', nickname);
            localStorage.setItem('userId', uid);

            // UI更新
            userNicknameElement.textContent = nickname;
            userAvatar.textContent = nickname.charAt(0).toUpperCase();
            userInfo.style.display = 'flex';

            // 接続時に消えるよう設定
            database.ref(`users/${uid}`).onDisconnect().remove();
        }

        // ユーザーIDを生成
        function generateUserId() {
            return Math.random().toString(36).substring(2, 15) +
                Math.random().toString(36).substring(2, 15);
        }

        // ログインモーダルを表示
        function showLoginModal() {
            loginModal.style.display = 'flex';
            nicknameInput.focus();
        }

        // ログインモーダルを非表示
        function hideLoginModal() {
            loginModal.style.display = 'none';
            nicknameError.style.display = 'none';
        }

        // 公開ゲームリストの更新を開始
        async function startPublicGamesRefresh() {
            await ensureAnonAuth();
            // 既存のタイマーがあればクリア
            if (publicGamesRefresh) {
                clearInterval(publicGamesRefresh);
            }

            // 公開ゲームリストを監視
            database.ref('publicGames').on('value', (snapshot) => {
                updatePublicGamesList(snapshot);
            });

            // 5秒ごとに更新
            publicGamesRefresh = setInterval(() => {
                cleanupOldPublicGames();
            }, 5000);
        }

        // 公開ゲームリストを更新
        function updatePublicGamesList(snapshot) {
            publicGamesListElement.innerHTML = '';
            if (spectatorGamesListElement) spectatorGamesListElement.innerHTML = '';
            publicGamesData = [];

            if (!snapshot || !snapshot.exists()) {
                publicGamesListElement.innerHTML = '<div class="no-games-message">現在公開された部屋はありません</div>';
                if (spectatorGamesListElement) spectatorGamesListElement.innerHTML = '<div class="no-games-message">現在観戦できる部屋はありません</div>';
                return;
            }

            const games = snapshot.val();
            const gameItems = Object.entries(games).map(([gameId, game]) => ({
                id: gameId,
                host: game.host || '匿名',
                createdAt: game.createdAt || 0,
                status: game.status || 'waiting'
            })).sort((a, b) => b.createdAt - a.createdAt);

            const joinable = gameItems.filter(game => game.status !== 'playing');
            const watchable = gameItems;

            const renderList = (container, items, buttonLabel, handlerBuilder) => {
                if (!container) return;
                if (items.length === 0) {
                    container.innerHTML = buttonLabel === '参加する'
                        ? '<div class="no-games-message">現在公開された部屋はありません</div>'
                        : '<div class="no-games-message">現在観戦できる部屋はありません</div>';
                    return;
                }

                items.forEach(game => {
                    const gameItem = document.createElement('div');
                    gameItem.className = 'public-game-item';

                    const gameInfo = document.createElement('div');
                    gameInfo.className = 'public-game-info';

                    const hostElement = document.createElement('div');
                    hostElement.className = 'public-game-host';
                    hostElement.textContent = `${game.host} の部屋`;

                    const statusElement = document.createElement('div');
                    statusElement.className = 'public-game-status';
                    statusElement.textContent = game.status === 'playing' ? '対局中' : '募集中';

                    gameInfo.appendChild(hostElement);
                    gameInfo.appendChild(statusElement);

                    const timeElement = document.createElement('div');
                    timeElement.className = 'public-game-time';
                    timeElement.textContent = formatTime(game.createdAt);
                    gameInfo.appendChild(timeElement);

                    const actionButton = document.createElement('button');
                    actionButton.className = 'join-public-button';
                    actionButton.textContent = buttonLabel;
                    actionButton.addEventListener('click', handlerBuilder(game));

                    if (buttonLabel === '参加する' && game.status === 'playing') {
                        actionButton.disabled = true;
                        actionButton.textContent = '対局中';
                    }

                    gameItem.appendChild(gameInfo);
                    gameItem.appendChild(actionButton);

                    container.appendChild(gameItem);
                });
            };

            renderList(publicGamesListElement, joinable, '参加する', game => () => {
                if (!isLoggedIn) { showLoginModal(); return; }
                joinGameRoomById(game.id);
            });

            renderList(spectatorGamesListElement, watchable, '観戦する', game => () => {
                if (!isLoggedIn) { showLoginModal(); return; }
                watchGameRoomById(game.id);
            });

            publicGamesData = gameItems;
        }

        // 古い公開ゲームをクリーンアップ
        async function cleanupOldPublicGames() {
            const now = Date.now();
            await ensureAnonAuth();
            database.ref('publicGames').once('value', (snapshot) => {
                if (!snapshot.exists()) return;

                const games = snapshot.val();
                for (const gameId in games) {
                    const game = games[gameId];

                    // 30分以上経過したゲームを削除
                    if (now - game.createdAt > 30 * 60 * 1000) {
                        database.ref(`publicGames/${gameId}`).remove();
                        database.ref(`games/${gameId}`).remove();
                    }
                }
            });
        }

        // 時間を「〜分前」形式に変換
        function formatTime(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;

            if (diff < 60 * 1000) {
                return 'たった今';
            } else if (diff < 60 * 60 * 1000) {
                return `${Math.floor(diff / (60 * 1000))}分前`;
            } else if (diff < 24 * 60 * 60 * 1000) {
                return `${Math.floor(diff / (60 * 60 * 1000))}時間前`;
            } else {
                return `${Math.floor(diff / (24 * 60 * 60 * 1000))}日前`;
            }
        }

        // リマッチボタンイベントリスナー
        if (rematchButton) rematchButton.addEventListener('click', offerRematch);

        // チャット機能イベントリスナー
        if (chatSubmit) chatSubmit.addEventListener('click', sendChatMessage);
        if (chatInput) {
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
        }

        // プリセットメッセージのイベントリスナー
        presetMessages.forEach(msg => {
            msg.addEventListener('click', () => {
                chatInput.value = msg.textContent;
                sendChatMessage();
            });
        });

        // ルールの表示/非表示
        if (rulesToggle) rulesToggle.addEventListener('click', () => {
            rulesContent.classList.toggle('show');
            rulesToggle.classList.toggle('open');
        });

        // ゲームをリセット
        if (resetButton) resetButton.addEventListener('click', () => {
            if (isOnlineGame) {
                if (confirm('オンライン対戦中です。ゲームをリセットしますか？')) {
                    // オンライン接続をリセット
                    leaveGameRoom();
                    initGame();
                }
            } else {
                initGame();
            }
        });

        // パスボタン
        if (passButton) passButton.addEventListener('click', () => {
            // 召喚後は駒を置かないとパスできない
            if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                alert('召喚した駒を盤面に打つ必要があります');
                return;
            }

            // 自分のターンでなければパスできない（オンライン時）
            if (isOnlineGame && !isMyTurn()) {
                alert('相手の手番です');
                return;
            }

            // 移動IDを生成して二重処理を防ぐ
            const moveId = generateMoveId();
            gameState.lastMoveId = moveId;
            gameState.lastProcessedMoveId = moveId;

            // 手番を切り替え
            switchTurn();
            playSound('move');

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame && !isSpectator) {
                syncGameState();
            }
        });

        // 召喚ボタン
        if (summonButton) summonButton.addEventListener('click', summonPiece);

        // プロモーションイベント
        if (promoteOption) promoteOption.addEventListener('click', () => handlePromotion(true));
        if (notPromoteOption) notPromoteOption.addEventListener('click', () => handlePromotion(false));

        // 効果音を再生（現在は無効化しています）
        function playSound(name) {
            // 音声機能は無効化されています
            return;
        }

        // チャットメッセージを送信
        async function sendChatMessage() {
            if (!isOnlineGame || !gameId) {
                showToast('対局中のみチャットが利用できます', 'warn');
                return;
            }

            const message = chatInput.value.trim();
            if (message === '') return;

            const timestamp = Date.now();
            const senderUid = firebase.auth().currentUser?.uid || `anon-${timestamp}`;
            let senderRole = playerRole;
            if (!senderRole) {
                senderRole = isSpectator ? 'spectator' : 'visitor';
            }
            const nicknameToUse = userNickname || localStorage.getItem('userNickname') || '匿名';

            const payload = {
                message,
                senderRole,
                sender: senderRole,
                senderUid,
                nickname: nicknameToUse,
                timestamp
            };

            chatInput.value = '';

            displayChatMessage(payload.message, payload.senderRole, payload.nickname, payload.timestamp, payload.senderUid);

            if (!isRealtimeConnected) {
                chatSendQueue.push(payload);
                showToast('接続復帰後に送信します', 'warn');
                updateChatInputState();
                return;
            }

            try {
                await postChatMessage(payload);
            } catch (err) {
                console.error('チャット送信に失敗', err);
                showToast('送信できませんでした。再送を試みます', 'error');
                chatSendQueue.push(payload);
                isRealtimeConnected = false;
                updateChatInputState();
            }

            flushChatQueue();

            if (chatInput && !chatInput.disabled) {
                setTimeout(() => chatInput.focus({ preventScroll: true }), 0);
            }
        }

        // チャットメッセージを表示
        function displayChatMessage(message, senderRole, nickname, timestamp, senderUid, messageKey) {
            if (!chatMessages) return;
            const baseId = `${senderUid || 'anon'}|${timestamp || 'unknown'}`;
            const candidateIds = [messageKey, baseId].filter(Boolean);
            if (candidateIds.some(id => displayedChatMessageIds.has(id))) return;
            candidateIds.forEach(id => displayedChatMessageIds.add(id));

            const messageEl = document.createElement('div');
            const currentUid = firebase.auth().currentUser?.uid;
            const isOwn = senderUid && currentUid && senderUid === currentUid;
            messageEl.className = `chat-message ${isOwn ? 'sent' : 'received'}`;

            const senderInfo = document.createElement('div');
            senderInfo.style.fontWeight = 'bold';
            senderInfo.style.marginBottom = '3px';
            const roleLabelMap = {
                sente: '先手',
                gote: '後手',
                spectator: '観戦者',
                visitor: '参加者'
            };
            const roleLabel = senderRole && roleLabelMap[senderRole] ? `（${roleLabelMap[senderRole]}）` : '';
            if (isOwn) {
                senderInfo.textContent = roleLabel ? `あなた${roleLabel}` : 'あなた';
            } else {
                senderInfo.textContent = `${nickname || '匿名'}${roleLabel}`;
            }

            const textEl = document.createElement('div');
            textEl.textContent = message;

            const timeEl = document.createElement('div');
            timeEl.className = 'chat-message-time';

            // タイムスタンプを整形
            const date = timestamp ? new Date(timestamp) : new Date();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            timeEl.textContent = `${hours}:${minutes}`;

            messageEl.appendChild(senderInfo);
            messageEl.appendChild(textEl);
            messageEl.appendChild(timeEl);

            chatMessages.appendChild(messageEl);

            if (chatMessages.children.length > 200) {
                const first = chatMessages.firstChild;
                if (first) first.remove();
            }

            // 最新のメッセージが見えるようにスクロール
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // リマッチを申し込む
        async function offerRematch() {
            if (!isOnlineGame || !gameId || !(playerRole === 'sente' || playerRole === 'gote')) return;

            rematchButton.disabled = true;
            rematchStatus.textContent = 'リマッチを申し込み中...';

            // リマッチ情報をFirebaseに保存
            await ensureAnonAuth();
            database.ref(`games/${gameId}/rematch/${playerRole}`).set({
                offered: true,
                nickname: userNickname
            });

            // 相手のリマッチ受諾状態をチェック
            const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';
            database.ref(`games/${gameId}/rematch/${opponentRole}`).once('value')
                .then((snapshot) => {
                    if (snapshot.exists() && snapshot.val().offered === true) {
                        // 両者がリマッチを希望
                        startRematch();
                    }
                });
        }

        // リマッチを開始
        async function startRematch() {
            rematchStatus.textContent = 'リマッチが成立しました！新しいゲームを開始します...';

            // リマッチフラグをリセット
            await ensureAnonAuth();
            database.ref(`games/${gameId}/rematch`).remove();

            // 新しいゲームを開始（ただし同じ部屋）
            initGame();

            // 役割を入れ替え（先手・後手を交代）
            const previousRole = playerRole;
            const nextRole = previousRole === 'sente' ? 'gote' : 'sente';
            applyPlayerRole(nextRole);

            const uid = firebase.auth().currentUser?.uid;
            if (uid && gameId) {
                await database.ref(`games/${gameId}/players/${uid}/role`).set(nextRole);
                await database.ref(`games/${gameId}/roles`).transaction(roles => {
                    if (!roles) return roles;
                    const currentSente = roles.sente;
                    const currentGote = roles.gote;
                    if (previousRole === 'sente' && currentSente === uid) {
                        roles.sente = currentGote || null;
                        roles.gote = uid;
                        return roles;
                    }
                    if (previousRole === 'gote' && currentGote === uid) {
                        roles.sente = uid;
                        roles.gote = currentSente || null;
                        return roles;
                    }
                    return roles;
                });
            }

            // ゲーム状態をFirebaseに初期化
            syncGameState();

            // リマッチコントロールを更新
            setTimeout(() => {
                rematchButton.disabled = false;
                rematchStatus.textContent = '';
                rematchControls.style.display = 'none';
            }, 3000);

            // 状態を更新
            updateTurnIndicator();
        }

        // 作成: ゲームを waiting で作って待機し、開始を監視
        async function createGameRoom() {
            await ensureAnonAuth();
            const uid = firebase.auth().currentUser.uid;
            const code = generateRandomId();
            const id = code; // 便宜上 code をそのまま gameId に
            const now = Date.now();

            const gameRef = database.ref(`games/${id}`);
            await gameRef.set({
                code, createdAt: now,
                status: { phase: 'waiting', turn: 'sente' },
                players: {
                    [uid]: { role: 'sente', nickname: localStorage.getItem('userNickname'), online: true, joinedAt: now }
                },
                roles: { sente: uid, gote: null }
            });

            // 公開リスト（任意）
            await database.ref(`publicGames/${id}`).set({ code, host: localStorage.getItem('userNickname'), createdAt: now, status: 'waiting' });

            // 接続切れ処理
            gameRef.child(`players/${uid}/online`).onDisconnect().set(false);

            isOnlineGame = true;
            isSpectator = false;
            gameId = id;
            localStorage.setItem('currentGameId', id);
            applyPlayerRole('sente');
            gameInfoElement.style.display = 'block';
            gameCodeElement.textContent = code;
            turnIndicator.style.display = 'block';
            turnIndicator.textContent = '対戦相手の接続を待っています…';

            await attachGameListeners(id);
            restoreChatOverlayState();
            updateChatInputState();
            updateChatInputState();
        }

        function initialBoardState() {
            return {
                ranks: {
                    1: {
                        e: { type: '王将', owner: 'sente' }
                    },
                    9: {
                        e: { type: '王将', owner: 'gote' }
                    }
                },
                captured: {
                    sente: [],
                    gote: []
                },
                turn: 'sente'
            };
        }



        // 参加: roles を原子的に確保し、players に反映（同時参加でも一意）
        async function joinGameRoomById(id) {
            await ensureAnonAuth();
            const uid = firebase.auth().currentUser.uid;
            const nickname = localStorage.getItem('userNickname') || '匿名';
            const gameRef = database.ref(`games/${id}`);
            const gameSnap = await gameRef.once('value');
            if (!gameSnap.exists()) { alert('部屋が見つかりません'); return; }

            const now = Date.now();
            let decidedRole = null;
            // 旧部屋互換: roles がない場合は players から推定
            const existingPlayers = (gameSnap.child('players').val() || {});
            const inferred = { sente: null, gote: null };
            for (const [pid, p] of Object.entries(existingPlayers)) {
                if (p?.role === 'sente') inferred.sente = pid;
                if (p?.role === 'gote') inferred.gote = pid;
            }

            const roleTxn = await gameRef.child('roles').transaction(cur => {
                const roles = cur || { sente: null, gote: null };
                // 空いているところに推定を反映（既存プレイヤーの役割を尊重）
                if (!roles.sente && inferred.sente) roles.sente = inferred.sente;
                if (!roles.gote && inferred.gote) roles.gote = inferred.gote;
                // すでに自分が入っている場合はそのまま
                if (roles.sente === uid || roles.gote === uid) return roles;
                // 典型: 先手が埋まっているので後手を確保
                if (roles.sente && !roles.gote) { decidedRole = 'gote'; roles.gote = uid; return roles; }
                // 先手が空いている場合は先手へ
                if (!roles.sente) { decidedRole = 'sente'; roles.sente = uid; return roles; }
                // それ以外は満員
                return; // abort
            });

            if (!roleTxn.committed) { alert('この部屋は満員です'); return; }
            // roles に基づき players を更新
            if (!decidedRole) {
                const rolesNow = roleTxn.snapshot.val() || {};
                decidedRole = rolesNow.sente === uid ? 'sente' : 'gote';
            }
            await gameRef.child(`players/${uid}`).set({ role: decidedRole, nickname, online: true, joinedAt: now });

            // 接続切れ時のフラグ
            gameRef.child(`players/${uid}/online`).onDisconnect().set(false);

            // ローカル状態/表示
            isOnlineGame = true;
            isSpectator = false;
            gameId = id;
            localStorage.setItem('currentGameId', id);
            applyPlayerRole(decidedRole);
            if (gameInfoElement) gameInfoElement.style.display = 'block';
            if (gameCodeElement) gameCodeElement.textContent = gameSnap.val().code || id;
            if (turnIndicator) turnIndicator.style.display = 'block';

            await attachGameListeners(id);
            restoreChatOverlayState();
            updateChatInputState();
        }

        async function registerSpectator(gameId) {
            await ensureAnonAuth();
            const uid = firebase.auth().currentUser.uid;
            const nickname = localStorage.getItem('userNickname') || '匿名';
            const spectatorRef = database.ref(`games/${gameId}/spectators/${uid}`);
            await spectatorRef.set({ nickname, online: true, joinedAt: Date.now() });
            spectatorRef.onDisconnect().remove();
        }

        async function watchGameRoomById(id) {
            await ensureAnonAuth();
            if (isOnlineGame && gameId && gameId !== id) {
                await leaveGameRoom();
            }
            const uid = firebase.auth().currentUser.uid;
            const nickname = localStorage.getItem('userNickname') || '匿名';
            const gameRef = database.ref(`games/${id}`);
            const gameSnap = await gameRef.once('value');
            if (!gameSnap.exists()) { alert('部屋が見つかりません'); return; }

            await registerSpectator(id);

            isOnlineGame = true;
            isSpectator = true;
            gameId = id;
            localStorage.setItem('currentGameId', id);
            localStorage.setItem('playerRole', 'spectator');
            applyPlayerRole('spectator');

            if (gameInfoElement) gameInfoElement.style.display = 'block';
            if (gameCodeElement) gameCodeElement.textContent = gameSnap.val()?.code || id;
            if (turnIndicator) turnIndicator.style.display = 'block';
            restoreChatOverlayState();
            updateChatInputState();
            if (rematchControls) rematchControls.style.display = 'none';
            if (rematchButton) rematchButton.disabled = true;

            await attachGameListeners(id);
            await ensureChatListener().catch(err => console.error('チャットリスナーの開始に失敗しました', err));
            if (watchCodeInput) watchCodeInput.value = '';
            updateChatInputState();
        }

        // 入力制御・初期state一括書き込みユーティリティ
        function setInputEnabled(enabled) {
            if (typeof summonButton !== 'undefined' && summonButton) summonButton.disabled = !enabled;
            if (typeof passButton !== 'undefined' && passButton) passButton.disabled = !enabled;
        }

        async function pushInitialStateOnce(gameRef) {
            await gameRef.child('meta/startedAt').transaction(v => v || Date.now());

            // 召喚プールを生成（38枚）
            const pool = [];
            for (const [piece, info] of Object.entries(pieceTypes)) {
                for (let i = 0; i < (info.count || 0); i++) pool.push(piece);
            }
            // フィッシャー–イェーツでシャッフル
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            const boardData = serializeBoard(gameState.board);

            const init = {
                currentTurn: 'sente',
                board: boardData,
                senteHand: [], goteHand: [],
                summonPool: pool,
                hasSummoned: false,
                mustPlaceLastSummoned: false,
                lastSummonedPiece: null,
                gameOver: false,
                winner: null,
                inCheck: { sente: false, gote: false },
                lastMove: null,
                lastMoveId: null
            };
            await gameRef.child('state').set(init);

            // 互換: 旧ロジック向けにトップレベルにも保存
            const legacy = {
                currentTurn: init.currentTurn,
                board: JSON.stringify(boardData),
                senteHand: JSON.stringify(init.senteHand),
                goteHand: JSON.stringify(init.goteHand),
                summonPool: JSON.stringify(init.summonPool),
                hasSummoned: init.hasSummoned,
                mustPlaceLastSummoned: init.mustPlaceLastSummoned,
                lastSummonedPiece: init.lastSummonedPiece,
                gameOver: init.gameOver,
                winner: init.winner,
                inCheck: JSON.stringify(init.inCheck),
                lastMove: JSON.stringify(init.lastMove),
                lastMoveId: init.lastMoveId,
                lastUpdate: Date.now()
            };
            await gameRef.update(legacy);
        }

        // 2人になったら開始、state購読でUI同期
        async function attachGameListeners(gameId) {
            await ensureAnonAuth();
            const gameRef = firebase.database().ref(`games/${gameId}`);

            // players 監視: 2人揃ったら開始処理 + 自分のrole反映
            gameRef.child('players').on('value', async snap => {
                const players = snap.val() || {};
                const count = Object.keys(players).length;

                currentPlayers = players;

                // 自分のroleをDBから確定してUIに反映
                const me = firebase.auth().currentUser?.uid;
                if (!isSpectator && me && players[me]?.role) {
                    applyPlayerRole(players[me].role);
                }

                // 役割マップがある場合はそちらを優先して反映
                const rolesSnap = await gameRef.child('roles').once('value');
                const roles = rolesSnap.val();
                if (roles && me) {
                    const roleFromMap = roles.sente === me ? 'sente' : (roles.gote === me ? 'gote' : null);
                    if (roleFromMap && !isSpectator) {
                        applyPlayerRole(roleFromMap);
                    } else if (!roleFromMap && !isSpectator && playerRole) {
                        applyPlayerRole(null);
                    }
                }

                if (isSpectator) {
                    applyPlayerRole('spectator');
                    if (roleSelect) roleSelect.style.display = 'none';
                    if (roleSelectMsg) roleSelectMsg.textContent = '観戦モードです';
                }

                opponentConnected = count === 2;

                // 公開リストのステータス更新（先手のみ）
                const hostUid = roles && roles.sente;
                if (hostUid && hostUid === firebase.auth().currentUser?.uid) {
                    try {
                        await firebase.database().ref(`publicGames/${gameId}`).update({
                            status: count >= 2 ? 'playing' : 'waiting'
                        });
                    } catch (e) {
                        console.warn('publicGames status 更新失敗', e);
                    }
                }

                if (count === 2) {
                    // 状態: 対局中へ
                    try { await gameRef.child('status/phase').set('playing'); } catch (e) { console.warn('status/phase 書き込み失敗', e); }
                    // 先手が初期state投入（1回だけ）
                    if (playerRole === 'sente') {
                        try {
                            const started = (await gameRef.child('meta/startedAt').once('value')).val();
                            if (!started) await pushInitialStateOnce(gameRef);
                        } catch (e) {
                            console.error('初期状態の書き込みに失敗しました。ルールで games/<id>/state と meta の書き込みを許可してください。', e);
                        }
                    }
                    if (gameInfoElement) gameInfoElement.style.display = 'block';
                    if (turnIndicator) turnIndicator.style.display = 'block';
                    restoreChatOverlayState();
                    if (typeof updateTurnIndicator === 'function') updateTurnIndicator();
                }

                // 役割選択UIの表示制御
                const uid = firebase.auth().currentUser?.uid;
                const myRoleKnown = !!(players[uid]?.role || (roles && (roles.sente === uid || roles.gote === uid)));
                if (!gameState.gameOver && isOnlineGame && !isSpectator) {
                    // 両役埋まっていない or 自分の役が未確定 → 表示
                    const bothAssigned = !!(roles && roles.sente && roles.gote);
                    roleSelect.style.display = (!bothAssigned || !myRoleKnown) ? 'block' : 'none';
                    roleSelectMsg.textContent = (!bothAssigned) ? '役割を選んでください（先着優先）' : '';
                } else {
                    roleSelect.style.display = 'none';
                }

                updateParticipantListDisplay();
            });

            // roles ノードの変化を監視してロールを常に同期
            gameRef.child('roles').on('value', snap => {
                const roles = snap.val() || {};
                const me = firebase.auth().currentUser?.uid;
                if (!me) return;
                if (isSpectator) {
                    applyPlayerRole('spectator');
                    return;
                }
                if (roles.sente === me) {
                    applyPlayerRole('sente');
                } else if (roles.gote === me) {
                    applyPlayerRole('gote');
                } else if (playerRole) {
                    applyPlayerRole(null);
                }
            });

            gameRef.child('spectators').on('value', snap => {
                currentSpectators = snap.val() || {};
                updateParticipantListDisplay();
            });

            // state 監視: UI反映・入力制御
            gameRef.child('state').on('value', snap => {
                const st = snap.val();
                if (!st) return;
                if (st.lastMoveId && st.lastMoveId === gameState.lastProcessedMoveId) {
                    return;
                }
                if ('currentTurn' in st) gameState.currentTurn = st.currentTurn;
                if ('board' in st) gameState.board = deserializeBoard(st.board);
                if ('senteHand' in st) gameState.senteHand = normalizeList(st.senteHand);
                if ('goteHand' in st) gameState.goteHand = normalizeList(st.goteHand);
                if ('summonPool' in st) gameState.summonPool = normalizeList(st.summonPool);
                if ('hasSummoned' in st) gameState.hasSummoned = !!st.hasSummoned;
                if ('mustPlaceLastSummoned' in st) gameState.mustPlaceLastSummoned = !!st.mustPlaceLastSummoned;
                if ('lastSummonedPiece' in st) gameState.lastSummonedPiece = st.lastSummonedPiece || null;
                if ('inCheck' in st) gameState.inCheck = st.inCheck || { sente: false, gote: false };
                if ('gameOver' in st) gameState.gameOver = !!st.gameOver;
                if ('winner' in st) gameState.winner = st.winner || null;
                if ('lastMoveId' in st) {
                    gameState.lastMoveId = st.lastMoveId;
                    gameState.lastProcessedMoveId = st.lastMoveId;
                }

                // 既存の描画系を呼ぶ（関数が存在する前提）
                if (typeof renderBoard === 'function') renderBoard();
                if (typeof renderHands === 'function') renderHands();
                if (typeof renderSummonPool === 'function') renderSummonPool();
                if (typeof updateStatus === 'function') updateStatus();
                if (typeof updateCounters === 'function') updateCounters();

                setInputEnabled(isMyTurn());
                if (turnIndicator) {
                    turnIndicator.textContent = isMyTurn() ? 'あなたの手番です' : '相手の手番です';
                }
            });

            // 互換: state が使えない環境向けにトップレベルも監視
            gameRef.on('value', snap => {
                if (!snap.exists()) {
                    alert('ゲームルームが削除されました');
                    leaveGameRoom().catch(err => console.error('ルーム離脱処理に失敗しました', err));
                    initGame();
                    return;
                }

                const st = snap.child('state').val();
                if (st) return; // state が使えているならこちらは不要
                const data = snap.val();
                if (!data) return;
                try {
                    if (data.lastMoveId && data.lastMoveId === gameState.lastProcessedMoveId) {
                        return;
                    }
                    if ('currentTurn' in data) gameState.currentTurn = data.currentTurn || gameState.currentTurn;
                    if ('board' in data) gameState.board = deserializeBoard(data.board);
                    if ('senteHand' in data) gameState.senteHand = normalizeList(data.senteHand);
                    if ('goteHand' in data) gameState.goteHand = normalizeList(data.goteHand);
                    if ('summonPool' in data) gameState.summonPool = normalizeList(data.summonPool);
                    if ('hasSummoned' in data) gameState.hasSummoned = !!data.hasSummoned;
                    if ('mustPlaceLastSummoned' in data) gameState.mustPlaceLastSummoned = !!data.mustPlaceLastSummoned;
                    if ('lastSummonedPiece' in data) gameState.lastSummonedPiece = data.lastSummonedPiece || null;
                    if ('inCheck' in data) {
                        try {
                            gameState.inCheck = typeof data.inCheck === 'string' ? JSON.parse(data.inCheck) : (data.inCheck || { sente: false, gote: false });
                        } catch (e) {
                            gameState.inCheck = { sente: false, gote: false };
                        }
                    }
                    if ('gameOver' in data) gameState.gameOver = !!data.gameOver;
                    if ('winner' in data) gameState.winner = data.winner || null;
                    if ('lastMoveId' in data) {
                        gameState.lastMoveId = data.lastMoveId;
                        gameState.lastProcessedMoveId = data.lastMoveId;
                    }

                    if (typeof renderBoard === 'function') renderBoard();
                    if (typeof renderHands === 'function') renderHands();
                    if (typeof renderSummonPool === 'function') renderSummonPool();
                    if (typeof updateStatus === 'function') updateStatus();
                    if (typeof updateCounters === 'function') updateCounters();

                    setInputEnabled(isMyTurn());
                    if (turnIndicator) {
                        turnIndicator.textContent = isMyTurn() ? 'あなたの手番です' : '相手の手番です';
                    }
                } catch (e) {
                    console.warn('レガシー状態の反映に失敗', e);
                }
            });

            isOnlineGame = true;
        }

        // 2人オンラインなら phase を playing に
        async function startGameIfReady(id) {
            const gameRef = database.ref(`games/${id}`);
            const ps = (await gameRef.child('players').once('value')).val() || {};
            const count = Object.values(ps).filter(p => p && p.online !== false).length;
            if (count === 2) await gameRef.child('status/phase').set('playing');
        }

        // 役割選択（先手/後手）の確定処理（transactionで原子的に確保）
        async function chooseRole(role) {
            if (!isOnlineGame || !gameId || isSpectator) return;
            await ensureAnonAuth();
            const uid = firebase.auth().currentUser.uid;
            const ref = database.ref(`games/${gameId}`);
            const tx = await ref.child('roles').transaction(cur => {
                const roles = cur || { sente: null, gote: null };
                // 既に自分がどちらかに入っていたら解放してから希望に入る
                if (roles.sente === uid && role === 'gote') roles.sente = null;
                if (roles.gote === uid && role === 'sente') roles.gote = null;
                // 既に他人がその役を取っていたら中止
                if (role === 'sente' && roles.sente && roles.sente !== uid) return; // abort
                if (role === 'gote' && roles.gote && roles.gote !== uid) return; // abort
                // 確保
                if (role === 'sente') roles.sente = uid; else roles.gote = uid;
                return roles;
            });
            if (!tx.committed) { roleSelectMsg.textContent = 'その役は既に埋まっています'; return; }
            await ref.child(`players/${uid}/role`).set(role);
            applyPlayerRole(role);
            roleSelectMsg.textContent = '役割を確定しました';
        }

        // phase 変更を監視してUIを有効化
        function watchGameStart(id) {
            const sRef = database.ref(`games/${id}/status/phase`);
            sRef.on('value', s => {
                if (s && s.val() === 'playing') {
                    turnIndicator.textContent = playerRole === 'sente' ? 'あなたの先手番です' : '先手の着手待ち';
                    // TODO: 既存の盤面初期化/ボタン有効化などを呼ぶ
                    // 例: initGame(); enableBoardForOnline(); 等
                } else {
                    turnIndicator.textContent = '対戦相手の接続を待っています…';
                }
            });
        }

        // コードから gameId を検索
        async function findGameIdByCode(code) {
            await ensureAnonAuth();
            const snap = await firebase.database()
                .ref('publicGames')
                .orderByChild('code')
                .equalTo(code)
                .once('value');
            if (!snap.exists()) return null;
            return Object.keys(snap.val())[0];
        }

        // ゲームルームから離脱
        async function leaveGameRoom() {
            if (isOnlineGame && gameId) {
                await ensureAnonAuth();
                const uid = firebase.auth().currentUser?.uid;
                const exitingRole = playerRole;
                const wasSpectator = isSpectator;

                // 監視を解除
                database.ref(`games/${gameId}`).off();

                if (uid) {
                    if (wasSpectator) {
                        await database.ref(`games/${gameId}/spectators/${uid}`).remove();
                    } else {
                        // players から自身を削除
                        await database.ref(`games/${gameId}/players/${uid}`).remove();
                        // roles マップを更新
                        await database.ref(`games/${gameId}/roles`).transaction(roles => {
                            if (!roles) return roles;
                            if (roles.sente === uid) roles.sente = null;
                            if (roles.gote === uid) roles.gote = null;
                            return roles;
                        });
                    }
                }

                if (exitingRole === 'sente') {
                    await database.ref(`publicGames/${gameId}`).remove();
                }

                stopChatListener();
                stopRematchListener();

                // リセット
                isOnlineGame = false;
                gameId = null;
                opponentConnected = false;
                isSpectator = false;
                currentPlayers = {};
                currentSpectators = {};
                applyPlayerRole(null);
                localStorage.removeItem('currentGameId');
                updateParticipantListDisplay();
                hideResultOverlay(false);

                // UI更新
                gameInfoElement.style.display = 'none';
                turnIndicator.style.display = 'none';
                rematchControls.style.display = 'none';
                closeChatOverlay(false);
                if (chatMessages) chatMessages.innerHTML = '';
                displayedChatMessageIds.clear();
                chatSendQueue.length = 0;
                isFlushingChatQueue = false;
                updateChatInputState();
                if (createGameButton) createGameButton.disabled = false;
                if (joinGameButton) joinGameButton.disabled = false;
            }
        }

        async function ensureChatListener() {
            if (!isOnlineGame || !gameId || chatListenerRef) return;
            await ensureAnonAuth();
            if (chatMessages) chatMessages.innerHTML = '';
            displayedChatMessageIds.clear();
            chatListenerRef = database.ref(`games/${gameId}/chat`);
            chatListenerRef.on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (!message) return;
                const role = message.senderRole || message.sender || 'visitor';
                displayChatMessage(
                    message.message,
                    role,
                    message.nickname,
                    message.timestamp,
                    message.senderUid,
                    snapshot.key
                );
            });
        }

        function stopChatListener() {
            if (chatListenerRef) {
                chatListenerRef.off();
                chatListenerRef = null;
            }
            displayedChatMessageIds.clear();
        }

        async function refreshRematchListener() {
            if (rematchListenerRef) {
                rematchListenerRef.off();
                rematchListenerRef = null;
            }

            if (!isOnlineGame || !gameId || !(playerRole === 'sente' || playerRole === 'gote')) return;

            const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';
            await ensureAnonAuth();
            rematchListenerRef = database.ref(`games/${gameId}/rematch/${opponentRole}`);
            rematchListenerRef.on('value', (snapshot) => {
                if (snapshot.exists() && snapshot.val().offered === true) {
                    const opponentNickname = snapshot.val().nickname;
                    rematchStatus.textContent = `${opponentNickname}さんからリマッチの申し込みがあります`;
                    rematchControls.style.display = 'block';

                    database.ref(`games/${gameId}/rematch/${playerRole}`).once('value')
                        .then((mySnapshot) => {
                            if (mySnapshot.exists() && mySnapshot.val().offered === true) {
                                startRematch();
                            }
                        });
                }
            });
        }

        function stopRematchListener() {
            if (rematchListenerRef) {
                rematchListenerRef.off();
                rematchListenerRef = null;
            }
        }

        // ゲーム状態をFirebaseに同期（state 下へフラット保存）
        async function syncGameState() {
            if (!isOnlineGame || !gameId || isSpectator) return;
            await ensureAnonAuth();
            const boardData = serializeBoard(gameState.board);
            const st = {
                currentTurn: gameState.currentTurn,
                board: boardData,
                senteHand: gameState.senteHand,
                goteHand: gameState.goteHand,
                summonPool: gameState.summonPool,
                hasSummoned: gameState.hasSummoned,
                mustPlaceLastSummoned: gameState.mustPlaceLastSummoned,
                lastSummonedPiece: gameState.lastSummonedPiece,
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                inCheck: gameState.inCheck,
                lastMove: gameState.lastMove,
                lastMoveId: gameState.lastMoveId
            };
            await database.ref(`games/${gameId}/state`).set(st);

            // 互換: 旧ロジック向けにトップレベルにも保存
            const legacy = {
                currentTurn: gameState.currentTurn,
                board: JSON.stringify(boardData),
                senteHand: JSON.stringify(gameState.senteHand),
                goteHand: JSON.stringify(gameState.goteHand),
                summonPool: JSON.stringify(gameState.summonPool),
                hasSummoned: gameState.hasSummoned,
                mustPlaceLastSummoned: gameState.mustPlaceLastSummoned,
                lastSummonedPiece: gameState.lastSummonedPiece,
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                inCheck: JSON.stringify(gameState.inCheck),
                lastMove: JSON.stringify(gameState.lastMove),
                lastMoveId: gameState.lastMoveId,
                lastUpdate: Date.now()
            };
            await database.ref(`games/${gameId}`).update(legacy);
        }

        // 自分のターンかどうかを確認
        function isMyTurn() {
            return isOnlineGame && playerRole === gameState.currentTurn && !gameState.gameOver;
        }

        // ターン表示を更新
        function updateTurnIndicator() {
            if (!isOnlineGame) {
                turnIndicator.style.display = 'none';
                return;
            }

            turnIndicator.style.display = 'block';

            if (!opponentConnected) {
                turnIndicator.textContent = '対戦相手の接続を待っています...';
                turnIndicator.className = 'turn-indicator';
                return;
            }

            if (gameState.gameOver) {
                const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                turnIndicator.textContent = `ゲーム終了 - ${winnerText}の勝利`;
                turnIndicator.className = 'turn-indicator';

                // ゲーム終了時はリマッチコントロールを表示
                rematchControls.style.display = 'block';
                return;
            }

            if (isSpectator) {
                const currentText = gameState.currentTurn === 'sente' ? '先手の手番です' : '後手の手番です';
                turnIndicator.textContent = `観戦中: ${currentText}`;
                turnIndicator.className = 'turn-indicator';
                return;
            }

            // デバッグ情報
            console.log('Turn Indicator Debug:', {
                isOnlineGame,
                playerRole,
                currentTurn: gameState.currentTurn,
                isMyTurn: isMyTurn(),
                gameOver: gameState.gameOver
            });

            if (isMyTurn()) {
                turnIndicator.textContent = 'あなたの手番です';
                turnIndicator.className = 'turn-indicator your-turn';
            } else {
                turnIndicator.textContent = '相手の手番です';
                turnIndicator.className = 'turn-indicator opponent-turn';
            }
        }

        // ゲームを初期化
        function initGame() {
            hideResultOverlay(false);
            // ボードをクリア
            gameState.board = Array(9).fill().map(() => Array(9).fill(null));
            gameState.senteHand = [];
            gameState.goteHand = [];
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];
            gameState.currentTurn = 'sente';
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false; // 召喚した駒を置かなければならないフラグ
            gameState.lastSummonedPiece = null; // 最後に召喚した駒の種類
            gameState.gameOver = false;
            gameState.winner = null; // 勝者をリセット
            gameState.inCheck = { sente: false, gote: false };
            gameState.lastMove = null;
            gameState.pendingPromotion = null;
            gameState.lastMoveId = null;
            gameState.lastProcessedMoveId = null;

            // 召喚プールを初期化
            gameState.summonPool = [];
            for (const [piece, info] of Object.entries(pieceTypes)) {
                for (let i = 0; i < info.count; i++) {
                    gameState.summonPool.push(piece);
                }
            }

            // 王将と玉将を初期配置
            gameState.board[8][4] = createPiece('王', 'sente');
            gameState.board[0][4] = createPiece('玉', 'gote');

            // UIを更新
            updateBoardFlipState();
            renderBoard();
            renderHands();
            renderSummonPool();
            updateStatus();
            updateCounters();

            // 召喚ボタンを有効化
            updateButtonsState();

            // 召喚情報を更新
            updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame && !isSpectator) {
                syncGameState();
            }

            updateChatInputState();
        }

        // ボタンの状態を更新
        function updateButtonsState() {
            const canAct = !isOnlineGame || isMyTurn();

            // 召喚ボタンの状態
            summonButton.disabled = gameState.summonPool.length === 0 ||
                gameState.hasSummoned ||
                gameState.gameOver ||
                !canAct;

            // パスボタンの状態
            passButton.disabled = gameState.gameOver ||
                (gameState.hasSummoned && gameState.mustPlaceLastSummoned) ||
                !canAct;
        }

        // カウンターを更新
        function updateCounters() {
            summonCountElement.textContent = `${gameState.summonPool.length}枚`;
            senteCountElement.textContent = `${gameState.senteHand.length}枚`;
            goteCountElement.textContent = `${gameState.goteHand.length}枚`;
        }

        // 召喚情報を更新
        function updateSummonInfo(text) {
            summonInfoElement.textContent = text;
        }

        // ボードをレンダリング
        function renderBoard() {
            boardElement.innerHTML = '';
            updateCoordinateLabels();
            boardElement.classList.toggle('flipped', isBoardFlipped);

            const rowOrder = isBoardFlipped ? [...Array(9).keys()].reverse() : [...Array(9).keys()];
            const colOrder = isBoardFlipped ? [...Array(9).keys()].reverse() : [...Array(9).keys()];

            for (const boardY of rowOrder) {
                for (const boardX of colOrder) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = boardX;
                    cell.dataset.y = boardY;

                    // 駒があれば表示
                    const piece = gameState.board[boardY][boardX];
                    if (piece && piece.type) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.owner}`;
                        if (gameState.selectedCell && gameState.selectedCell.x === boardX && gameState.selectedCell.y === boardY) {
                            pieceElement.classList.add('selected');
                        }

                        // 最後に動かした駒にアニメーションを適用
                        if (gameState.lastMove && gameState.lastMove.toX === boardX && gameState.lastMove.toY === boardY) {
                            pieceElement.classList.add('animated');
                        }

                        pieceElement.textContent = piece.type;
                        cell.appendChild(pieceElement);
                    }

                    // セルのハイライト
                    if (gameState.possibleMoves.some(move => {
                        if (move.x === boardX && move.y === boardY) {
                            const targetPiece = gameState.board[boardY][boardX];
                            if (targetPiece && targetPiece.owner !== gameState.currentTurn) {
                                cell.classList.add('highlight-attack');
                            } else {
                                cell.classList.add('highlight-move');
                            }
                            return true;
                        }
                        return false;
                    })) {
                        // ハイライトは上記のif文で適用済み
                    }

                    // クリックイベント
                    cell.addEventListener('click', () => handleCellClick(boardX, boardY));

                    boardElement.appendChild(cell);
                }
            }
        }

        // 持ち駒をレンダリング
        function renderHands() {
            // 先手の持ち駒
            senteHandElement.innerHTML = '';

            // 持ち駒を種類ごとに集計
            const senteHandCount = gameState.senteHand.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 持ち駒を種類順に並べる
            const sortedSentePieces = Object.keys(senteHandCount).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedSentePieces) {
                const count = senteHandCount[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'hand-piece sente';
                pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                pieceElement.dataset.type = piece;
                pieceElement.addEventListener('click', () => {
                    if (isOnlineGame && playerRole !== 'sente') return; // オンライン対戦時は自分の持ち駒だけ
                    handleHandPieceClick(piece, 'sente');
                });
                senteHandElement.appendChild(pieceElement);
            }

            // 後手の持ち駒
            goteHandElement.innerHTML = '';

            // 持ち駒を種類ごとに集計
            const goteHandCount = gameState.goteHand.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 持ち駒を種類順に並べる
            const sortedGotePieces = Object.keys(goteHandCount).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedGotePieces) {
                const count = goteHandCount[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'hand-piece gote';
                pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                pieceElement.dataset.type = piece;
                pieceElement.addEventListener('click', () => {
                    if (isOnlineGame && playerRole !== 'gote') return; // オンライン対戦時は自分の持ち駒だけ
                    handleHandPieceClick(piece, 'gote');
                });
                goteHandElement.appendChild(pieceElement);
            }
        }

        // 召喚プールをレンダリング
        function renderSummonPool() {
            summonPoolElement.innerHTML = '';

            // 召喚プールの駒の数を表示
            const pieceCounts = gameState.summonPool.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 駒を種類順に並べる
            const sortedPieces = Object.keys(pieceCounts).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedPieces) {
                const count = pieceCounts[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'summon-piece';
                pieceElement.textContent = `${piece}×${count}`;
                summonPoolElement.appendChild(pieceElement);
            }

            // ボタンの状態を更新
            updateButtonsState();
        }

        // ステータスを更新
        function updateStatus() {
            statusElement.className = 'status';

            if (gameState.gameOver) {
                const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                statusElement.textContent = `${winnerText}の勝利！`;
                statusElement.classList.add('gameover');
                const outcome = (isSpectator || !(playerRole === 'sente' || playerRole === 'gote'))
                    ? (gameState.winner === 'sente' ? 'sente-win' : 'gote-win')
                    : (gameState.winner === playerRole ? 'win' : 'lose');
                showResultOverlay(outcome);
            } else if (gameState.inCheck.sente) {
                statusElement.textContent = '先手の王が王手です！';
                statusElement.classList.add('check');
                hideResultOverlay(false);
            } else if (gameState.inCheck.gote) {
                statusElement.textContent = '後手の玉が王手です！';
                statusElement.classList.add('check');
                hideResultOverlay(false);
            } else {
                statusElement.textContent = gameState.currentTurn === 'sente' ? '先手の手番です' : '後手の手番です';
                statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');
                hideResultOverlay(false);
            }

            // ボタンの状態を更新
            updateButtonsState();
        }

        // セルがクリックされたときの処理
        function handleCellClick(x, y) {
            if (gameState.gameOver) return;

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            const clickedPiece = gameState.board[y][x];

            // 選択中の駒があり、有効な移動先がクリックされた場合
            if (gameState.selectedPiece && gameState.possibleMoves.some(move => move.x === x && move.y === y)) {
                movePiece(x, y);
                return;
            }

            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // 自分の駒をクリックした場合
            if (clickedPiece && clickedPiece.owner === gameState.currentTurn) {
                gameState.selectedPiece = clickedPiece;
                gameState.selectedCell = { x, y };
                gameState.possibleMoves = calculatePossibleMoves(x, y, clickedPiece);
            }

            renderBoard();
        }

        // 持ち駒がクリックされたときの処理
        function handleHandPieceClick(pieceType, owner) {
            const normalizedOwner = normalizeOwner(owner);
            if (gameState.gameOver || normalizedOwner !== gameState.currentTurn) return;

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            // 召喚後の場合は、その駒だけを選べるようにする
            if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                // 最後に召喚した駒以外は選べないようにする（実装の簡略化のため省略）
            }

            // 選択をクリア
            gameState.selectedPiece = { type: pieceType, owner: normalizedOwner, fromHand: true };
            gameState.selectedCell = null;
            gameState.possibleMoves = calculateDropPositions(pieceType);

            renderBoard();

            // 召喚後は駒を置くよう促す
            if (gameState.hasSummoned) {
                updateSummonInfo(`召喚した${pieceType}を盤面に打ってください`);
            }
        }

        // 駒を移動
        function movePiece(toX, toY) {
            const { selectedPiece, selectedCell } = gameState;
            const movingOwner = normalizeOwner(selectedPiece.owner) || gameState.currentTurn;

            // 持ち駒を置く場合
            if (selectedPiece.fromHand) {
                // 持ち駒から削除
                const hand = movingOwner === 'sente' ? gameState.senteHand : gameState.goteHand;
                const index = hand.indexOf(selectedPiece.type);
                if (index !== -1) {
                    hand.splice(index, 1);
                }

                // ボードに配置
                gameState.board[toY][toX] = createPiece(selectedPiece.type, movingOwner);

                // 最後の移動を記録
                gameState.lastMove = {
                    fromX: null,
                    fromY: null,
                    toX,
                    toY,
                    isFromHand: true
                };

                playSound('move');

                // 召喚した駒を置いた場合、そのフラグをリセット
                if (gameState.hasSummoned) {
                    gameState.mustPlaceLastSummoned = false;
                    gameState.lastSummonedPiece = null;
                }
            } else {
                // 盤上の駒を移動
                const fromX = selectedCell.x;
                const fromY = selectedCell.y;

                // 移動先に相手の駒があれば持ち駒にする
                const targetPiece = gameState.board[toY][toX];
                if (targetPiece) {
                    // 成り駒は元に戻す
                    let capturedType = targetPiece.type;
                    for (const [original, info] of Object.entries(pieceTypes)) {
                        if (info.promotion === capturedType) {
                            capturedType = original;
                            break;
                        }
                    }

                    // 王や玉は取れない（念のためチェック）
                    if (capturedType !== '王' && capturedType !== '玉') {
                        addPieceToHand(movingOwner, capturedType);
                    }

                    playSound('capture');
                } else {
                    playSound('move');
                }

                // 駒を移動
                gameState.board[toY][toX] = createPiece(selectedPiece.type, movingOwner);
                gameState.board[fromY][fromX] = null;

                // 最後の移動を記録
                gameState.lastMove = { fromX, fromY, toX, toY, isFromHand: false };

                // 成りの確認
                const canPromote = checkCanPromote(fromX, fromY, toX, toY, selectedPiece);
                if (canPromote) {
                    // 成りのダイアログを表示
                    showPromotionDialog(toX, toY, selectedPiece);
                    return; // 処理を中断して成りのダイアログを表示
                }
            }

            // 処理を完了
            finalizeTurnAfterMove();
        }

        // 成りの可能性をチェック
        function checkCanPromote(fromX, fromY, toX, toY, piece) {
            const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
            if (!promotionInfo || !promotionInfo[1].promotion) return false;

            // 成れる条件（敵陣3段目以内に入った、または敵陣から出た）
            const isInPromotionZone = (piece.owner === 'sente' && (toY <= 2 || fromY <= 2)) ||
                (piece.owner === 'gote' && (toY >= 6 || fromY >= 6));

            if (isInPromotionZone) {
                return true;
            }

            // 成らないと動けない場合は自動的に成る
            const mustPromote = (piece.type === '歩' || piece.type === '香') &&
                ((piece.owner === 'sente' && toY === 0) ||
                    (piece.owner === 'gote' && toY === 8)) ||
                (piece.type === '桂' &&
                    ((piece.owner === 'sente' && toY <= 1) ||
                        (piece.owner === 'gote' && toY >= 7)));

            if (mustPromote) {
                // 自動的に成る
                const promoted = promotionInfo[1].promotion;
                gameState.board[toY][toX].type = promoted;
                return false;
            }

            return false;
        }

        // 成りダイアログを表示
        function showPromotionDialog(x, y, piece) {
            const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
            if (!promotionInfo || !promotionInfo[1].promotion) return;

            const promoted = promotionInfo[1].promotion;

            // ダイアログの内容を設定
            promoteOption.textContent = promoted;
            notPromoteOption.textContent = piece.type;

            // 成り駒の位置を記録
            gameState.pendingPromotion = { x, y, piece };

            // ダイアログを表示
            promotionDialog.style.display = 'flex';
        }

        // 成りの選択を処理
        function handlePromotion(doPromote) {
            const { x, y, piece } = gameState.pendingPromotion;

            if (doPromote) {
                const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
                if (promotionInfo && promotionInfo[1].promotion) {
                    gameState.board[y][x].type = promotionInfo[1].promotion;
                }
            }

            // ダイアログを閉じる
            promotionDialog.style.display = 'none';
            gameState.pendingPromotion = null;

            // ターンを完了
            finalizeTurnAfterMove();
        }

        // 駒の移動後にターンを完了
        function finalizeTurnAfterMove() {
            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // 王手をチェック
            checkForCheck();

            // 手番を進める前に相手側の詰みチェック
            const nextPlayer = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
            gameState.currentTurn = nextPlayer; // 一時的に次のプレイヤーにして詰みをチェック

            // チェックメイトをチェック
            if (isCheckmate()) {
                gameState.gameOver = true;
                // 勝者を記録（現在の手番が詰まされているので、元の手番のプレイヤーが勝者）
                gameState.winner = nextPlayer === 'sente' ? 'gote' : 'sente';

                // ゲーム終了処理
                endGame();
                return;
            }

            // 重要: 召喚フラグをリセット
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false;
            gameState.lastSummonedPiece = null;

            const moveId = generateMoveId();
            gameState.lastMoveId = moveId;
            gameState.lastProcessedMoveId = moveId;

            // UI更新
            updateStatus();
            renderBoard();
            renderHands();
            renderSummonPool();
            updateCounters();

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame && !isSpectator) {
                syncGameState();
            }
        }

        // ゲーム終了処理
        function endGame() {
            updateStatus();
            renderBoard();
            updateCounters();
            playSound('gameover');

            // ボタンを無効化
            summonButton.disabled = true;
            passButton.disabled = true;

            // 勝利メッセージをより目立たせる
            const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
            const loserText = gameState.winner === 'sente' ? '後手' : '先手';
            statusElement.innerHTML = `<strong>${winnerText}の勝利！</strong><br>${loserText}の${gameState.winner === 'sente' ? '玉' : '王'}が詰みました`;

            // 詰みの場所をハイライト
            const kingPos = findKing(gameState.winner === 'sente' ? 'gote' : 'sente');
            if (kingPos) {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const x = parseInt(cell.dataset.x);
                    const y = parseInt(cell.dataset.y);
                    if (x === kingPos.x && y === kingPos.y) {
                        cell.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                        cell.style.boxShadow = '0 0 10px red';
                    }
                });
            }

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();

                // リマッチコントロールを表示
                rematchControls.style.display = 'block';
            }

            // ターン表示を更新
            updateTurnIndicator();

            const winner = gameState.winner;
            let outcomeKey = null;
            if (winner) {
                if (isSpectator || !(playerRole === 'sente' || playerRole === 'gote')) {
                    outcomeKey = winner === 'sente' ? 'sente-win' : 'gote-win';
                } else {
                    outcomeKey = winner === playerRole ? 'win' : 'lose';
                }
            }
            if (outcomeKey) {
                showResultOverlay(outcomeKey);
            } else {
                hideResultOverlay(false);
            }
        }

        // 王手の確認
        function checkForCheck() {
            const senteKingPos = findKing('sente');
            const goteKingPos = findKing('gote');

            const senteWasInCheck = gameState.inCheck.sente;
            const goteWasInCheck = gameState.inCheck.gote;

            gameState.inCheck.sente = isPositionUnderAttack(senteKingPos.x, senteKingPos.y, 'gote');
            gameState.inCheck.gote = isPositionUnderAttack(goteKingPos.x, goteKingPos.y, 'sente');

            // 新たに王手になった場合に効果音を再生
            if (!senteWasInCheck && gameState.inCheck.sente ||
                !goteWasInCheck && gameState.inCheck.gote) {
                playSound('check');
            }
        }

        // 詰み判定（シンプルで確実なアルゴリズム）
        function isCheckmate() {
            const currentPlayer = gameState.currentTurn;

            // 王手がかかっていなければ詰みではない
            if ((currentPlayer === 'sente' && !gameState.inCheck.sente) ||
                (currentPlayer === 'gote' && !gameState.inCheck.gote)) {
                return false;
            }

            // 王の位置を取得
            const kingPos = findKing(currentPlayer);
            if (!kingPos) return false; // 念のためチェック

            // すべての可能な手を試す（王の移動、駒の移動、持ち駒の使用）

            // 1. 王が移動できるかチェック
            const kingPiece = gameState.board[kingPos.y][kingPos.x];
            const kingMoves = calculatePossibleMoves(kingPos.x, kingPos.y, kingPiece);

            for (const move of kingMoves) {
                const tmpBoard = cloneBoard(gameState.board);
                // 王を移動
                tmpBoard[move.y][move.x] = tmpBoard[kingPos.y][kingPos.x];
                tmpBoard[kingPos.y][kingPos.x] = null;

                // 移動後も王手されているかチェック
                if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                    // 王手回避できる
                    return false;
                }
            }

            // 2. 他の駒を動かして王手を回避できるかチェック
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = gameState.board[y][x];
                    if (piece && piece.owner === currentPlayer &&
                        (piece.type !== '王' && piece.type !== '玉')) {

                        const moves = calculatePossibleMoves(x, y, piece);
                        for (const move of moves) {
                            const tmpBoard = cloneBoard(gameState.board);
                            // 駒を移動（移動先に相手の駒があれば取る）
                            tmpBoard[move.y][move.x] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            // 移動後も王手されているかチェック
                            if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                                // 王手回避できる
                                return false;
                            }
                        }
                    }
                }
            }

            // 3. 持ち駒を使って王手を回避できるかチェック
            const hand = currentPlayer === 'sente' ? gameState.senteHand : gameState.goteHand;
            const uniquePieces = [...new Set(hand)]; // 重複を排除

            for (const pieceType of uniquePieces) {
                const dropPositions = calculateDropPositions(pieceType);
                for (const pos of dropPositions) {
                    const tmpBoard = cloneBoard(gameState.board);
                    // 持ち駒を配置
                    tmpBoard[pos.y][pos.x] = { type: pieceType, owner: currentPlayer };

                    // 配置後も王手されているかチェック
                    if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                        // 王手回避できる
                        return false;
                    }
                }
            }

            // すべての手を試しても王手を回避できないため詰み
            return true;
        }

        // 盤面をコピー
        function cloneBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        // 指定した盤面で王が王手されているかをチェック
        function isKingInCheckWithBoard(player, board) {
            const kingPos = findKingInBoard(player, board);
            if (!kingPos) return false;

            const opponentPlayer = player === 'sente' ? 'gote' : 'sente';
            return isPositionUnderAttackWithBoard(kingPos.x, kingPos.y, opponentPlayer, board);
        }

        // 指定した盤面で王の位置を探す
        function findKingInBoard(player, board) {
            const kingType = player === 'sente' ? '王' : '玉';

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = board[y][x];
                    if (piece && piece.owner === player && piece.type === kingType) {
                        return { x, y };
                    }
                }
            }

            return null;
        }

        // 王の位置を探す
        function findKing(player) {
            const kingType = player === 'sente' ? '王' : '玉';

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = gameState.board[y][x];
                    if (piece && piece.owner === player && piece.type === kingType) {
                        return { x, y };
                    }
                }
            }

            return null;
        }

        // 位置が攻撃を受けているかチェック
        function isPositionUnderAttack(x, y, attackerPlayer) {
            for (let cy = 0; cy < 9; cy++) {
                for (let cx = 0; cx < 9; cx++) {
                    const piece = gameState.board[cy][cx];
                    if (piece && piece.owner === attackerPlayer) {
                        // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                        const moves = calculateRawPossibleMoves(cx, cy, piece, true);
                        if (moves.some(move => move.x === x && move.y === y)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 盤面で位置が攻撃を受けているかチェック
        function isPositionUnderAttackWithBoard(x, y, attackerPlayer, board) {
            for (let cy = 0; cy < 9; cy++) {
                for (let cx = 0; cx < 9; cx++) {
                    const piece = board[cy][cx];
                    if (piece && piece.owner === attackerPlayer) {
                        // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                        const moves = calculateRawPossibleMovesWithBoard(cx, cy, piece, board, true);
                        if (moves.some(move => move.x === x && move.y === y)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
        function calculateRawPossibleMoves(x, y, piece, checkingAttack = false) {
            return calculateRawPossibleMovesWithBoard(x, y, piece, gameState.board, checkingAttack);
        }

        // 盤面での生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
        function calculateRawPossibleMovesWithBoard(x, y, piece, board, checkingAttack = false) {
            const moves = [];
            const movePatterns = pieceMoves[piece.type];

            if (!movePatterns) return moves;

            for (const pattern of movePatterns) {
                const range = pattern.range || 1;

                for (let i = 1; i <= range; i++) {
                    let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                    let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                    const newX = x + dx * i;
                    const newY = y + dy * i;

                    // ボード外ならスキップ
                    if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                        break;
                    }

                    const targetPiece = board[newY][newX];

                    // 自分の駒があれば移動不可
                    if (targetPiece && targetPiece.owner === piece.owner) {
                        break;
                    }

                    // マスを追加
                    moves.push({ x: newX, y: newY });

                    // 駒があれば次のマスには移動できない
                    if (targetPiece) {
                        break;
                    }
                }
            }

            return moves;
        }

        // 可能な移動先を計算
        function calculatePossibleMoves(x, y, piece, checkingAttack = false) {
            const moves = [];
            const movePatterns = pieceMoves[piece.type];
            const isKing = piece.type === '王' || piece.type === '玉';
            const opponentPlayer = piece.owner === 'sente' ? 'gote' : 'sente';

            if (!movePatterns) return moves;

            for (const pattern of movePatterns) {
                const range = pattern.range || 1;

                for (let i = 1; i <= range; i++) {
                    let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                    let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                    const newX = x + dx * i;
                    const newY = y + dy * i;

                    // ボード外ならスキップ
                    if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                        break;
                    }

                    const targetPiece = gameState.board[newY][newX];

                    // 自分の駒があれば移動不可
                    if (targetPiece && targetPiece.owner === piece.owner) {
                        break;
                    }

                    // 王手チェック時は相手の駒を取れるか確認のみ
                    if (checkingAttack) {
                        moves.push({ x: newX, y: newY });

                        // 駒があれば次のマスには移動できない
                        if (targetPiece) {
                            break;
                        }
                    } else {
                        // 通常の移動チェック
                        // 王手がかかっている場合は、王手を回避する手だけを許可
                        const isChecked = piece.owner === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;

                        // 王の場合は、移動先が相手の利きに入っていないことを確認
                        if (isKing) {
                            // 移動後の盤面をシミュレート
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[newY][newX] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            // 移動先が安全かチェック
                            const wouldBeInCheck = isPositionUnderAttackWithBoard(
                                newX, newY,
                                opponentPlayer,
                                tmpBoard
                            );

                            if (!wouldBeInCheck) {
                                moves.push({ x: newX, y: newY });
                            }
                        } else if (isChecked) {
                            // 王以外の駒で、王手がかかっている場合
                            // 一時的に移動させて王手が解消されるかチェック
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[newY][newX] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            const kingPos = findKing(piece.owner);
                            const isStillChecked = isPositionUnderAttackWithBoard(
                                kingPos.x, kingPos.y,
                                opponentPlayer,
                                tmpBoard
                            );

                            if (!isStillChecked) {
                                moves.push({ x: newX, y: newY });
                            }
                        } else {
                            // 王手がかかっていない通常の状態
                            moves.push({ x: newX, y: newY });
                        }

                        // 駒があれば次のマスには移動できない
                        if (targetPiece) {
                            break;
                        }
                    }
                }
            }

            return moves;
        }

        // 持ち駒を置ける場所を計算
        function calculateDropPositions(pieceType) {
            const positions = [];
            const currentPlayer = gameState.currentTurn;

            // 二歩のチェック用
            const hasPawnInColumn = Array(9).fill(false);
            if (pieceType === '歩') {
                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const piece = gameState.board[y][x];
                        if (piece && piece.type === '歩' && piece.owner === currentPlayer) {
                            hasPawnInColumn[x] = true;
                        }
                    }
                }
            }

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    // 既に駒がある場所には置けない
                    if (gameState.board[y][x]) continue;

                    // 二歩のチェック
                    if (pieceType === '歩' && hasPawnInColumn[x]) continue;

                    // 行き所のない駒のチェック
                    if (pieceType === '歩' || pieceType === '香') {
                        if ((currentPlayer === 'sente' && y === 0) ||
                            (currentPlayer === 'gote' && y === 8)) {
                            continue;
                        }
                    }

                    if (pieceType === '桂') {
                        if ((currentPlayer === 'sente' && y <= 1) ||
                            (currentPlayer === 'gote' && y >= 7)) {
                            continue;
                        }
                    }

                    // 王手回避のチェック
                    const isChecked = currentPlayer === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;
                    if (isChecked) {
                        // 一時的に駒を置いて王手が解消されるかチェック
                        const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                        tmpBoard[y][x] = { type: pieceType, owner: currentPlayer };

                        const kingPos = findKing(currentPlayer);
                        const isStillChecked = isPositionUnderAttackWithBoard(
                            kingPos.x, kingPos.y,
                            currentPlayer === 'sente' ? 'gote' : 'sente',
                            tmpBoard
                        );

                        if (!isStillChecked) {
                            positions.push({ x, y });
                        }
                    } else {
                        // 打ち歩詰めのチェック（歩を打って相手を詰ませることは反則）
                        if (pieceType === '歩') {
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[y][x] = { type: pieceType, owner: currentPlayer };

                            const opponentPlayer = currentPlayer === 'sente' ? 'gote' : 'sente';
                            const opponentKingPos = findKingInBoard(opponentPlayer, tmpBoard);

                            if (opponentKingPos) {
                                // 歩を打った後、相手の王が王手されているかチェック
                                const isOpponentInCheck = isPositionUnderAttackWithBoard(
                                    opponentKingPos.x,
                                    opponentKingPos.y,
                                    currentPlayer,
                                    tmpBoard
                                );

                                if (isOpponentInCheck) {
                                    // 相手が詰んでいるかチェック
                                    const savedBoard = gameState.board;
                                    const savedTurn = gameState.currentTurn;

                                    gameState.board = tmpBoard;
                                    gameState.currentTurn = opponentPlayer;

                                    const isOpponentCheckmated = isCheckmate();

                                    gameState.board = savedBoard;
                                    gameState.currentTurn = savedTurn;

                                    // 打ち歩詰めの場合はこの位置を除外
                                    if (isOpponentCheckmated) {
                                        continue;
                                    }
                                }
                            }
                        }

                        positions.push({ x, y });
                    }
                }
            }

            return positions;
        }

        // 召喚の処理
        function summonPiece() {
            if (gameState.summonPool.length === 0 || gameState.hasSummoned || gameState.gameOver) {
                // もう一度召喚できない理由をログに出力（デバッグ用）
                console.log("召喚できない理由:", {
                    "プールが空": gameState.summonPool.length === 0,
                    "すでに召喚済み": gameState.hasSummoned,
                    "ゲーム終了": gameState.gameOver
                });
                return;
            }

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            // ランダムに一つ選ぶ
            const randomIndex = Math.floor(Math.random() * gameState.summonPool.length);
            const piece = gameState.summonPool[randomIndex];

            // 召喚プールから削除
            gameState.summonPool.splice(randomIndex, 1);

            // 持ち駒に追加
            addPieceToHand(gameState.currentTurn, piece);

            // 召喚済みフラグを立てる
            gameState.hasSummoned = true;
            gameState.mustPlaceLastSummoned = true;
            gameState.lastSummonedPiece = piece;

            // 効果音を再生
            playSound('summon');

            // UIを更新
            renderHands();
            renderSummonPool();
            updateCounters();

            // 召喚情報を更新
            updateSummonInfo(`${piece}を召喚しました！その駒を盤面に打ってください`);

            // 召喚した駒を自動的に選択状態にする
            handleHandPieceClick(piece, gameState.currentTurn);

            // ステータスを更新して次のアクションを促す
            statusElement.textContent = `召喚した${piece}を盤面に打ってください`;
            statusElement.className = 'status';
            statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');

            // パスボタンを無効化（駒を打つ必要があるため）
            passButton.disabled = true;

            // 召喚ボタンの状態を更新
            updateStatus();

            // 移動IDを生成して二重処理を防ぐ
            const moveId = generateMoveId();
            gameState.lastMoveId = moveId;
            gameState.lastProcessedMoveId = moveId;

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }
        }

        // ターンを切り替え
        function switchTurn() {
            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // ターンを切り替え
            gameState.currentTurn = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false;
            gameState.lastSummonedPiece = null;

            // UI更新
            renderBoard();
            updateStatus();
            renderHands();
            renderSummonPool();
            updateCounters();

            // 召喚情報を更新
            if (gameState.summonPool.length > 0) {
                updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');
            } else {
                updateSummonInfo('召喚プールに駒が残っていません。');
            }

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }

            // ターン表示を更新
            updateTurnIndicator();
        }

        // ゲームを初期化
        initGame();
    </script>
</body>

</html>
