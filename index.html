<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>オンライン対戦対応 召喚将棋 (改良版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@600&display=swap');

        :root {
            --board-bg: #E8C99B;
            --board-border: #8B4513;
            --cell-bg: #F0D9B5;
            --cell-hover: #FFE4B5;
            --highlight: #FFFF99;
            --highlight-move: rgba(50, 255, 50, 0.4);
            --highlight-attack: rgba(255, 50, 50, 0.4);
            --main-bg: #F5F5DC;
            --text-color: #333;
            --button-primary: #8B4513;
            --button-hover: #A0522D;
            --button-disabled: #cccccc;
            --sente-color: #000;
            --gote-color: #000;
            --header-bg: #8B4513;
            --header-text: #FFF;
            --promotion-bg: rgba(0, 0, 0, 0.7);
            --chat-bg: #fff;
            --chat-border: #ddd;
            --chat-message-sent: #e1f5fe;
            --chat-message-received: #f5f5f5;
            --piece-sente-bg: #f9e0a2;
            --piece-sente-border: #c19a6b;
            --piece-gote-bg: #f0f0f0;
            --piece-gote-border: #bbbbbb;
            --piece-shadow: rgba(0, 0, 0, 0.3);
            --modal-bg: rgba(0, 0, 0, 0.7);
            --game-list-hover: #f0f0f0;
            --game-list-active: #e6f7ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--main-bg);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            position: relative;
        }

        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            width: 100%;
            padding: 15px 20px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8rem;
            margin: 0;
        }

        .user-info {
            display: flex;
            align-items: center;
            margin-top: 10px;
            color: white;
            font-size: 0.9em;
        }

        .user-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
            color: #333;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }

        .board-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            overflow: auto;
        }

        .coordinates {
            display: flex;
            justify-content: space-around;
            width: 450px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .row-coordinates {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 450px;
            font-weight: bold;
            margin-right: 5px;
        }

        .board-with-coords {
            display: flex;
            align-items: center;
        }

        .board {
            width: 450px;
            height: 450px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            gap: 1px;
            background-color: var(--board-border);
            padding: 2px;
            border: 5px solid var(--board-border);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .board::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23E8C99B" fill-opacity="0.5"/><path d="M0,20 L100,20 M0,40 L100,40 M0,60 L100,60 M0,80 L100,80 M20,0 L20,100 M40,0 L40,100 M60,0 L60,100 M80,0 L80,100" stroke="%238B4513" stroke-width="0.5" stroke-opacity="0.3"/></svg>');
            background-size: 50px 50px;
            opacity: 0.5;
            z-index: 0;
            pointer-events: none;
        }

        .cell {
            background-color: var(--cell-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s ease;
            z-index: 1;
        }

        .cell:hover {
            background-color: var(--cell-hover);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .cell.highlighted {
            background-color: var(--highlight);
        }

        .cell.highlight-move {
            background-color: var(--highlight-move);
        }

        .cell.highlight-attack {
            background-color: var(--highlight-attack);
        }

        .piece {
            width: 90%;
            height: 90%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.5em;
            font-weight: bold;
            user-select: none;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            transform: rotate(0deg);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            transform: rotate(180deg);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .piece.selected {
            box-shadow: 0 0 0 3px #ff0, 0 4px 6px var(--piece-shadow);
            transform: scale(1.1);
        }

        .piece.gote.selected {
            transform: scale(1.1) rotate(180deg);
        }

        .piece.animated {
            animation: pop-in 0.3s ease-out forwards;
        }

        @keyframes pop-in {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .piece.gote.animated {
            animation: pop-in-gote 0.3s ease-out forwards;
        }

        @keyframes pop-in-gote {
            0% { transform: scale(0.5) rotate(180deg); opacity: 0; }
            70% { transform: scale(1.1) rotate(180deg); }
            100% { transform: scale(1) rotate(180deg); opacity: 1; }
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 450px;
        }

        .status-panel {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            background-color: #f0f0f0;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
        }

        .status.sente-turn {
            background-color: #ffe6e6;
        }

        .status.gote-turn {
            background-color: #e6f0ff;
        }

        .status.check {
            background-color: #ffcccc;
            animation: pulse 1.5s infinite;
        }

        .status.gameover {
            background-color: #ffcc00;
            font-size: 1.2em;
            padding: 15px;
            animation: victory-pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes victory-pulse {
            0% { transform: scale(1); background-color: #ffcc00; }
            50% { transform: scale(1.05); background-color: #ffd700; }
            100% { transform: scale(1); background-color: #ffcc00; }
        }

        .hand-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .hand-title {
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hand-title span {
            font-size: 0.9em;
            color: #777;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 60px;
        }

        .hand-piece {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-weight: bold;
            user-select: none;
            transition: all 0.2s ease;
            position: relative;
            cursor: pointer;

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .hand-piece.sente {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            color: var(--sente-color);
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        .hand-piece.gote {
            background-color: var(--piece-gote-bg);
            border: 2px solid var(--piece-gote-border);
            color: var(--gote-color);
            transform: rotate(180deg);
            box-shadow: 0 2px 4px var(--piece-shadow);
        }

        .hand-piece::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .hand-piece:hover {
            background-color: var(--highlight);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .hand-piece.gote:hover {
            transform: translateY(-2px) rotate(180deg);
        }

        .summon-container {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .summon-title {
            margin-bottom: 10px;
            font-weight: bold;
        }

        .summon-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
            margin-bottom: 10px;
        }

        .summon-piece {
            padding: 5px 8px;
            background-color: #f0d9b5;
            border: 1px solid #c19a6b;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 12px;
            background-color: var(--button-primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.2s ease;
            flex: 1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background-color: var(--button-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .rules-container {
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .rules-toggle {
            cursor: pointer;
            color: var(--button-primary);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .rules-toggle::after {
            content: "▼";
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .rules-toggle.open::after {
            transform: rotate(180deg);
        }

        .rules-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .rules-content.show {
            max-height: 800px;
        }

        .rules-content ul, .rules-content ol {
            padding-left: 20px;
            margin: 10px 0;
        }

        .rules-content li {
            margin-bottom: 8px;
        }

        .piece-movement {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .move-diagram {
            text-align: center;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 90px;
            height: 90px;
            margin: 0 auto 5px;
        }

        .move-cell {
            width: 30px;
            height: 30px;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em;
        }

        .move-cell.can-move {
            background-color: var(--highlight);
        }

        .move-cell.piece {
            background-color: #ffedcc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* プロモーションダイアログ */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--promotion-bg);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 300px;
            width: 100%;
        }

        .promotion-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .promotion-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .promotion-option {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Noto Serif JP', serif;
            font-size: 1.8em;
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;

            /* 五角形の形状 */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .promotion-option:nth-child(1) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option:nth-child(2) {
            background-color: var(--piece-sente-bg);
            border: 2px solid var(--piece-sente-border);
            box-shadow: 0 4px 6px var(--piece-shadow);
        }

        .promotion-option::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 50%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: -1;
        }

        .promotion-option:hover {
            background-color: var(--highlight);
            transform: scale(1.1);
        }

        /* オンライン対戦用スタイル */
        .online-controls {
            background-color: white;
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            width: 100%;
            max-width: 450px;
        }

        .online-controls h3 {
            margin-bottom: 15px;
            text-align: center;
            color: var(--board-border);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }

        .tab-button {
            padding: 8px 15px;
            background-color: transparent;
            color: #666;
            border: none;
            border-bottom: 3px solid transparent;
            border-radius: 0;
            box-shadow: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background-color: #f5f5f5;
            box-shadow: none;
        }

        .tab-button.active {
            color: var(--button-primary);
            border-bottom: 3px solid var(--button-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #game-info {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            text-align: center;
        }

        #game-code {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--board-border);
        }

        #player-role {
            font-weight: bold;
        }

        #join-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #game-code-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }

        #join-submit {
            white-space: nowrap;
        }

        .public-games-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .public-game-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .public-game-item:last-child {
            border-bottom: none;
        }

        .public-game-item:hover {
            background-color: var(--game-list-hover);
        }

        .public-game-info {
            display: flex;
            flex-direction: column;
        }

        .public-game-host {
            font-weight: bold;
        }

        .public-game-time {
            font-size: 0.8em;
            color: #888;
        }

        .join-public-button {
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .join-public-button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        .no-games-message {
            padding: 15px;
            text-align: center;
            color: #999;
        }

        .wait-message {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }

        .turn-indicator {
            padding: 5px 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .your-turn {
            background-color: #d4edda;
            color: #155724;
        }

        .opponent-turn {
            background-color: #f8d7da;
            color: #721c24;
        }

        /* リマッチ対応 */
        #rematch-controls {
            display: none;
            margin-top: 15px;
            text-align: center;
        }

        #rematch-button {
            width: 100%;
            background-color: #4caf50;
        }

        #rematch-button:hover {
            background-color: #45a049;
        }

        #rematch-status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }

        /* チャット機能のスタイル */
        .chat-container {
            background-color: var(--chat-bg);
            border: 2px solid var(--board-border);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            display: none;
        }

        .chat-container h3 {
            margin-bottom: 10px;
            text-align: center;
            color: var(--board-border);
        }

        .chat-messages {
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fafafa;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            max-width: 80%;
            word-break: break-word;
        }

        .chat-message.sent {
            background-color: var(--chat-message-sent);
            margin-left: auto;
            border-bottom-right-radius: 0;
        }

        .chat-message.received {
            background-color: var(--chat-message-received);
            margin-right: auto;
            border-bottom-left-radius: 0;
        }

        .chat-message-time {
            font-size: 0.7em;
            color: #888;
            text-align: right;
            margin-top: 2px;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
        }

        #chat-input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--chat-border);
            border-radius: 4px;
            font-size: 1em;
        }

        #chat-submit {
            white-space: nowrap;
            background-color: #4caf50;
        }

        #chat-submit:hover {
            background-color: #45a049;
        }

        /* プリセットメッセージ */
        .preset-messages {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

        .preset-message {
            font-size: 0.8em;
            padding: 5px 8px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-message:hover {
            background-color: #e0e0e0;
        }

        /* ログインモーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--modal-bg);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
        }

        .modal-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: var(--board-border);
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 1em;
        }

        .modal-error {
            color: #dc3545;
            font-size: 0.9em;
            margin-bottom: 15px;
            display: none;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .game-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .board {
                width: 90vw;
                height: 90vw;
                max-width: 450px;
                max-height: 450px;
            }

            .coordinates, .row-coordinates {
                font-size: 0.8em;
            }

            .coordinates {
                width: 90vw;
                max-width: 450px;
            }

            .row-coordinates {
                height: 90vw;
                max-height: 450px;
            }

            .controls,
            .online-controls,
            .chat-container {
                width: 90vw;
                max-width: 450px;
            }

            .piece {
                font-size: 3.5vw;
            }

            .rules-container {
                width: 90vw;
                padding: 15px;
            }

            .button-group {
                flex-direction: column;
            }

            .tab-button {
                padding: 8px 10px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .piece {
                font-size: 4vw;
            }

            .hand-piece {
                width: 35px;
                height: 35px;
                font-size: 0.9em;
            }

            .action-buttons {
                flex-direction: column;
            }
        }

        /* 縦長レイアウト用 (スマホ向け) */
        @media (max-width: 768px) and (orientation: portrait) {
            .game-layout {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            .board-area {
                order: 1;
                margin-bottom: 15px;
                width: 100%;
            }

            .controls {
                order: 2;
                width: 100%;
            }

            .hand-container:first-of-type {
                order: 0;
                margin-bottom: 10px;
            }

            .hand-container:last-of-type {
                order: 3;
                margin-top: 10px;
            }

            .summon-container {
                order: 2;
            }
        }
    </style>

    <!-- Firebase SDK -->
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script> -->
</head>
<body>
    <div class="header">
        <h1>オンライン対戦対応 召喚将棋</h1>
        <div class="user-info" id="user-info" style="display: none;">
            <div class="user-avatar" id="user-avatar">N</div>
            <span id="user-nickname">未ログイン</span>
        </div>
    </div>

    <div class="online-controls">
        <h3>オンライン対戦</h3>

        <div class="tab-buttons">
            <button class="tab-button active" data-tab="create-tab">部屋を作成</button>
            <button class="tab-button" data-tab="join-tab">部屋に参加</button>
        </div>

        <div class="tab-content active" id="create-tab">
            <button id="create-game" class="create-game-button">部屋を作成する</button>
        </div>

        <div class="tab-content" id="join-tab">
            <div class="public-games-list" id="public-games-list">
                <div class="no-games-message">現在公開された部屋はありません</div>
            </div>

            <div id="join-form">
                <input type="text" id="game-code-input" placeholder="ゲームコードを入力して参加">
                <button id="join-submit">参加</button>
            </div>
        </div>

        <div id="game-info" style="display: none;">
            <p>ゲームコード: <span id="game-code"></span></p>
            <p>あなたは<span id="player-role"></span>です</p>
        </div>

        <div id="turn-indicator" class="turn-indicator" style="display: none;">
            待機中...
        </div>

        <div id="rematch-controls" style="display: none;">
            <button id="rematch-button">リマッチを申し込む</button>
            <div id="rematch-status"></div>
        </div>
    </div>

    <div class="chat-container" id="chat-container">
        <h3>チャット</h3>
        <div class="preset-messages">
            <div class="preset-message">よろしくお願いします</div>
            <div class="preset-message">いい勝負でした</div>
            <div class="preset-message">考え中です</div>
            <div class="preset-message">ありがとうございました</div>
            <div class="preset-message">また対戦しましょう</div>
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="メッセージを入力...">
            <button id="chat-submit">送信</button>
        </div>
    </div>

    <div class="game-container game-layout">
        <div class="board-area">
            <div class="coordinates">
                <div>9</div><div>8</div><div>7</div><div>6</div><div>5</div><div>4</div><div>3</div><div>2</div><div>1</div>
            </div>
            <div class="board-with-coords">
                <div class="row-coordinates">
                    <div>一</div><div>二</div><div>三</div><div>四</div><div>五</div><div>六</div><div>七</div><div>八</div><div>九</div>
                </div>
                <div class="board" id="board"></div>
            </div>
        </div>

        <div class="controls">
            <div class="hand-container">
                <div class="hand-title">後手の持ち駒 <span id="gote-count">0枚</span></div>
                <div class="hand" id="gote-hand"></div>
            </div>

            <div class="status-panel">
                <div class="status" id="status">ゲームを開始します</div>
                <div class="action-buttons">
                    <button id="summon-button" disabled>召喚する</button>
                    <button id="pass-button" disabled>パス</button>
                    <button id="reset-button">リセット</button>
                </div>
            </div>

            <div class="summon-container">
                <div class="summon-title">召喚プール <span id="summon-count">38枚</span></div>
                <div class="summon-pool" id="summon-pool"></div>
                <div class="summon-info" id="summon-info">
                    新しい駒を召喚するには「召喚する」ボタンをクリックしてください。
                </div>
                <div style="margin-top: 10px; font-size: 0.85em; color: #8B4513; text-align: center;">
                    ※召喚したら、その駒を必ず盤面に打つ必要があります
                </div>
            </div>

            <div class="hand-container">
                <div class="hand-title">先手の持ち駒 <span id="sente-count">0枚</span></div>
                <div class="hand" id="sente-hand"></div>
            </div>
        </div>
    </div>

    <div class="rules-container">
        <div class="rules-toggle" id="rules-toggle">召喚将棋のルール</div>
        <div class="rules-content" id="rules-content">
            <h3>基本ルール:</h3>
            <ul>
                <li>最初、盤面には王将と玉将のみが初期配置されている（王将は先手側、玉将は後手側）</li>
                <li>残りのコマは「召喚プール」に置いてあり、ランダムに一コマずつ召喚できる</li>
                <li>先行のプレイヤーから交互に以下の選択肢がある:
                    <ol>
                        <li>召喚する（脇によけたコマが無くなるまで一ターンに一回まで）→ 召喚したらその駒を必ず盤面に打つ</li>
                        <li>持ち駒を置く</li>
                        <li>盤上の駒を動かす</li>
                    </ol>
                </li>
                <li>王手などで王が取られる場合はその限りでない（王手への対応が必要）</li>
                <li>初期配置の違いと召喚の選択肢があるだけで、他はクラシカルな将棋のルールと同じ</li>
            </ul>

            <h3>操作方法:</h3>
            <ul>
                <li>駒を動かす: 駒をクリックして、移動可能なマスをクリックする</li>
                <li>持ち駒を使う: 持ち駒をクリックして、置きたいマスをクリックする</li>
                <li>召喚する: 「召喚する」ボタンをクリックする（ターンに1回まで）</li>
                <li>何もしない: 「パス」ボタンをクリックする</li>
                <li>ゲームをリセット: 「リセット」ボタンをクリックする</li>
            </ul>

            <h3>オンライン対戦:</h3>
            <ul>
                <li>「部屋を作成」ボタンをクリックして新しいゲームを開始</li>
                <li>公開された部屋は誰でも参加できます</li>
                <li>ゲームコードを使って特定の相手と対戦することもできます</li>
                <li>先手（部屋作成者）から開始</li>
                <li>ゲーム終了後、「リマッチを申し込む」ボタンでもう一度対戦できます</li>
                <li>チャット機能を使って対戦相手とコミュニケーションが取れます</li>
            </ul>

            <h3>主な駒の動き:</h3>
            <div class="piece-movement">
                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell can-move">←</div>
                        <div class="move-cell piece">王</div>
                        <div class="move-cell can-move">→</div>
                        <div class="move-cell can-move">↙</div>
                        <div class="move-cell can-move">↓</div>
                        <div class="move-cell can-move">↘</div>
                    </div>
                    <div>王将・玉将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell can-move">←</div>
                        <div class="move-cell piece">金</div>
                        <div class="move-cell can-move">→</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↓</div>
                        <div class="move-cell"></div>
                    </div>
                    <div>金将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell can-move">↖</div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell can-move">↗</div>
                        <div class="move-cell"></div>
                        <div class="move-cell piece">銀</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↙</div>
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↘</div>
                    </div>
                    <div>銀将</div>
                </div>

                <div class="move-diagram">
                    <div class="move-grid">
                        <div class="move-cell"></div>
                        <div class="move-cell can-move">↑</div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell piece">歩</div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                        <div class="move-cell"></div>
                    </div>
                    <div>歩兵</div>
                </div>
            </div>
        </div>
    </div>

    <!-- プロモーションダイアログ -->
    <div class="promotion-dialog" id="promotion-dialog">
        <div class="promotion-content">
            <div class="promotion-title">駒を成りますか？</div>
            <div class="promotion-options">
                <div class="promotion-option" id="promote">と</div>
                <div class="promotion-option" id="not-promote">歩</div>
            </div>
            <div>※左が成り駒、右が元の駒です</div>
        </div>
    </div>

    <!-- ログインモーダル -->
    <div class="modal" id="login-modal">
        <div class="modal-content">
            <div class="modal-title">ニックネームを設定</div>
            <p>オンライン対戦を楽しむためのニックネームを入力してください</p>
            <input type="text" id="nickname-input" class="modal-input" placeholder="ニックネーム (2〜10文字)" maxlength="10">
            <div class="modal-error" id="nickname-error">既に使用されているニックネームです。別の名前を入力してください。</div>
            <div class="modal-buttons">
                <button id="login-button">ログイン</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>


    <script>
        // Firebase設定
        const firebaseConfig = {
            apiKey: "AIzaSyAjVQZN--ODV3u-LpDtAUEw1PDoqeapCO8",
            authDomain: "summon-shogi.firebaseapp.com",
            projectId: "summon-shogi",
            storageBucket: "summon-shogi.firebasestorage.app",
            messagingSenderId: "964883817096",
            appId: "1:964883817096:web:da421585a4c97c5715353d",
            measurementId: "G-6SY3BS1VHX"
        };

        // Firebaseの初期化
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Firebaseの初期化コード内または直後に追加
        firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
        .then(() => {
            console.log('認証の永続化を設定しました');
        })
        .catch((error) => {
            console.error('認証の永続化の設定に失敗しました:', error);
        });

        // 認証状態の監視（デバッグ用）
        firebase.auth().onAuthStateChanged(function(user) {
            console.log("認証状態:", user ? "認証済み" : "未認証");
        });

        function listenForGameChanges(gameId) {
        const gameRef = firebase.database().ref(`games/${gameId}`);

        gameRef.on('value', (snapshot) => {
            // ゲームデータの処理
        }, (error) => {
            console.error('ゲームデータの取得エラー:', error);
            if (error.code === 'PERMISSION_DENIED') {
            alert('ゲームデータへのアクセス権限がありません');
            // エラーリカバリー処理
            }
        });
        }

        // ページ読み込み時に実行
        document.addEventListener('DOMContentLoaded', function() {
            // Firebase認証状態の監視
            firebase.auth().onAuthStateChanged(function(user) {
                if (user) {
                console.log('ログイン済み:', user.uid);

                // 前回の対局があれば復帰
                const savedGameId = localStorage.getItem('currentGameId');
                const playerRole = localStorage.getItem('playerRole');

                if (savedGameId) {
                    // 対局が存在するか確認
                    firebase.database().ref(`games/${savedGameId}`).once('value')
                    .then(snapshot => {
                        if (snapshot.exists()) {
                        console.log('前回の対局に復帰します:', savedGameId);
                        listenForGameChanges(savedGameId);
                        } else {
                        // 対局が見つからない場合はローカルストレージをクリア
                        localStorage.removeItem('currentGameId');
                        localStorage.removeItem('playerRole');
                        }
                    });
                }
                }
            });
        });


        // DOMContentLoaded内に追加
        firebase.auth().onAuthStateChanged((user) => {
        console.log('認証状態が変更されました:', user ? 'ログイン中' : '未ログイン');

        if (user) {
            // ユーザーがログインしている場合
            const userNickname = localStorage.getItem('userNickname');
            console.log('ログイン中のユーザー:', user.uid, 'ニックネーム:', userNickname);

            // ニックネームが取得できない場合は再入力を促す
            if (!userNickname || userNickname.length < 2) {
            showNicknameModal();
            }
        } else {
            // 未ログイン状態の場合、匿名ログインを自動実行
            firebase.auth().signInAnonymously()
            .catch((error) => {
                console.error('匿名ログインに失敗しました:', error);
            });
        }
        });


        // オンライン対戦用の変数
        let isOnlineGame = false;
        let gameId = null;
        let playerRole = null; // 'sente'または'gote'
        let opponentConnected = false;
        let rematchOffered = false;
        let rematchAccepted = false;

        // ユーザー認証用の変数
        let userNickname = null;
        let isLoggedIn = false;
        let publicGamesData = []; // 変数名を変更
        let publicGamesRefresh = null;

        // ゲームの状態を管理
        const gameState = {
            currentTurn: 'sente', // 先手（sente）または後手（gote）
            selectedPiece: null,
            selectedCell: null,
            possibleMoves: [],
            board: Array.from({ length: 9 }, () => Array(9).fill(null)),
            senteHand: [],
            goteHand: [],
            summonPool: [],
            hasSummoned: false,
            mustPlaceLastSummoned: false,
            lastSummonedPiece: null,
            gameOver: false,
            winner: null, // 勝者を記録
            inCheck: { sente: false, gote: false },
            lastMove: null,
            pendingPromotion: null
        };

        // 駒の種類と初期数
        const pieceTypes = {
            '歩': { count: 18, promotion: 'と' },
            '香': { count: 4, promotion: '杏' },
            '桂': { count: 4, promotion: '圭' },
            '銀': { count: 4, promotion: '全' },
            '金': { count: 4, promotion: null },
            '角': { count: 2, promotion: '馬' },
            '飛': { count: 2, promotion: '竜' }
        };

        // 駒の動き
        const pieceMoves = {
            '王': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ],
            '玉': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }
            ],
            '金': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '銀': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 1 }, { x: 1, y: 1 }
            ],
            '桂': [
                { x: -1, y: -2 }, { x: 1, y: -2 }
            ],
            '香': [
                { x: 0, y: -1, range: 8 }
            ],
            '角': [
                { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 }
            ],
            '飛': [
                { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 }
            ],
            '歩': [
                { x: 0, y: -1 }
            ],
            'と': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '杏': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '圭': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '全': [
                { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 0 }, { x: 1, y: 0 },
                { x: 0, y: 1 }
            ],
            '馬': [
                { x: -1, y: -1, range: 8 }, { x: 1, y: -1, range: 8 },
                { x: -1, y: 1, range: 8 }, { x: 1, y: 1, range: 8 },
                { x: 0, y: -1 }, { x: -1, y: 0 },
                { x: 1, y: 0 }, { x: 0, y: 1 }
            ],
            '竜': [
                { x: 0, y: -1, range: 8 }, { x: -1, y: 0, range: 8 },
                { x: 1, y: 0, range: 8 }, { x: 0, y: 1, range: 8 },
                { x: -1, y: -1 }, { x: 1, y: -1 },
                { x: -1, y: 1 }, { x: 1, y: 1 }
            ]
        };

        function showNicknameModal() {
            loginModal.style.display = 'flex';
            nicknameInput.focus();
        }

        function generateRandomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // 効果音を無効化（ブラウザの互換性問題を回避）
        const sounds = {
            move: null,
            summon: null,
            capture: null,
            check: null,
            gameover: null
        };

        // DOM要素
        const boardElement = document.getElementById('board');
        const senteHandElement = document.getElementById('sente-hand');
        const goteHandElement = document.getElementById('gote-hand');
        const summonPoolElement = document.getElementById('summon-pool');
        const summonButton = document.getElementById('summon-button');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('reset-button');
        const passButton = document.getElementById('pass-button');
        const rulesToggle = document.getElementById('rules-toggle');
        const rulesContent = document.getElementById('rules-content');
        const summonCountElement = document.getElementById('summon-count');
        const senteCountElement = document.getElementById('sente-count');
        const goteCountElement = document.getElementById('gote-count');
        const summonInfoElement = document.getElementById('summon-info');

        // プロモーションダイアログ
        const promotionDialog = document.getElementById('promotion-dialog');
        const promoteOption = document.getElementById('promote');
        const notPromoteOption = document.getElementById('not-promote');

        // オンライン対戦用のUI要素
        const createGameButton = document.getElementById('create-game');
        const joinGameButton = document.getElementById('join-game');
        const gameInfoElement = document.getElementById('game-info');
        const gameCodeElement = document.getElementById('game-code');
        const playerRoleElement = document.getElementById('player-role');
        const joinFormElement = document.getElementById('join-form');
        const gameCodeInput = document.getElementById('game-code-input');
        const joinSubmitButton = document.getElementById('join-submit');
        const turnIndicator = document.getElementById('turn-indicator');
        const publicGamesListElement = document.getElementById('public-games-list'); // 変数名を変更

        // タブ切り替え用の要素
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // リマッチ用のUI要素
        const rematchControls = document.getElementById('rematch-controls');
        const rematchButton = document.getElementById('rematch-button');
        const rematchStatus = document.getElementById('rematch-status');

        // チャット機能用のUI要素
        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSubmit = document.getElementById('chat-submit');
        const presetMessages = document.querySelectorAll('.preset-message');

        // ログイン機能用のUI要素
        const loginModal = document.getElementById('login-modal');
        const nicknameInput = document.getElementById('nickname-input');
        const loginButton = document.getElementById('login-button');
        const nicknameError = document.getElementById('nickname-error');
        const userInfo = document.getElementById('user-info');
        const userAvatar = document.getElementById('user-avatar');
        const userNicknameElement = document.getElementById('user-nickname');

        // HTML内のscriptタグに追加
        document.addEventListener('DOMContentLoaded', function() {
            const loginButton = document.querySelector('#loginButton') || document.querySelector('button');

            if (loginButton) {
                loginButton.addEventListener('click', function() {
                const nicknameInput = document.querySelector('input').value;

                if (!nicknameInput || nicknameInput.trim().length < 2) {
                    alert('ニックネームは2文字以上入力してください');
                    return;
                }

                // 匿名認証でログイン（既にログイン済みでも再実行して確実にする）
                firebase.auth().signInAnonymously()
                    .then((userCredential) => {
                    const user = userCredential.user;
                    localStorage.setItem('userNickname', nicknameInput);

                    // ユーザー情報をデータベースに保存
                    return firebase.database().ref('users/' + user.uid).set({
                        nickname: nicknameInput,
                        lastLoginAt: firebase.database.ServerValue.TIMESTAMP
                    });
                    })
                    .then(() => {
                    console.log('ログイン成功！');
                    // モーダルを閉じる処理
                    const modal = document.querySelector('.modal');
                    if (modal) modal.style.display = 'none';
                    })
                    .catch((error) => {
                    console.error('ログインエラー:', error);
                    alert('ログインに失敗しました: ' + error.message);
                    });
                });
            }
            // 部屋作成ボタンのイベントリスナー追加
            const createButton = document.querySelector('.部屋を作成する, #createRoomButton');
            if (createButton) {
                createButton.addEventListener('click', handleRoomCreation);
            }
        });

        // イベントハンドラを関数として定義
        function handleRoomCreation() {
        const user = firebase.auth().currentUser;
        const userNickname = localStorage.getItem('userNickname');

        if (!user) {
            console.error('ユーザーがログインしていません');
            firebase.auth().signInAnonymously()
            .then(() => {
                if (userNickname && userNickname.length >= 2) {
                setTimeout(createRoom, 500);
                } else {
                alert('ログインが必要です。ニックネームを入力してください。');
                showNicknameModal();
                }
            })
            .catch(error => {
                console.error('再ログインに失敗:', error);
                alert('ログインに失敗しました。再読み込みしてお試しください。');
            });
            return;
        }

        if (!userNickname || userNickname.length < 2) {
            alert('ニックネームは2文字以上入力してください');
            showNicknameModal();
            return;
        }



        createRoom();
        }


        // ページ読み込み時に実行
        document.addEventListener('DOMContentLoaded', () => {
            // localStorageからユーザー情報を取得
            const savedNickname = localStorage.getItem('userNickname');
            if (savedNickname) {
                // ニックネームがあれば自動ログイン
                checkNicknameAvailability(savedNickname)
                    .then(available => {
                        if (!available) {
                            // 既に使われている場合は改めてログイン
                            showLoginModal();
                        } else {
                            // 使用可能なら登録して自動ログイン
                            registerUser(savedNickname);
                        }
                    });
            } else {
                // ニックネームがない場合はログインモーダルを表示
                showLoginModal();
            }

            // 公開ゲームリストの取得を開始
            startPublicGamesRefresh();
        });

        // タブ切り替え
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                // アクティブなタブを切り替え
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                // 対応するコンテンツを表示
                const tabId = button.getAttribute('data-tab');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
            });
        });

        // オンライン対戦イベントリスナー
        createGameButton.addEventListener('click', () => {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }
            createGameRoom();
        });

        joinSubmitButton.addEventListener('click', () => {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }

            const code = gameCodeInput.value.trim().toUpperCase();
            if (code.length === 6) {
                joinGameRoom(code);
            } else {
                alert('有効なゲームコード（6文字）を入力してください');
            }
        });

        // ログインイベントリスナー
        loginButton.addEventListener('click', () => {
            const nickname = nicknameInput.value.trim();

            // 入力チェック
            if (nickname.length < 2 || nickname.length > 10) {
                nicknameError.textContent = 'ニックネームは2〜10文字で入力してください';
                nicknameError.style.display = 'block';
                return;
            }

            // ニックネームの重複チェック
            checkNicknameAvailability(nickname)
                .then(available => {
                    if (available) {
                        // 使用可能ならユーザー登録
                        registerUser(nickname);
                        hideLoginModal();
                    } else {
                        // 既に使用中の場合はエラー表示
                        nicknameError.textContent = '既に使用されているニックネームです。別の名前を入力してください。';
                        nicknameError.style.display = 'block';
                    }
                });
        });

        // ニックネーム入力でEnterキーの処理
        nicknameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loginButton.click();
            }
        });

        // ニックネームの重複をチェック
        function checkNicknameAvailability(nickname) {
            return database.ref('users').orderByChild('nickname').equalTo(nickname).once('value')
                .then(snapshot => {
                    return !snapshot.exists();
                });
        }

        // ユーザー登録
        function registerUser(nickname) {
            userNickname = nickname;
            isLoggedIn = true;

            // Firebaseにユーザー情報を保存
            const userId = generateUserId();
            database.ref(`users/${userId}`).set({
                nickname: nickname,
                lastLogin: Date.now()
            });

            // localStorageに保存
            localStorage.setItem('userNickname', nickname);
            localStorage.setItem('userId', userId);

            // UI更新
            userNicknameElement.textContent = nickname;
            userAvatar.textContent = nickname.charAt(0).toUpperCase();
            userInfo.style.display = 'flex';

            // 接続時に消えるよう設定
            database.ref(`users/${userId}`).onDisconnect().remove();
        }

        // ユーザーIDを生成
        function generateUserId() {
            return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
        }

        // ログインモーダルを表示
        function showLoginModal() {
            loginModal.style.display = 'flex';
            nicknameInput.focus();
        }

        // ログインモーダルを非表示
        function hideLoginModal() {
            loginModal.style.display = 'none';
            nicknameError.style.display = 'none';
        }

        // 公開ゲームリストの更新を開始
        function startPublicGamesRefresh() {
            // 既存のタイマーがあればクリア
            if (publicGamesRefresh) {
                clearInterval(publicGamesRefresh);
            }

            // 公開ゲームリストを監視
            database.ref('publicGames').on('value', (snapshot) => {
                updatePublicGamesList(snapshot);
            });

            // 5秒ごとに更新
            publicGamesRefresh = setInterval(() => {
                cleanupOldPublicGames();
            }, 5000);
        }

        // 公開ゲームリストを更新
        function updatePublicGamesList(snapshot) {
            // リストをクリア
            publicGamesListElement.innerHTML = '';
            publicGamesData = [];

            if (!snapshot || !snapshot.exists()) {
                publicGamesListElement.innerHTML = '<div class="no-games-message">現在公開された部屋はありません</div>';
                return;
            }

            const games = snapshot.val();
            const gameItems = [];

            // ゲームデータをリストに変換
            for (const gameId in games) {
                const game = games[gameId];
                gameItems.push({
                    id: gameId,
                    host: game.host,
                    createdAt: game.createdAt
                });
            }

            // 新しい順に並べ替え
            gameItems.sort((a, b) => b.createdAt - a.createdAt);

            if (gameItems.length === 0) {
                publicGamesListElement.innerHTML = '<div class="no-games-message">現在公開された部屋はありません</div>';
                return;
            }

            // リストアイテムを生成
            gameItems.forEach(game => {
                const gameItem = document.createElement('div');
                gameItem.className = 'public-game-item';

                const gameInfo = document.createElement('div');
                gameInfo.className = 'public-game-info';

                const hostElement = document.createElement('div');
                hostElement.className = 'public-game-host';
                hostElement.textContent = `${game.host} の部屋`;

                const timeElement = document.createElement('div');
                timeElement.className = 'public-game-time';
                timeElement.textContent = formatTime(game.createdAt);

                gameInfo.appendChild(hostElement);
                gameInfo.appendChild(timeElement);

                const joinButton = document.createElement('button');
                joinButton.className = 'join-public-button';
                joinButton.textContent = '参加する';
                joinButton.addEventListener('click', () => {
                    if (!isLoggedIn) {
                        showLoginModal();
                        return;
                    }
                    joinGameRoom(game.id);
                });

                gameItem.appendChild(gameInfo);
                gameItem.appendChild(joinButton);

                publicGamesListElement.appendChild(gameItem);
            });

            // 公開ゲームリストを保存
            publicGamesData = gameItems;
        }

        // 古い公開ゲームをクリーンアップ
        function cleanupOldPublicGames() {
            const now = Date.now();
            database.ref('publicGames').once('value', (snapshot) => {
                if (!snapshot.exists()) return;

                const games = snapshot.val();
                for (const gameId in games) {
                    const game = games[gameId];

                    // 30分以上経過したゲームを削除
                    if (now - game.createdAt > 30 * 60 * 1000) {
                        database.ref(`publicGames/${gameId}`).remove();
                        database.ref(`games/${gameId}`).remove();
                    }
                }
            });
        }

        // 時間を「〜分前」形式に変換
        function formatTime(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;

            if (diff < 60 * 1000) {
                return 'たった今';
            } else if (diff < 60 * 60 * 1000) {
                return `${Math.floor(diff / (60 * 1000))}分前`;
            } else if (diff < 24 * 60 * 60 * 1000) {
                return `${Math.floor(diff / (60 * 60 * 1000))}時間前`;
            } else {
                return `${Math.floor(diff / (24 * 60 * 60 * 1000))}日前`;
            }
        }

        // リマッチボタンイベントリスナー
        rematchButton.addEventListener('click', offerRematch);

        // チャット機能イベントリスナー
        chatSubmit.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });

        // プリセットメッセージのイベントリスナー
        presetMessages.forEach(msg => {
            msg.addEventListener('click', () => {
                chatInput.value = msg.textContent;
                sendChatMessage();
            });
        });

        // ルールの表示/非表示
        rulesToggle.addEventListener('click', () => {
            rulesContent.classList.toggle('show');
            rulesToggle.classList.toggle('open');
        });

        // ゲームをリセット
        resetButton.addEventListener('click', () => {
            if (isOnlineGame) {
                if (confirm('オンライン対戦中です。ゲームをリセットしますか？')) {
                    // オンライン接続をリセット
                    leaveGameRoom();
                    initGame();
                }
            } else {
                initGame();
            }
        });

        // パスボタン
        passButton.addEventListener('click', () => {
            // 召喚後は駒を置かないとパスできない
            if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                alert('召喚した駒を盤面に打つ必要があります');
                return;
            }

            // 自分のターンでなければパスできない（オンライン時）
            if (isOnlineGame && !isMyTurn()) {
                alert('相手の手番です');
                return;
            }

            // 手番を切り替え
            switchTurn();
            playSound('move');

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }
        });

        // 召喚ボタン
        summonButton.addEventListener('click', summonPiece);

        // プロモーションイベント
        promoteOption.addEventListener('click', () => handlePromotion(true));
        notPromoteOption.addEventListener('click', () => handlePromotion(false));

        // 効果音を再生（現在は無効化しています）
        function playSound(name) {
            // 音声機能は無効化されています
            return;
        }

        // チャットメッセージを送信
        function sendChatMessage() {
            if (!isOnlineGame || !gameId) return;

            const message = chatInput.value.trim();
            if (message === '') return;

            const timestamp = Date.now();
            const sender = playerRole;

            // メッセージをFirebaseに保存
            database.ref(`games/${gameId}/chat/${timestamp}`).set({
                message,
                sender,
                nickname: userNickname,
                timestamp
            });

            // 入力欄をクリア
            chatInput.value = '';

            // UIに自分のメッセージを表示
            displayChatMessage(message, sender, userNickname, timestamp);
        }

        // チャットメッセージを表示
        function displayChatMessage(message, sender, nickname, timestamp) {
            const messageEl = document.createElement('div');
            messageEl.className = `chat-message ${sender === playerRole ? 'sent' : 'received'}`;

            const senderInfo = document.createElement('div');
            senderInfo.style.fontWeight = 'bold';
            senderInfo.style.marginBottom = '3px';
            senderInfo.textContent = sender === playerRole ? 'あなた' : nickname;

            const textEl = document.createElement('div');
            textEl.textContent = message;

            const timeEl = document.createElement('div');
            timeEl.className = 'chat-message-time';

            // タイムスタンプを整形
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            timeEl.textContent = `${hours}:${minutes}`;

            messageEl.appendChild(senderInfo);
            messageEl.appendChild(textEl);
            messageEl.appendChild(timeEl);

            chatMessages.appendChild(messageEl);

            // 最新のメッセージが見えるようにスクロール
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // リマッチを申し込む
        function offerRematch() {
            if (!isOnlineGame || !gameId) return;

            rematchButton.disabled = true;
            rematchStatus.textContent = 'リマッチを申し込み中...';

            // リマッチ情報をFirebaseに保存
            database.ref(`games/${gameId}/rematch/${playerRole}`).set({
                offered: true,
                nickname: userNickname
            });

            // 相手のリマッチ受諾状態をチェック
            const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';
            database.ref(`games/${gameId}/rematch/${opponentRole}`).once('value')
                .then((snapshot) => {
                    if (snapshot.exists() && snapshot.val().offered === true) {
                        // 両者がリマッチを希望
                        startRematch();
                    }
                });
        }

        // リマッチを開始
        function startRematch() {
            rematchStatus.textContent = 'リマッチが成立しました！新しいゲームを開始します...';

            // リマッチフラグをリセット
            database.ref(`games/${gameId}/rematch`).remove();

            // 新しいゲームを開始（ただし同じ部屋）
            initGame();

            // 役割を入れ替え（先手・後手を交代）
            if (playerRole === 'sente') {
                playerRole = 'gote';
                playerRoleElement.textContent = '後手（白）';
            } else {
                playerRole = 'sente';
                playerRoleElement.textContent = '先手（黒）';
            }

            // ゲーム状態をFirebaseに初期化
            syncGameState();

            // リマッチコントロールを更新
            setTimeout(() => {
                rematchButton.disabled = false;
                rematchStatus.textContent = '';
                rematchControls.style.display = 'none';
            }, 3000);

            // 状態を更新
            updateTurnIndicator();
        }

        // 部屋作成関数
        function createGameRoom() {
        // 認証状態の確認
        const user = firebase.auth().currentUser;
        if (!user) {
            console.error('ユーザーがログインしていません');
            alert('ログインが必要です');
            return;
        }

        gameId = generateRandomId(); // または既存のコード方式
        const userNickname = localStorage.getItem('userNickname') || '匿名プレイヤー';

        // 部屋データの構造を修正
        const gameData = {
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            status: 'waiting',
            players: {
            sente: {
                uid: user.uid,
                nickname: userNickname,
                connected: true
            }
            },
            // 初期盤面データも設定
            board: initialBoardState()
        };

        // データベースに保存
        firebase.database().ref(`games/${gameId}`).set(gameData)
            .then(() => {
                console.log('部屋を作成しました:', gameId);

                // グローバル変数に代入しておく（あとで参照するため）
                isOnlineGame = true;
                playerRole = 'sente';
                gameId = gameId; // すでに定義済みでも明示的に再代入しておく

                // プレイヤー情報の保存
                database.ref(`games/${gameId}/players/sente`).set({
                    uid: user.uid,
                    nickname: userNickname,
                    connected: true
                });

                // 接続解除時に削除
                database.ref(`games/${gameId}/players/sente`).onDisconnect().remove();

                // 公開ゲームとしてリストに追加
                database.ref(`publicGames/${gameId}`).set({
                    host: userNickname,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });

                // UIを更新
                gameCodeElement.textContent = gameId;
                playerRoleElement.textContent = '先手（黒）';
                gameInfoElement.style.display = 'block';
                turnIndicator.style.display = 'block';
                updateTurnIndicator();

                // ローカルストレージに保存して復帰できるように
                localStorage.setItem('currentGameId', gameId);
                localStorage.setItem('playerRole', 'sente');

                // リスナーを設定
                listenForGameChanges(gameId);
            })
            .catch(error => {
                console.error('部屋の作成に失敗しました:', error);
                alert('部屋の作成に失敗しました');
            });
        }

        // 部屋の変更を監視する関数
        function listenForGameChanges(gameId) {
        const gameRef = firebase.database().ref(`games/${gameId}`);

        // データ変更をリッスン
        gameRef.on('value', (snapshot) => {
            const gameData = snapshot.val();
            if (!gameData) {
            console.warn('ゲームデータが見つかりません');
            return;
            }

            // ゲームの状態に応じた処理
            updateGameUI(gameData);
        }, (error) => {
            console.error('ゲームデータの取得エラー:', error);
        });
        }

        function initialBoardState() {
        return {
            // 段（横列）を1〜9、筋（縦列）をa〜iで表現
            ranks: {
            1: {
                e: { type: '王将', owner: 'sente' }
            },
            9: {
                e: { type: '王将', owner: 'gote' }
            }
            },
            // 持ち駒情報
            captured: {
            sente: [],
            gote: []
            },
            // 手番（初期値は先手）
            turn: 'sente'
        };
        }



        // ゲームルームに参加（後手として）
        function joinGameRoom(roomId) {
            if (!isLoggedIn) {
                showLoginModal();
                return;
            }

            gameId = roomId.toUpperCase();
            playerRole = 'gote';
            isOnlineGame = true;

            // ゲーム状態を読み込み
            database.ref(`games/${gameId}`).once('value')
                .then((snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();

                        // ゲーム状態を反映
                        function safeParse(obj) {
                            if (typeof obj === 'string') {
                                try {
                                    return JSON.parse(obj);
                                } catch (e) {
                                    console.error('JSONパースエラー:', e);
                                    return null;
                                }
                            }
                            return obj;
                        }

                        gameState.board = safeParse(data.board) || Array.from({ length: 9 }, () => Array(9).fill(null));
                        gameState.senteHand = safeParse(data.senteHand) || [];
                        gameState.goteHand = safeParse(data.goteHand) || [];
                        gameState.summonPool = safeParse(data.summonPool) || [];
                        gameState.currentTurn = data.currentTurn || 'sente';
                        gameState.hasSummoned = data.hasSummoned || false;
                        gameState.mustPlaceLastSummoned = data.mustPlaceLastSummoned || false;
                        gameState.gameOver = data.gameOver || false;
                        gameState.winner = data.winner || null;

                        // UI更新
                        renderBoard();
                        renderHands();
                        renderSummonPool();
                        updateStatus();
                        updateCounters();

                        // 自分の接続状態を記録
                        database.ref(`games/${gameId}/players/gote`).set({
                            nickname: userNickname,
                            connected: true
                        });

                        // 切断時に自分の接続状態を削除
                        database.ref(`games/${gameId}/players/gote`).onDisconnect().remove();

                        // 相手の接続状態を監視
                        database.ref(`games/${gameId}/players/sente`).on('value', (snapshot) => {
                            opponentConnected = snapshot.exists();
                            updateTurnIndicator();

                            // 対戦相手が接続したらチャット機能を有効化
                            if (opponentConnected) {
                                chatContainer.style.display = 'block';

                                // 公開ゲームリストから削除（満員になったため）
                                database.ref(`publicGames/${gameId}`).remove();
                            }
                        });

                        // ゲーム状態の変更を監視
                        listenForGameChanges(gameId);

                        // チャットメッセージの監視
                        listenForChatMessages();

                        // リマッチ申し込みの監視
                        listenForRematchOffers();

                        // UI更新
                        gameCodeElement.textContent = gameId;
                        playerRoleElement.textContent = '後手（白）';
                        gameInfoElement.style.display = 'block';
                        joinFormElement.style.display = 'block';
                        createGameButton.disabled = true;
                        joinGameButton.disabled = true;
                        turnIndicator.style.display = 'block';

                        updateTurnIndicator();
                    } else {
                        alert('指定されたゲームルームが見つかりません');
                        joinFormElement.style.display = 'block';
                        createGameButton.disabled = false;
                    }
                })
                .catch((error) => {
                    console.error('ゲームルームへの参加エラー:', error);
                    alert('ゲームルームへの参加中にエラーが発生しました');
                    joinFormElement.style.display = 'block';
                    createGameButton.disabled = false;
                });
        }

        // ゲームルームから離脱
        function leaveGameRoom() {
            if (isOnlineGame && gameId) {
                // 監視を解除
                database.ref(`games/${gameId}`).off();

                // 自分の接続状態を削除
                if (playerRole === 'sente') {
                    database.ref(`games/${gameId}/players/sente`).remove();
                    // 公開ゲームリストからも削除
                    database.ref(`publicGames/${gameId}`).remove();
                } else {
                    database.ref(`games/${gameId}/players/gote`).remove();
                }

                // リセット
                isOnlineGame = false;
                gameId = null;
                playerRole = null;
                opponentConnected = false;

                // UI更新
                gameInfoElement.style.display = 'none';
                turnIndicator.style.display = 'none';
                rematchControls.style.display = 'none';
                chatContainer.style.display = 'none';
                createGameButton.disabled = false;
                joinGameButton.disabled = false;
            }
        }

        // ゲーム状態の変更を監視
        function listenForGameChanges() {
            database.ref(`games/${gameId}`).on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    alert('ゲームルームが削除されました');
                    leaveGameRoom();
                    initGame();
                    return;
                }

                const data = snapshot.val();

                // 自分のターンでない場合のみ状態を更新
                if (!isMyTurn() || data.lastUpdate > (gameState.lastUpdate || 0)) {
                    gameState.board = JSON.parse(data.board ?? 'null') || Array.from({ length: 9 }, () => Array(9).fill(null));
                    gameState.senteHand = JSON.parse(data.senteHand);
                    gameState.goteHand = JSON.parse(data.goteHand);
                    gameState.summonPool = JSON.parse(data.summonPool);
                    gameState.currentTurn = data.currentTurn;
                    gameState.hasSummoned = data.hasSummoned;
                    gameState.mustPlaceLastSummoned = data.mustPlaceLastSummoned || false;
                    gameState.gameOver = data.gameOver || false;
                    gameState.winner = data.winner || null;
                    gameState.lastUpdate = data.lastUpdate;

                    // 自分のターンになった場合は通知
                    if (isMyTurn() && gameState.currentTurn !== gameState.previousTurn) {
                        updateTurnIndicator();
                    }

                    gameState.previousTurn = gameState.currentTurn;

                    // UI更新
                    renderBoard();
                    renderHands();
                    renderSummonPool();
                    updateStatus();
                    updateCounters();

                    // ゲーム終了時はリマッチコントロールを表示
                    if (gameState.gameOver) {
                        rematchControls.style.display = 'block';
                    }
                }
            });
        }

        // チャットメッセージを監視
        function listenForChatMessages() {
            database.ref(`games/${gameId}/chat`).on('child_added', (snapshot) => {
                const message = snapshot.val();

                // 自分が送信したメッセージは既に表示済みなのでスキップ
                if (message.sender !== playerRole) {
                    displayChatMessage(message.message, message.sender, message.nickname, message.timestamp);
                }
            });
        }

        // リマッチ申し込みを監視
        function listenForRematchOffers() {
            const opponentRole = playerRole === 'sente' ? 'gote' : 'sente';

            database.ref(`games/${gameId}/rematch/${opponentRole}`).on('value', (snapshot) => {
                if (snapshot.exists() && snapshot.val().offered === true) {
                    // 相手からリマッチ申し込みが来た
                    const opponentNickname = snapshot.val().nickname;
                    rematchStatus.textContent = `${opponentNickname}さんからリマッチの申し込みがあります`;
                    rematchControls.style.display = 'block';

                    // 自分もリマッチを申し込んでいる場合は開始
                    database.ref(`games/${gameId}/rematch/${playerRole}`).once('value')
                        .then((mySnapshot) => {
                            if (mySnapshot.exists() && mySnapshot.val().offered === true) {
                                startRematch();
                            }
                        });
                }
            });
        }

        // ゲーム状態をFirebaseに同期
        function syncGameState() {
            if (isOnlineGame && gameId) {
                gameState.lastUpdate = Date.now();

                database.ref(`games/${gameId}`).update({
                    board: JSON.stringify(gameState.board),
                    senteHand: JSON.stringify(gameState.senteHand),
                    goteHand: JSON.stringify(gameState.goteHand),
                    summonPool: JSON.stringify(gameState.summonPool),
                    currentTurn: gameState.currentTurn,
                    hasSummoned: gameState.hasSummoned,
                    mustPlaceLastSummoned: gameState.mustPlaceLastSummoned,
                    gameOver: gameState.gameOver,
                    winner: gameState.winner,
                    lastUpdate: gameState.lastUpdate
                });

                updateTurnIndicator();
            }
        }

        // 自分のターンかどうかを確認
        function isMyTurn() {
            return !isOnlineGame ||
                   (playerRole === 'sente' && gameState.currentTurn === 'sente') ||
                   (playerRole === 'gote' && gameState.currentTurn === 'gote');
        }

        // ターン表示を更新
        function updateTurnIndicator() {
            if (!isOnlineGame) {
                turnIndicator.style.display = 'none';
                return;
            }

            turnIndicator.style.display = 'block';

            if (!opponentConnected) {
                turnIndicator.textContent = '対戦相手の接続を待っています...';
                turnIndicator.className = 'turn-indicator';
                return;
            }

            if (gameState.gameOver) {
                const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                turnIndicator.textContent = `ゲーム終了 - ${winnerText}の勝利`;
                turnIndicator.className = 'turn-indicator';

                // ゲーム終了時はリマッチコントロールを表示
                rematchControls.style.display = 'block';
                return;
            }

            if (isMyTurn()) {
                turnIndicator.textContent = 'あなたの手番です';
                turnIndicator.className = 'turn-indicator your-turn';
            } else {
                turnIndicator.textContent = '相手の手番です';
                turnIndicator.className = 'turn-indicator opponent-turn';
            }
        }

        // ゲームを初期化
        function initGame() {
            // ボードをクリア
            gameState.board = Array(9).fill().map(() => Array(9).fill(null));
            gameState.senteHand = [];
            gameState.goteHand = [];
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];
            gameState.currentTurn = 'sente';
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false; // 召喚した駒を置かなければならないフラグ
            gameState.lastSummonedPiece = null; // 最後に召喚した駒の種類
            gameState.gameOver = false;
            gameState.winner = null; // 勝者をリセット
            gameState.inCheck = { sente: false, gote: false };
            gameState.lastMove = null;
            gameState.pendingPromotion = null;

            // 召喚プールを初期化
            gameState.summonPool = [];
            for (const [piece, info] of Object.entries(pieceTypes)) {
                for (let i = 0; i < info.count; i++) {
                    gameState.summonPool.push(piece);
                }
            }

            // 王将と玉将を初期配置
            gameState.board[8][4] = { type: '王', owner: 'sente' };
            gameState.board[0][4] = { type: '玉', owner: 'gote' };

            // UIを更新
            renderBoard();
            renderHands();
            renderSummonPool();
            updateStatus();
            updateCounters();

            // 召喚ボタンを有効化
            updateButtonsState();

            // 召喚情報を更新
            updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }
        }

        // ボタンの状態を更新
        function updateButtonsState() {
            const canAct = !isOnlineGame || isMyTurn();

            // 召喚ボタンの状態
            summonButton.disabled = gameState.summonPool.length === 0 ||
                                   gameState.hasSummoned ||
                                   gameState.gameOver ||
                                   !canAct;

            // パスボタンの状態
            passButton.disabled = gameState.gameOver ||
                                (gameState.hasSummoned && gameState.mustPlaceLastSummoned) ||
                                !canAct;
        }

        // カウンターを更新
        function updateCounters() {
            summonCountElement.textContent = `${gameState.summonPool.length}枚`;
            senteCountElement.textContent = `${gameState.senteHand.length}枚`;
            goteCountElement.textContent = `${gameState.goteHand.length}枚`;
        }

        // 召喚情報を更新
        function updateSummonInfo(text) {
            summonInfoElement.textContent = text;
        }

        // ボードをレンダリング
        function renderBoard() {
            boardElement.innerHTML = '';

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    // 駒があれば表示
                    const piece = gameState.board[y][x];
                    if (piece && piece.type) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.owner}`;
                        if (gameState.selectedCell && gameState.selectedCell.x === x && gameState.selectedCell.y === y) {
                            pieceElement.classList.add('selected');
                        }

                        // 最後に動かした駒にアニメーションを適用
                        if (gameState.lastMove && gameState.lastMove.toX === x && gameState.lastMove.toY === y) {
                            pieceElement.classList.add('animated');
                        }

                        pieceElement.textContent = piece.type;
                        cell.appendChild(pieceElement);
                    }

                    // セルのハイライト
                    if (gameState.possibleMoves.some(move => {
                        if (move.x === x && move.y === y) {
                            const targetPiece = gameState.board[y][x];
                            if (targetPiece && targetPiece.owner !== gameState.currentTurn) {
                                cell.classList.add('highlight-attack');
                            } else {
                                cell.classList.add('highlight-move');
                            }
                            return true;
                        }
                        return false;
                    })) {
                        // ハイライトは上記のif文で適用済み
                    }

                    // クリックイベント
                    cell.addEventListener('click', () => handleCellClick(x, y));

                    boardElement.appendChild(cell);
                }
            }
        }

        // 持ち駒をレンダリング
        function renderHands() {
            // 先手の持ち駒
            senteHandElement.innerHTML = '';

            // 持ち駒を種類ごとに集計
            const senteHandCount = gameState.senteHand.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 持ち駒を種類順に並べる
            const sortedSentePieces = Object.keys(senteHandCount).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedSentePieces) {
                const count = senteHandCount[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'hand-piece sente';
                pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                pieceElement.dataset.type = piece;
                pieceElement.addEventListener('click', () => {
                    if (isOnlineGame && playerRole !== 'sente') return; // オンライン対戦時は自分の持ち駒だけ
                    handleHandPieceClick(piece, 'sente');
                });
                senteHandElement.appendChild(pieceElement);
            }

            // 後手の持ち駒
            goteHandElement.innerHTML = '';

            // 持ち駒を種類ごとに集計
            const goteHandCount = gameState.goteHand.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 持ち駒を種類順に並べる
            const sortedGotePieces = Object.keys(goteHandCount).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedGotePieces) {
                const count = goteHandCount[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'hand-piece gote';
                pieceElement.textContent = count > 1 ? `${piece}${count}` : piece;
                pieceElement.dataset.type = piece;
                pieceElement.addEventListener('click', () => {
                    if (isOnlineGame && playerRole !== 'gote') return; // オンライン対戦時は自分の持ち駒だけ
                    handleHandPieceClick(piece, 'gote');
                });
                goteHandElement.appendChild(pieceElement);
            }
        }

        // 召喚プールをレンダリング
        function renderSummonPool() {
            summonPoolElement.innerHTML = '';

            // 召喚プールの駒の数を表示
            const pieceCounts = gameState.summonPool.reduce((acc, piece) => {
                acc[piece] = (acc[piece] || 0) + 1;
                return acc;
            }, {});

            // 駒を種類順に並べる
            const sortedPieces = Object.keys(pieceCounts).sort((a, b) => {
                const pieceOrder = ['歩', '香', '桂', '銀', '金', '角', '飛'];
                return pieceOrder.indexOf(a) - pieceOrder.indexOf(b);
            });

            for (const piece of sortedPieces) {
                const count = pieceCounts[piece];
                const pieceElement = document.createElement('div');
                pieceElement.className = 'summon-piece';
                pieceElement.textContent = `${piece}×${count}`;
                summonPoolElement.appendChild(pieceElement);
            }

            // ボタンの状態を更新
            updateButtonsState();
        }

        // ステータスを更新
        function updateStatus() {
            statusElement.className = 'status';

            if (gameState.gameOver) {
                const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
                statusElement.textContent = `${winnerText}の勝利！`;
                statusElement.classList.add('gameover');
            } else if (gameState.inCheck.sente) {
                statusElement.textContent = '先手の王が王手です！';
                statusElement.classList.add('check');
            } else if (gameState.inCheck.gote) {
                statusElement.textContent = '後手の玉が王手です！';
                statusElement.classList.add('check');
            } else {
                statusElement.textContent = gameState.currentTurn === 'sente' ? '先手の手番です' : '後手の手番です';
                statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');
            }

            // ボタンの状態を更新
            updateButtonsState();
        }

        // セルがクリックされたときの処理
        function handleCellClick(x, y) {
            if (gameState.gameOver) return;

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            const clickedPiece = gameState.board[y][x];

            // 選択中の駒があり、有効な移動先がクリックされた場合
            if (gameState.selectedPiece && gameState.possibleMoves.some(move => move.x === x && move.y === y)) {
                movePiece(x, y);
                return;
            }

            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // 自分の駒をクリックした場合
            if (clickedPiece && clickedPiece.owner === gameState.currentTurn) {
                gameState.selectedPiece = clickedPiece;
                gameState.selectedCell = { x, y };
                gameState.possibleMoves = calculatePossibleMoves(x, y, clickedPiece);
            }

            renderBoard();
        }

        // 持ち駒がクリックされたときの処理
        function handleHandPieceClick(pieceType, owner) {
            if (gameState.gameOver || owner !== gameState.currentTurn) return;

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            // 召喚後の場合は、その駒だけを選べるようにする
            if (gameState.hasSummoned && gameState.mustPlaceLastSummoned) {
                // 最後に召喚した駒以外は選べないようにする（実装の簡略化のため省略）
            }

            // 選択をクリア
            gameState.selectedPiece = { type: pieceType, owner, fromHand: true };
            gameState.selectedCell = null;
            gameState.possibleMoves = calculateDropPositions(pieceType);

            renderBoard();

            // 召喚後は駒を置くよう促す
            if (gameState.hasSummoned) {
                updateSummonInfo(`召喚した${pieceType}を盤面に打ってください`);
            }
        }

        // 駒を移動
        function movePiece(toX, toY) {
            const { selectedPiece, selectedCell } = gameState;

            // 持ち駒を置く場合
            if (selectedPiece.fromHand) {
                // 持ち駒から削除
                const hand = selectedPiece.owner === 'sente' ? gameState.senteHand : gameState.goteHand;
                const index = hand.indexOf(selectedPiece.type);
                if (index !== -1) {
                    hand.splice(index, 1);
                }

                // ボードに配置
                gameState.board[toY][toX] = {
                    type: selectedPiece.type,
                    owner: selectedPiece.owner
                };

                // 最後の移動を記録
                gameState.lastMove = {
                    fromX: null,
                    fromY: null,
                    toX,
                    toY,
                    isFromHand: true
                };

                playSound('move');

                // 召喚した駒を置いた場合、そのフラグをリセット
                if (gameState.hasSummoned) {
                    gameState.mustPlaceLastSummoned = false;
                    gameState.lastSummonedPiece = null;
                }
            } else {
                // 盤上の駒を移動
                const fromX = selectedCell.x;
                const fromY = selectedCell.y;

                // 移動先に相手の駒があれば持ち駒にする
                const targetPiece = gameState.board[toY][toX];
                if (targetPiece) {
                    // 成り駒は元に戻す
                    let capturedType = targetPiece.type;
                    for (const [original, info] of Object.entries(pieceTypes)) {
                        if (info.promotion === capturedType) {
                            capturedType = original;
                            break;
                        }
                    }

                    // 王や玉は取れない（念のためチェック）
                    if (capturedType !== '王' && capturedType !== '玉') {
                        if (gameState.currentTurn === 'sente') {
                            gameState.senteHand.push(capturedType);
                        } else {
                            gameState.goteHand.push(capturedType);
                        }
                    }

                    playSound('capture');
                } else {
                    playSound('move');
                }

                // 駒を移動
                gameState.board[toY][toX] = {
                    type: selectedPiece.type,
                    owner: selectedPiece.owner
                };
                gameState.board[fromY][fromX] = null;

                // 最後の移動を記録
                gameState.lastMove = { fromX, fromY, toX, toY, isFromHand: false };

                // 成りの確認
                const canPromote = checkCanPromote(fromX, fromY, toX, toY, selectedPiece);
                if (canPromote) {
                    // 成りのダイアログを表示
                    showPromotionDialog(toX, toY, selectedPiece);
                    return; // 処理を中断して成りのダイアログを表示
                }
            }

            // 処理を完了
            finalizeTurnAfterMove();
        }

        // 成りの可能性をチェック
        function checkCanPromote(fromX, fromY, toX, toY, piece) {
            const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
            if (!promotionInfo || !promotionInfo[1].promotion) return false;

            // 成れる条件（敵陣3段目以内に入った、または敵陣から出た）
            const isInPromotionZone = (piece.owner === 'sente' && (toY <= 2 || fromY <= 2)) ||
                                     (piece.owner === 'gote' && (toY >= 6 || fromY >= 6));

            if (isInPromotionZone) {
                return true;
            }

            // 成らないと動けない場合は自動的に成る
            const mustPromote = (piece.type === '歩' || piece.type === '香') &&
                               ((piece.owner === 'sente' && toY === 0) ||
                                (piece.owner === 'gote' && toY === 8)) ||
                               (piece.type === '桂' &&
                                ((piece.owner === 'sente' && toY <= 1) ||
                                 (piece.owner === 'gote' && toY >= 7)));

            if (mustPromote) {
                // 自動的に成る
                const promoted = promotionInfo[1].promotion;
                gameState.board[toY][toX].type = promoted;
                return false;
            }

            return false;
        }

        // 成りダイアログを表示
        function showPromotionDialog(x, y, piece) {
            const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
            if (!promotionInfo || !promotionInfo[1].promotion) return;

            const promoted = promotionInfo[1].promotion;

            // ダイアログの内容を設定
            promoteOption.textContent = promoted;
            notPromoteOption.textContent = piece.type;

            // 成り駒の位置を記録
            gameState.pendingPromotion = { x, y, piece };

            // ダイアログを表示
            promotionDialog.style.display = 'flex';
        }

        // 成りの選択を処理
        function handlePromotion(doPromote) {
            const { x, y, piece } = gameState.pendingPromotion;

            if (doPromote) {
                const promotionInfo = Object.entries(pieceTypes).find(([type, info]) => type === piece.type);
                if (promotionInfo && promotionInfo[1].promotion) {
                    gameState.board[y][x].type = promotionInfo[1].promotion;
                }
            }

            // ダイアログを閉じる
            promotionDialog.style.display = 'none';
            gameState.pendingPromotion = null;

            // ターンを完了
            finalizeTurnAfterMove();
        }

        // 駒の移動後にターンを完了
        function finalizeTurnAfterMove() {
            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // 王手をチェック
            checkForCheck();

            // 手番を進める前に相手側の詰みチェック
            const nextPlayer = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
            gameState.currentTurn = nextPlayer; // 一時的に次のプレイヤーにして詰みをチェック

            // チェックメイトをチェック
            if (isCheckmate()) {
                gameState.gameOver = true;
                // 勝者を記録（現在の手番が詰まされているので、元の手番のプレイヤーが勝者）
                gameState.winner = nextPlayer === 'sente' ? 'gote' : 'sente';

                // ゲーム終了処理
                endGame();
                return;
            }

            // 重要: 召喚フラグをリセット
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false;
            gameState.lastSummonedPiece = null;

            // UI更新
            updateStatus();
            renderBoard();
            renderHands();
            renderSummonPool();
            updateCounters();

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }
        }

        // ゲーム終了処理
        function endGame() {
            updateStatus();
            renderBoard();
            updateCounters();
            playSound('gameover');

            // ボタンを無効化
            summonButton.disabled = true;
            passButton.disabled = true;

            // 勝利メッセージをより目立たせる
            const winnerText = gameState.winner === 'sente' ? '先手' : '後手';
            const loserText = gameState.winner === 'sente' ? '後手' : '先手';
            statusElement.innerHTML = `<strong>${winnerText}の勝利！</strong><br>${loserText}の${gameState.winner === 'sente' ? '玉' : '王'}が詰みました`;

            // 詰みの場所をハイライト
            const kingPos = findKing(gameState.winner === 'sente' ? 'gote' : 'sente');
            if (kingPos) {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const x = parseInt(cell.dataset.x);
                    const y = parseInt(cell.dataset.y);
                    if (x === kingPos.x && y === kingPos.y) {
                        cell.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                        cell.style.boxShadow = '0 0 10px red';
                    }
                });
            }

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();

                // リマッチコントロールを表示
                rematchControls.style.display = 'block';
            }

            // ターン表示を更新
            updateTurnIndicator();
        }

        // 王手の確認
        function checkForCheck() {
            const senteKingPos = findKing('sente');
            const goteKingPos = findKing('gote');

            const senteWasInCheck = gameState.inCheck.sente;
            const goteWasInCheck = gameState.inCheck.gote;

            gameState.inCheck.sente = isPositionUnderAttack(senteKingPos.x, senteKingPos.y, 'gote');
            gameState.inCheck.gote = isPositionUnderAttack(goteKingPos.x, goteKingPos.y, 'sente');

            // 新たに王手になった場合に効果音を再生
            if (!senteWasInCheck && gameState.inCheck.sente ||
                !goteWasInCheck && gameState.inCheck.gote) {
                playSound('check');
            }
        }

        // 詰み判定（シンプルで確実なアルゴリズム）
        function isCheckmate() {
            const currentPlayer = gameState.currentTurn;

            // 王手がかかっていなければ詰みではない
            if ((currentPlayer === 'sente' && !gameState.inCheck.sente) ||
                (currentPlayer === 'gote' && !gameState.inCheck.gote)) {
                return false;
            }

            // 王の位置を取得
            const kingPos = findKing(currentPlayer);
            if (!kingPos) return false; // 念のためチェック

            // すべての可能な手を試す（王の移動、駒の移動、持ち駒の使用）

            // 1. 王が移動できるかチェック
            const kingPiece = gameState.board[kingPos.y][kingPos.x];
            const kingMoves = calculatePossibleMoves(kingPos.x, kingPos.y, kingPiece);

            for (const move of kingMoves) {
                const tmpBoard = cloneBoard(gameState.board);
                // 王を移動
                tmpBoard[move.y][move.x] = tmpBoard[kingPos.y][kingPos.x];
                tmpBoard[kingPos.y][kingPos.x] = null;

                // 移動後も王手されているかチェック
                if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                    // 王手回避できる
                    return false;
                }
            }

            // 2. 他の駒を動かして王手を回避できるかチェック
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = gameState.board[y][x];
                    if (piece && piece.owner === currentPlayer &&
                        (piece.type !== '王' && piece.type !== '玉')) {

                        const moves = calculatePossibleMoves(x, y, piece);
                        for (const move of moves) {
                            const tmpBoard = cloneBoard(gameState.board);
                            // 駒を移動（移動先に相手の駒があれば取る）
                            tmpBoard[move.y][move.x] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            // 移動後も王手されているかチェック
                            if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                                // 王手回避できる
                                return false;
                            }
                        }
                    }
                }
            }

            // 3. 持ち駒を使って王手を回避できるかチェック
            const hand = currentPlayer === 'sente' ? gameState.senteHand : gameState.goteHand;
            const uniquePieces = [...new Set(hand)]; // 重複を排除

            for (const pieceType of uniquePieces) {
                const dropPositions = calculateDropPositions(pieceType);
                for (const pos of dropPositions) {
                    const tmpBoard = cloneBoard(gameState.board);
                    // 持ち駒を配置
                    tmpBoard[pos.y][pos.x] = { type: pieceType, owner: currentPlayer };

                    // 配置後も王手されているかチェック
                    if (!isKingInCheckWithBoard(currentPlayer, tmpBoard)) {
                        // 王手回避できる
                        return false;
                    }
                }
            }

            // すべての手を試しても王手を回避できないため詰み
            return true;
        }

        // 盤面をコピー
        function cloneBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        // 指定した盤面で王が王手されているかをチェック
        function isKingInCheckWithBoard(player, board) {
            const kingPos = findKingInBoard(player, board);
            if (!kingPos) return false;

            const opponentPlayer = player === 'sente' ? 'gote' : 'sente';
            return isPositionUnderAttackWithBoard(kingPos.x, kingPos.y, opponentPlayer, board);
        }

        // 指定した盤面で王の位置を探す
        function findKingInBoard(player, board) {
            const kingType = player === 'sente' ? '王' : '玉';

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = board[y][x];
                    if (piece && piece.owner === player && piece.type === kingType) {
                        return { x, y };
                    }
                }
            }

            return null;
        }

        // 王の位置を探す
        function findKing(player) {
            const kingType = player === 'sente' ? '王' : '玉';

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const piece = gameState.board[y][x];
                    if (piece && piece.owner === player && piece.type === kingType) {
                        return { x, y };
                    }
                }
            }

            return null;
        }

        // 位置が攻撃を受けているかチェック
        function isPositionUnderAttack(x, y, attackerPlayer) {
            for (let cy = 0; cy < 9; cy++) {
                for (let cx = 0; cx < 9; cx++) {
                    const piece = gameState.board[cy][cx];
                    if (piece && piece.owner === attackerPlayer) {
                        // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                        const moves = calculateRawPossibleMoves(cx, cy, piece, true);
                        if (moves.some(move => move.x === x && move.y === y)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 盤面で位置が攻撃を受けているかチェック
        function isPositionUnderAttackWithBoard(x, y, attackerPlayer, board) {
            for (let cy = 0; cy < 9; cy++) {
                for (let cx = 0; cx < 9; cx++) {
                    const piece = board[cy][cx];
                    if (piece && piece.owner === attackerPlayer) {
                        // 攻撃可能かどうかをチェック（checkingAttack=trueで他の駒は考慮しない）
                        const moves = calculateRawPossibleMovesWithBoard(cx, cy, piece, board, true);
                        if (moves.some(move => move.x === x && move.y === y)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
        function calculateRawPossibleMoves(x, y, piece, checkingAttack = false) {
            return calculateRawPossibleMovesWithBoard(x, y, piece, gameState.board, checkingAttack);
        }

        // 盤面での生の移動可能先を計算（王手回避やセーフティチェックを考慮しない）
        function calculateRawPossibleMovesWithBoard(x, y, piece, board, checkingAttack = false) {
            const moves = [];
            const movePatterns = pieceMoves[piece.type];

            if (!movePatterns) return moves;

            for (const pattern of movePatterns) {
                const range = pattern.range || 1;

                for (let i = 1; i <= range; i++) {
                    let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                    let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                    const newX = x + dx * i;
                    const newY = y + dy * i;

                    // ボード外ならスキップ
                    if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                        break;
                    }

                    const targetPiece = board[newY][newX];

                    // 自分の駒があれば移動不可
                    if (targetPiece && targetPiece.owner === piece.owner) {
                        break;
                    }

                    // マスを追加
                    moves.push({ x: newX, y: newY });

                    // 駒があれば次のマスには移動できない
                    if (targetPiece) {
                        break;
                    }
                }
            }

            return moves;
        }

        // 可能な移動先を計算
        function calculatePossibleMoves(x, y, piece, checkingAttack = false) {
            const moves = [];
            const movePatterns = pieceMoves[piece.type];
            const isKing = piece.type === '王' || piece.type === '玉';
            const opponentPlayer = piece.owner === 'sente' ? 'gote' : 'sente';

            if (!movePatterns) return moves;

            for (const pattern of movePatterns) {
                const range = pattern.range || 1;

                for (let i = 1; i <= range; i++) {
                    let dx = pattern.x * (piece.owner === 'gote' ? -1 : 1);
                    let dy = pattern.y * (piece.owner === 'gote' ? -1 : 1);

                    const newX = x + dx * i;
                    const newY = y + dy * i;

                    // ボード外ならスキップ
                    if (newX < 0 || newX >= 9 || newY < 0 || newY >= 9) {
                        break;
                    }

                    const targetPiece = gameState.board[newY][newX];

                    // 自分の駒があれば移動不可
                    if (targetPiece && targetPiece.owner === piece.owner) {
                        break;
                    }

                    // 王手チェック時は相手の駒を取れるか確認のみ
                    if (checkingAttack) {
                        moves.push({ x: newX, y: newY });

                        // 駒があれば次のマスには移動できない
                        if (targetPiece) {
                            break;
                        }
                    } else {
                        // 通常の移動チェック
                        // 王手がかかっている場合は、王手を回避する手だけを許可
                        const isChecked = piece.owner === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;

                        // 王の場合は、移動先が相手の利きに入っていないことを確認
                        if (isKing) {
                            // 移動後の盤面をシミュレート
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[newY][newX] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            // 移動先が安全かチェック
                            const wouldBeInCheck = isPositionUnderAttackWithBoard(
                                newX, newY,
                                opponentPlayer,
                                tmpBoard
                            );

                            if (!wouldBeInCheck) {
                                moves.push({ x: newX, y: newY });
                            }
                        } else if (isChecked) {
                            // 王以外の駒で、王手がかかっている場合
                            // 一時的に移動させて王手が解消されるかチェック
                            const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                            tmpBoard[newY][newX] = tmpBoard[y][x];
                            tmpBoard[y][x] = null;

                            const kingPos = findKing(piece.owner);
                            const isStillChecked = isPositionUnderAttackWithBoard(
                                kingPos.x, kingPos.y,
                                opponentPlayer,
                                tmpBoard
                            );

                            if (!isStillChecked) {
                                moves.push({ x: newX, y: newY });
                            }
                        } else {
                            // 王手がかかっていない通常の状態
                            moves.push({ x: newX, y: newY });
                        }

                        // 駒があれば次のマスには移動できない
                        if (targetPiece) {
                            break;
                        }
                    }
                }
            }

            return moves;
        }

        // 持ち駒を置ける場所を計算
        function calculateDropPositions(pieceType) {
            const positions = [];
            const currentPlayer = gameState.currentTurn;

            // 二歩のチェック用
            const hasPawnInColumn = Array(9).fill(false);
            if (pieceType === '歩') {
                for (let y = 0; y < 9; y++) {
                    for (let x = 0; x < 9; x++) {
                        const piece = gameState.board[y][x];
                        if (piece && piece.type === '歩' && piece.owner === currentPlayer) {
                            hasPawnInColumn[x] = true;
                        }
                    }
                }
            }

            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    // 既に駒がある場所には置けない
                    if (gameState.board[y][x]) continue;

                    // 二歩のチェック
                    if (pieceType === '歩' && hasPawnInColumn[x]) continue;

                    // 行き所のない駒のチェック
                    if (pieceType === '歩' || pieceType === '香') {
                        if ((currentPlayer === 'sente' && y === 0) ||
                            (currentPlayer === 'gote' && y === 8)) {
                            continue;
                        }
                    }

                    if (pieceType === '桂') {
                        if ((currentPlayer === 'sente' && y <= 1) ||
                            (currentPlayer === 'gote' && y >= 7)) {
                            continue;
                        }
                    }

                    // 王手回避のチェック
                    const isChecked = currentPlayer === 'sente' ? gameState.inCheck.sente : gameState.inCheck.gote;
                    if (isChecked) {
                        // 一時的に駒を置いて王手が解消されるかチェック
                        const tmpBoard = JSON.parse(JSON.stringify(gameState.board));
                        tmpBoard[y][x] = { type: pieceType, owner: currentPlayer };

                        const kingPos = findKing(currentPlayer);
                        const isStillChecked = isPositionUnderAttackWithBoard(
                            kingPos.x, kingPos.y,
                            currentPlayer === 'sente' ? 'gote' : 'sente',
                            tmpBoard
                        );

                        if (!isStillChecked) {
                            positions.push({ x, y });
                        }
                    } else {
                        positions.push({ x, y });
                    }
                }
            }

            return positions;
        }

        // 召喚の処理
        function summonPiece() {
            if (gameState.summonPool.length === 0 || gameState.hasSummoned || gameState.gameOver) {
                // もう一度召喚できない理由をログに出力（デバッグ用）
                console.log("召喚できない理由:", {
                    "プールが空": gameState.summonPool.length === 0,
                    "すでに召喚済み": gameState.hasSummoned,
                    "ゲーム終了": gameState.gameOver
                });
                return;
            }

            // オンライン対戦時は自分のターンのみ操作可能
            if (isOnlineGame && !isMyTurn()) {
                return;
            }

            // ランダムに一つ選ぶ
            const randomIndex = Math.floor(Math.random() * gameState.summonPool.length);
            const piece = gameState.summonPool[randomIndex];

            // 召喚プールから削除
            gameState.summonPool.splice(randomIndex, 1);

            // 持ち駒に追加
            if (gameState.currentTurn === 'sente') {
                gameState.senteHand.push(piece);
            } else {
                gameState.goteHand.push(piece);
            }

            // 召喚済みフラグを立てる
            gameState.hasSummoned = true;
            gameState.mustPlaceLastSummoned = true;
            gameState.lastSummonedPiece = piece;

            // 効果音を再生
            playSound('summon');

            // UIを更新
            renderHands();
            renderSummonPool();
            updateCounters();

            // 召喚情報を更新
            updateSummonInfo(`${piece}を召喚しました！その駒を盤面に打ってください`);

            // 召喚した駒を自動的に選択状態にする
            handleHandPieceClick(piece, gameState.currentTurn);

            // ステータスを更新して次のアクションを促す
            statusElement.textContent = `召喚した${piece}を盤面に打ってください`;
            statusElement.className = 'status';
            statusElement.classList.add(gameState.currentTurn === 'sente' ? 'sente-turn' : 'gote-turn');

            // パスボタンを無効化（駒を打つ必要があるため）
            passButton.disabled = true;

            // 召喚ボタンの状態を更新
            updateStatus();

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }
        }

        // ターンを切り替え
        function switchTurn() {
            // 選択をクリア
            gameState.selectedPiece = null;
            gameState.selectedCell = null;
            gameState.possibleMoves = [];

            // ターンを切り替え
            gameState.currentTurn = gameState.currentTurn === 'sente' ? 'gote' : 'sente';
            gameState.hasSummoned = false;
            gameState.mustPlaceLastSummoned = false;
            gameState.lastSummonedPiece = null;

            // UI更新
            renderBoard();
            updateStatus();
            renderHands();
            renderSummonPool();
            updateCounters();

            // 召喚情報を更新
            if (gameState.summonPool.length > 0) {
                updateSummonInfo('新しい駒を召喚するには「召喚する」ボタンをクリックしてください。');
            } else {
                updateSummonInfo('召喚プールに駒が残っていません。');
            }

            // オンライン対戦の場合は状態を同期
            if (isOnlineGame) {
                syncGameState();
            }

            // ターン表示を更新
            updateTurnIndicator();
        }

        // ゲームを初期化
        initGame();
    </script>
</body>
</html>
